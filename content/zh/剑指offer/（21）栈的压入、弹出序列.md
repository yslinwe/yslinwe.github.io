---
title: "剑指office（二十一）栈的压入、弹出序列"
date: 2020-04-30
description: "剑指office（二十一）栈的压入、弹出序列"
draft: false
hideToc: false
enableToc: true
enableTocContent: true
author: YSL
authorEmoji: 🎅
pinned: true
tags:
- 剑指office
series:
- 剑指office
categories:
- 剑指office
weight: 3
image: https://cdn.pixabay.com/photo/2021/03/26/23/53/house-6127137__340.jpg
---

### 题目描述

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

### 示例1

#### 输入

```
[1,2,3,4,5],[4,3,5,1,2]
```

#### 返回值

```
false
```

```c++
class Solution {
public:
    bool IsPopOrder(vector<int> pushV,vector<int> popV) {
        bool result = false;
        stack<int> leftS;
        stack<int> rightS;
        int pushVSize = pushV.size();
        int popVSize = popV.size();
        int j = 0;
        bool isLeft = true;
        for(int i = 0;i<pushVSize;i++)
        {
            if(pushV[i] == popV[j])
            {
                j++;
                isLeft = !isLeft;
            }else
            {
                if(isLeft)
                    leftS.push(pushV[i]);
                else
                    rightS.push(pushV[i]);
            }
        }
        if(j>=popVSize)
            return true;
       int left = 0;
        int right = 0;
        while(j<popVSize)
        {
            left = leftS.empty()?NULL:leftS.top();
            right = rightS.empty()?NULL:rightS.top();
            
            if(popV[j]==left)
            {
                 leftS.pop();
                 result = true;
            }
            else if(popV[j]==right)
            {
                rightS.pop();
                result = true;
            }
            else
            {
                result = false;
                break;
            }
            j++;
        }
        return result;
    }
};
```