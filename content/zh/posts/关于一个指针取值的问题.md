---
title: "关于一个指针取值的问题"
summary: 关于一个指针取值的问题
date: 2021-05-21
tags: ["关于一个指针取值的问题"]
author: "YSL"
draft: false
weight: 2
---
题目描述：

char szNum[]="123456789";
int n=*(short*)(szNum+4)- *(short*)(szNum);

问n = ？


答案大家可以编程实现，n=1028。就这题来说，无论是小端还是大端 都是1028。


看你的系统是小端还是大端可以用下面这个函数测试：


//如果字节序为big-endian，返回true;
//反之为   little-endian，返回false
 
bool IsBig_Endian()
{
    unsigned short test = 0x1234;
    if(*( (unsigned char*) &test ) == 0x12)
       return TRUE;
   else
       return FALSE;
}//IsBig_Endian()


*(short*)(szNum+4)  这句话 首先是将szNum + 4 这个字符型地址 强制转换成short型地址，因为地址都是4个字节存储的，所以值不会变。也就是说，这个地址由指向字符的地址变成了指向short型变量的地址了。而这个地址值没有变。那么这个区别在哪里呢？

因为地址指向的都是相同的地方，那么区别就在于取值了。


如果是小端，那么计算机存储的是高位在高地址，低位在低地址，而short型是两个字节的变量。所以(short*)(szNum+4) 这个指向的值是低位，它只指了一个字节，而short有两个字节，而第二个字节就是这个地址的下一个地址所指向的值，这个值就是高位，例如问题里，szNum+4 指向的是字符‘5’，这个只是一个字节，它代表的是低位，而下一个字节自然就是字符‘6’，它代表的是高位，所以*(short*)(szNum+4)取出来的值就是0x36 35 ，这里因为字符’5‘的十六进制为35 字符‘6’的十六进制为36 所以取出的即为此值。

同理取*(short*)(szNum) 也是这个原理，取‘1’， ‘2’ 两个字节，值为0x32 31 ，结果即为0x36 35 - 0x32 31 = 1028


如果是大端，就只是将高低位转换一下，和小端类似，小端对计算机易于处理，而大端符合人类正常思维。
————————————————
版权声明：本文为CSDN博主「娜一笑最倾城」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/ljd4305/article/details/8929345