---
title: "基于用户的协同过滤推荐算法原理和实现"
summary: 基于用户的协同过滤推荐算法原理和实现
date: 2022-04-01
tags: ["js"]
author: "YSL"
draft: false
weight: 2
---

#### 1. 发现兴趣相似的用户

   通常用 Jaccard 公式或者余弦相似度计算两个用户之间的相似度。设 N(u) 为用户 u 喜欢的物品集合，N(v) 为用户 v 喜欢的物品集合，那么 u 和 v 的相似度是多少呢：

   Jaccard 公式：

![img](https://images0.cnblogs.com/blog2015/70278/201504/292243027244041.png)

   余弦相似度：

![img](https://images0.cnblogs.com/blog2015/70278/201504/292245154114469.png)

   假设目前共有4个用户： A、B、C、D；共有5个物品：a、b、c、d、e。用户与物品的关系（用户喜欢物品）如下图所示：

![img](https://images0.cnblogs.com/blog2015/70278/201504/292257329433249.png)

   如何一下子计算所有用户之间的相似度呢？为计算方便，通常首先需要建立“物品—用户”的倒排表，如下图所示：

![img](https://images0.cnblogs.com/blog2015/70278/201504/292301482716246.png)

   然后对于每个物品，喜欢他的用户，两两之间相同物品加1。例如喜欢物品 a 的用户有 A 和 B，那么在矩阵中他们两两加1。如下图所示：

![img](https://images0.cnblogs.com/blog2015/70278/201504/292313403659929.png)

   计算用户两两之间的相似度，上面的矩阵仅仅代表的是公式的分子部分。以余弦相似度为例，对上图进行进一步计算：

![img](https://images0.cnblogs.com/blog2015/70278/201504/300220294273266.png)

   到此，计算用户相似度就大功告成，可以很直观的找到与目标用户兴趣较相似的用户。

#### 2. 推荐物品

   首先需要从矩阵中找出与目标用户 u 最相似的 K 个用户，用集合 S(u, K) 表示，将 S 中用户喜欢的物品全部提取出来，并去除 u 已经喜欢的物品。对于每个候选物品 i ，用户 u 对它感兴趣的程度用如下公式计算：

![img](https://images0.cnblogs.com/blog2015/70278/201504/292340566307942.png)

   其中 rvi 表示用户 v 对 i 的喜欢程度，在本例中都是为 1，在一些需要用户给予评分的推荐系统中，则要代入用户评分。

   举个例子，假设我们要给 A 推荐物品，选取 K = 3 个相似用户，相似用户则是：B、C、D，那么他们喜欢过并且 A 没有喜欢过的物品有：c、e，那么分别计算 p(A, c) 和 p(A, e)：

![img](https://images0.cnblogs.com/blog2015/70278/201504/292347569434600.png)

![img](https://images0.cnblogs.com/blog2015/70278/201504/292349095052333.png)

   看样子用户 A 对 c 和 e 的喜欢程度可能是一样的，在真实的推荐系统中，只要按得分排序，取前几个物品就可以了。