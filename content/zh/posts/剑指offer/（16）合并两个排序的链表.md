---
title: "剑指office（十六）合并两个排序的链表"
date: 2020-04-25
description: "剑指office（十六）合并两个排序的链表"
draft: false
hideToc: false
enableToc: true
enableTocContent: false
author: YSL
authorEmoji: 🎅
pinned: false
tags:
- 剑指office
series:
- 剑指office
categories:
- 剑指office
weight: 3
image: https://cdn.pixabay.com/photo/2021/04/22/02/05/snow-6197832__340.jpg
type: "notshow"
---

### 题目描述

输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

### 示例1

#### 输入

```
{1,3,5},{2,4,6}
```

#### 返回值

```
{1,2,3,4,5,6}
```

```c++
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
        ListNode* result = NULL;
        ListNode* cur = NULL;
        if(!pHead1)
            return pHead2;
        if(!pHead2)
            return pHead1;
        while(pHead1||pHead2)
        {
            if(pHead1&&pHead2)
            {   if(pHead1->val>=pHead2->val)
                {
                    ListNode* temp = pHead2->next;
                    if(!result)
                    {
                        result = pHead2;
                        cur = result;
                    }
                    else
                    {
                       result->next = pHead2;
                       result = result->next;
                    }
                        
                    pHead2 = temp;
                }
                 else
                {
                    ListNode* temp = pHead1->next;
                    if(!result)
                    {
                       result = pHead1;
                        cur = result;
                    }
                    else
                    {
                       result->next = pHead1;
                       result = result->next;
                    }
                    pHead1 = temp;
                }
            }
            else
            {
                if(pHead1)
                {
                    result->next = pHead1;
                }
                else
                {
                    result->next = pHead2;
                }
                break;
            }
        }
        return cur;
    }
};
```
```c++
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
        ListNode* result = new ListNode(-1);
        ListNode* cur = result;
        if(!pHead1)
            return pHead2;
        if(!pHead2)
            return pHead1;
        while(pHead1||pHead2)
        {
            if(pHead1&&pHead2)
            {   if(pHead1->val>=pHead2->val)
                {
                   
                       result->next = pHead2;
                        pHead2 = pHead2->next;
                   
                }
                 else
                {
                  
                       result->next = pHead1;
                        pHead1 = pHead1->next;
                }
                result = result->next;

            }
            else
            {
                result->next = pHead1?pHead1:pHead2;
                break;
            }
        }
        return cur->next;
    }
};
```
```c++
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
        if(!pHead1)
            return pHead2;
        if(!pHead2)
            return pHead1;
        if(pHead1->val>=pHead2->val)
        {
            pHead2->next = Merge(pHead1,pHead2->next);
            return pHead2;
        }else
        {
            pHead1->next = Merge(pHead1->next, pHead2);
            return pHead1;
        }
    }
};
```