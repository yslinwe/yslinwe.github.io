[{"content":"使用Unity Hub安装Unity Unity Hub快速安装链接\n或者直接从下面链接下载\n使用方式 用浏览器打开链接 选择打开unity hub\nUnity 2021.2（α）：\n1  unityhub://2021.2.0a10/b8c2bb7e8b36   Unity 2021.1：\n1  unityhub://2021.1.0f1/61a549675243   Unity 2020.3（LTS）：\n1 2 3  unityhub://2020.3.2f1/8fd9074bf66c unityhub://2020.3.1f1/77a89f25062f unityhub://2020.3.0f1/c7b5465681fb   Unity 2020.2：\n1 2 3 4 5 6 7 8  unityhub://2020.2.7f1/c53830e277f1 unityhub://2020.2.6f1/8a2143876886 unityhub://2020.2.5f1/e2c53f129de5 unityhub://2020.2.4f1/becced5a802b unityhub://2020.2.3f1/8ff31bc5bf5b unityhub://2020.2.2f1/068178b99f32 unityhub://2020.2.1f1/270dd8c3da1c unityhub://2020.2.0f1/3721df5a8b28   Unity 2020.1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  unityhub://2020.1.17f1/9957aee8edc2 unityhub://2020.1.16f1/f483ad6465d6 unityhub://2020.1.15f1/97d0ae02d19d unityhub://2020.1.14f1/d81f64f5201d unityhub://2020.1.13f1/5e24f28bfbc0 unityhub://2020.1.12f1/55b56f0a86e3 unityhub://2020.1.11f1/698c1113cef0 unityhub://2020.1.10f1/974a9d56f159 unityhub://2020.1.9f1/145f5172610f unityhub://2020.1.8f1/22e8c0b0c3ec unityhub://2020.1.7f1/064ffcdb64ad unityhub://2020.1.6f1/fc477ca6df10 unityhub://2020.1.5f1/e025938fdedc unityhub://2020.1.4f1/fa717bb873ec unityhub://2020.1.3f1/cf5c4788e1d8 unityhub://2020.1.2f1/7b32bc54ba47 unityhub://2020.1.1f1/2285c3239188 unityhub://2020.1.0f1/2ab9c4179772   Unity 2019.4（LTS）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  unityhub://2019.4.20f1/6dd1c08eedfa unityhub://2019.4.19f1/ca5b14067cec unityhub://2019.4.18f1/3310a4d4f880 unityhub://2019.4.17f1/667c8606c536 unityhub://2019.4.16f1/e05b6e02d63e unityhub://2019.4.15f1/fbf367ac14e9 unityhub://2019.4.14f1/4037e52648cd unityhub://2019.4.13f1/518737b1de84 unityhub://2019.4.12f1/225e826a680e unityhub://2019.4.11f1/2d9804dddde7 unityhub://2019.4.10f1/5311b3af6f69 unityhub://2019.4.9f1/50fe8a171dd9 unityhub://2019.4.8f1/60781d942082 unityhub://2019.4.7f1/e992b1a16e65 unityhub://2019.4.6f1/a7aea80e3716 unityhub://2019.4.5f1/81610f64359c unityhub://2019.4.4f1/1f1dac67805b unityhub://2019.4.3f1/f880dceab6fe unityhub://2019.4.2f1/20b4642a3455 unityhub://2019.4.1f1/e6c045e14e4e unityhub://2019.4.0f1/0af376155913   Unity 2019.3：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  unityhub://2019.3.15f1/59ff3e03856d unityhub://2019.3.14f1/2b330bf6d2d8 unityhub://2019.3.13f1/d4ddf0d95db9 unityhub://2019.3.12f1/84b23722532d unityhub://2019.3.11f1/ceef2d848e70 unityhub://2019.3.10f1/5968d7f82152 unityhub://2019.3.9f1/e6e740a1c473 unityhub://2019.3.8f1/4ba98e9386ed unityhub://2019.3.8f1/4ba98e9386ed unityhub://2019.3.7f1/6437fd74d35d unityhub://2019.3.6f1/5c3fb0a11183 unityhub://2019.3.5f1/d691e07d38ef unityhub://2019.3.4f1/4f139db2fdbd unityhub://2019.3.3f1/7ceaae5f7503 unityhub://2019.3.2f1/c46a3a38511e unityhub://2019.3.1f1/89d6087839c2 unityhub://2019.3.0f6/27ab2135bccf   Unity 2019.2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  unityhub://2019.2.21f1/9d528d026557 unityhub://2019.2.20f1/c67d00285037 unityhub://2019.2.19f1/929ab4d01772 unityhub://2019.2.18f1/bbf64de26e34 unityhub://2019.2.17f1/8e603399ca02 unityhub://2019.2.16f1/b9898e2d04a4 unityhub://2019.2.15f1/dcb72c2e9334 unityhub://2019.2.14f1/49dd4e9fa428 unityhub://2019.2.13f1/e20f6c7e5017 unityhub://2019.2.12f1/b1a7e1fb4fa5 unityhub://2019.2.11f1/5f859a4cfee5 unityhub://2019.2.10f1/923acd2d43aa unityhub://2019.2.9f1/ebce4d76e6e8 unityhub://2019.2.8f1/ff5b465c8d13 unityhub://2019.2.7f2/c96f78eb5904 unityhub://2019.2.6f1/fe82a0e88406 unityhub://2019.2.5f1/9dace1eed4cc unityhub://2019.2.4f1/c63b2af89a85 unityhub://2019.2.3f1/8e55c27a4621 unityhub://2019.2.2f1/ab112815d860 unityhub://2019.2.1f1/ca4d5af0be6f unityhub://2019.2.0f1/20c1667945cf   Unity 2019.1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  unityhub://2019.1.14f1/148b5891095a unityhub://2019.1.13f1/b5956c0a61e7 unityhub://2019.1.12f1/f04f5427219e unityhub://2019.1.11f1/9b001d489a54 unityhub://2019.1.10f1/f007ed779b7a unityhub://2019.1.9f1/d5f1b37da199 unityhub://2019.1.8f1/7938dd008a75 unityhub://2019.1.7f1/f3c4928e5742 unityhub://2019.1.6f1/f2970305fe1c unityhub://2019.1.5f1/0ca0f5646614 unityhub://2019.1.4f1/ffa3a7a2dd7d unityhub://2019.1.3f1/dc414eb9ed43 unityhub://2019.1.2f1/3e18427e571f unityhub://2019.1.1f1/fef62e97e63b unityhub://2019.1.0f2/292b93d75a2c   Unity 2018.4 (LTS) ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  unityhub://2018.4.32f1/fba45da84107 unityhub://2018.4.31f1/212ea663d844 unityhub://2018.4.30f1/c698a062d8e6 unityhub://2018.4.29f1/50cce2edf27f unityhub://2018.4.28f1/a2d4f71491a4 unityhub://2018.4.27f1/4e283b7d3f88 unityhub://2018.4.26f1/a7ac1c6396db unityhub://2018.4.25f1/b07bfa0a8827 unityhub://2018.4.24f1/3071911a89e9 unityhub://2018.4.23f1/c9cf1a90e812 unityhub://2018.4.22f1/3362ffbb7aa1 unityhub://2018.4.21f1/fd3915227633 unityhub://2018.4.20f1/008688490035 unityhub://2018.4.19f1/459f70f82ea4 unityhub://2018.4.18f1/61fce66342ad unityhub://2018.4.17f1/b830f56f42f0 unityhub://2018.4.16f1/e6e9ca02b32a unityhub://2018.4.15f1/13f5a1bf9ca1 unityhub://2018.4.14f1/05119b33d0b7 unityhub://2018.4.13f1/497f083a43af unityhub://2018.4.12f1/59ddc4c59b4f unityhub://2018.4.11f1/7098af2f11ea unityhub://2018.4.10f1/a0470569e97b unityhub://2018.4.9f1/ca372476eaba unityhub://2018.4.8f1/9bc9d983d803 unityhub://2018.4.7f1/b9a993fd1334 unityhub://2018.4.6f1/cde1bbcc9f0d unityhub://2018.4.5f1/7b38f8ac282e unityhub://2018.4.4f1/5440768ff61c unityhub://2018.4.3f1/8a9509a5aff9 unityhub://2018.4.2f1/d6fb3630ea75 unityhub://2018.4.1f1/b7c424a951c0 unityhub://2018.4.0f1/b6ffa8986c8d   Unity 2018.3：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  unityhub://2018.3.14f1/d0e9f15437b1 unityhub://2018.3.13f1/06548a9e9582 unityhub://2018.3.12f1/8afd630d1f5b unityhub://2018.3.11f1/5063218e4ab8 unityhub://2018.3.10f1/f88de2c96e63 unityhub://2018.3.9f1/947e1ea5aa8d unityhub://2018.3.8f1/fc0fe30d6d91 unityhub://2018.3.7f1/9e14d22a41bb unityhub://2018.3.6f1/a220877bc173 unityhub://2018.3.5f1/76b3e37670a4 unityhub://2018.3.4f1/1d952368ca3a unityhub://2018.3.3f1/393bae82dbb8 unityhub://2018.3.2f1/b3c100a4b73a unityhub://2018.3.1f1/bb579dc42f1d unityhub://2018.3.0f2/6e9a27477296   Unity 2018.2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  unityhub://2018.2.21f1/a122f5dc316d unityhub://2018.2.20f1/cef3e6c0c622 unityhub://2018.2.19f1/06990f28ba00 unityhub://2018.2.18f1/4550892b6062 unityhub://2018.2.17f1/88933597c842 unityhub://2018.2.16f1/39a4ac3d51f6 unityhub://2018.2.15f1/65e0713a5949 unityhub://2018.2.14f1/3262fb3b0716 unityhub://2018.2.13f1/83fbdcd35118 unityhub://2018.2.12f1/0a46ddfcfad4 unityhub://2018.2.11f1/38bd7dec5000 unityhub://2018.2.10f1/674aa5a67ed5 unityhub://2018.2.9f1/2207421190e9 unityhub://2018.2.8f1/ae1180820377 unityhub://2018.2.7f1/4ebd28dd9664 unityhub://2018.2.6f1/c591d9a97a0b unityhub://2018.2.5f1/3071d1717b71 unityhub://2018.2.4f1/cb262d9ddeaf unityhub://2018.2.3f1/1431a7d2ced7 unityhub://2018.2.2f1/c18cef34cbcd unityhub://2018.2.1f1/1a9968d9f99c unityhub://2018.2.0f2/787658998520   Unity 2018.1：\n1 2 3 4 5 6 7 8 9 10  unityhub://2018.1.9f2/a6cc294b73ee unityhub://2018.1.8f1/26051d4de9e9 unityhub://2018.1.7f1/4cb482063d12 unityhub://2018.1.6f1/57cc34175ccf unityhub://2018.1.5f1/732dbf75922d unityhub://2018.1.4f1/1a308f4ebef1 unityhub://2018.1.3f1/a53ad04f7c7f unityhub://2018.1.2f1/a46d718d282d unityhub://2018.1.1f1/b8cbb5de9840 unityhub://2018.1.0f2/d4d99f31acba   Unity 2017.4 (LTS) ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  unityhub://2017.4.40f1/6e14067f8a9a unityhub://2017.4.39f1/947131c5be7e unityhub://2017.4.38f1/82ac2fb100ce unityhub://2017.4.37f1/78b69503ebc4 unityhub://2017.4.36f1/c663def8414c unityhub://2017.4.35f1/e57a7bcbbf0b unityhub://2017.4.34f1/121f18246307 unityhub://2017.4.33f1/a8557a619e24 unityhub://2017.4.32f1/4da3ed968770 unityhub://2017.4.31f1/9c8dbc3421cb unityhub://2017.4.30f1/c6fa43736cae unityhub://2017.4.29f1/06508aa14ca1 unityhub://2017.4.28f1/e3a0f7dd2097 unityhub://2017.4.27f1/0c4b856e4c6e unityhub://2017.4.26f1/3b349d10f010 unityhub://2017.4.25f1/9cba1c3a94f1 unityhub://2017.4.24f1/786769fc3439 unityhub://2017.4.23f1/f80c8a98b1b5 unityhub://2017.4.22f1/eb4bc6fa7f1d unityhub://2017.4.21f1/de35fe252486 unityhub://2017.4.20f2/413dbd19b6dc unityhub://2017.4.19f1/47cd37c28be8 unityhub://2017.4.18f1/a9236f402e28 unityhub://2017.4.17f1/05307cddbb71 unityhub://2017.4.16f1/7f7bdd1ef02b unityhub://2017.4.15f1/5d485b4897a7 unityhub://2017.4.14f1/b28150134d55 unityhub://2017.4.13f1/6902ad48015d unityhub://2017.4.12f1/b582b87345b1 unityhub://2017.4.11f1/8c6b8ef6d111 unityhub://2017.4.10f1/f2cce2a5991f unityhub://2017.4.9f1/6d84dfc57ccf unityhub://2017.4.8f1/5ab7f4878ef1 unityhub://2017.4.7f1/de9eb5ca33c5 unityhub://2017.4.6f1/c24f30193bac unityhub://2017.4.5f1/89d1db9cb682 unityhub://2017.4.4f1/645c9050ba4d unityhub://2017.4.3f1/21ae32b5a9cb unityhub://2017.4.2f2/52d9cb89b362 unityhub://2017.4.1f1/9231f953d9d3   Unity 2017.3：\n1 2  unityhub://2017.3.1f1/fc1d3344e6ea unityhub://2017.3.0f3/a9f86dcd79df   Unity 2017.2：\n1 2 3 4 5 6  unityhub://2017.2.5f1/588dc79c95ed unityhub://2017.2.4f1/f1557d1f61fd unityhub://2017.2.3f1/372229934efd unityhub://2017.2.2f1/1f4e0f9b6a50 unityhub://2017.2.1f1/94bf3f9e6b5e unityhub://2017.2.0f3/46dda1414e51   Unity 2017.1：\n1 2 3 4 5 6  unityhub://2017.1.5f1/9758a36cfaa6 unityhub://2017.1.4f1/9fd71167a288 unityhub://2017.1.3f1/574eeb502d14 unityhub://2017.1.2f1/cc85bf6a8a04 unityhub://2017.1.1f1/5d30cf096e79 unityhub://2017.1.0f3/472613c02cf7   Unity 5：\n1 2 3 4 5 6 7 8  unityhub://5.6.7f1/e80cc3114ac1 unityhub://5.6.6f2/6bac21139588 unityhub://5.6.5f1/2cac56bf7bb6 unityhub://5.6.4f1/ac7086b8d112 unityhub://5.6.3f1/d3101c3b8468 unityhub://5.6.2f1/a2913c821e27 unityhub://5.6.1f1/2860b30f0b54 unityhub://5.6.0f3/497a0f351392   ","description":"","id":1,"section":"posts","tags":["unity,mac"],"title":"使用Unity Hub安装Unity","uri":"https://yslinwe.github.io/posts/%E4%BD%BF%E7%94%A8unity-hub%E5%AE%89%E8%A3%85unity/"},{"content":"步骤1：验证是否正确打开工程目录  你可以查看VSCode左侧的资源管理器，查看列表当中是否有sln文件。如果有继续往下看。\n 步骤2：验证工程是否指定正确 VSCode无法进行Unity C#智能提示，代码补全以及方法跳转等功能的解决方案！\n按下键盘的Ctrl/Command + Shift+ P快捷键，选定工程目录下的sln文件。\n至此，如果你以前是有代码提示的，稍等几秒等待自动加载完成以后你可以重试一下是否有代码提示功能\n步骤3：检查和安装对应的.NET开发者版本 记住你的版本号，到这下载对应版本号的开发者版 .NET Framework 。\nhttps://docs.microsoft.com/zh-cn/dotnet/framework/deployment/deployment-guide-for-developers\n 注意你需要下载Developer版本的，如果是Runtime版本很可能安装的时候会提示你已经安装了当前或更高版本的.NET从而拒绝你安装。当然稳妥方式都装一遍… 装完以后，重开VSCode。你期待的代码提示就会出现了！  其他相关 利用控制台定位问题 1.留意你的VSCode控制台输出面板，通常在这里会弹出启动报错信息。仔细阅读输出的报错信息，大部分错误都会有告诉你解决问题的方式。\n代码提示有了，但找不到UnityEngine.UI等类 步骤1：点开Unity的 Package Manager，找到右Visual Studio Code Editor，选择1.2.0以后的版本，然后点击右下角的升级按钮。(注意如果你用的2019,插件不要用太新的版本.否则还是会出现.不出来的情况.)\n步骤2：保存并关闭Unity和VSCode，到工程目录下删除所有的*.sln和*.csproj文件。\n步骤3：重新打开Unity和这个工程，刚被删除的这两个文件将会被重新创建，届时这个故障就解决了。\n如果你不想重启unity和vscode参照这个帖子https://blog.csdn.net/weixin_45476117/article/details/108911678\ngameobject什么的只能.出一个智能引用 这里还是Unity Package Manager的插件惹的祸,我这里用1.2.0可以但是升级到1.2.3就出现这个问题.建议降级到低版本尝试.\n","description":"","id":2,"section":"posts","tags":["VSCode、Unity"],"title":"解决VSCode无法显示Unity代码提示的真正解决办法","uri":"https://yslinwe.github.io/posts/%E8%A7%A3%E5%86%B3vscode%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BAunity%E4%BB%A3%E7%A0%81%E6%8F%90%E7%A4%BA%E7%9A%84%E7%9C%9F%E6%AD%A3%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"content":"开发过程中，经常会有一些通用的部分希望抽取出来做成一个公共库来提供给别的工程来使用，而公共代码库的版本管理是个麻烦的事情。git submodule命令就可以解决这个问题。\nGit归并策略\nGit归并有两种策略：递归，章鱼。\n1.递归策略：当分支数只有两个的时候。\n2.章鱼策略：当分支数大于两个的时候。\nGit会自动选择归并的方法。\n3.子树策略：是Git另一种归并方法。（submodule）\n它可以把另一个子项目，嵌入到当前项目。而且会非常聪明的合并这些子项目。\n添加\n为当前工程添加submodule，命令如下：\n1  git submodule add 仓库地址 路径   其中，仓库地址是指子模块仓库地址，路径指将子模块放置在当前工程下的路径。\n注意：路径不能以 / 结尾（会造成修改不生效）、不能是现有工程已有的目录（不能順利 Clone）\n示例:\n1  git submodule add -f http://git.cs/Cmblife_iOS_Internal/modulesLib.git   -f 是强制的意思，一般不需要加\n命令执行完成，会在当前工程根路径下生成一个名为“.gitmodules”的文件，其中记录了子模块的信息。添加完成以后，再将子模块所在的文件夹添加到工程中即可。\n删除\nsubmodule的删除稍微麻烦点：首先，要在“.gitmodules”文件中删除相应配置信息。然后，执行“git rm –cached ”命令将子模块所在的文件从git中删除。\n下载的工程带有submodule\n当使用git clone下来的工程中带有submodule时，初始的时候，submodule的内容并不会自动下载下来的，此时，只需执行如下命令：\n1  git submodule update –init –recursive   即可将子模块内容下载下来后工程才不会缺少相应的文件。\n————————————————\n版权声明：本文为CSDN博主「糖果屋的世界」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/ajdfhajdkfakr/article/details/77892137\n","description":"","id":3,"section":"posts","tags":["git"],"title":"git 添加子项目","uri":"https://yslinwe.github.io/posts/git-%E6%B7%BB%E5%8A%A0%E5%AD%90%E9%A1%B9%E7%9B%AE/"},{"content":"第一部分：\npublic/private/protected的具体区别\n在说明这四个关键字之前，就class之间的关系做一个简单的定义，对于继承自己的class，base class可以认为他们都是自己的子女，而对于和自己一个目录下的classes，认为都是自己的朋友。\n1、public：public表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用\n2、private：private表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用，私有财产神圣不可侵犯嘛，即便是子女，朋友，都不可以使用。\n3、protected：protected对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private。\n第二部分：\n派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。\n我们可以根据访问权限总结出不同的访问类型，如下所示：\n一个派生类继承了所有基类的方法，但下列情况除外：\n*基类的构造函数、析构函数和拷贝构造函数（可能是为了多继承定义不出现冲突）\n*除了赋值运算符重载函数以外，所有的运算符重载函数都可以被派生类继承。 （原因：“赋\n值运算符重载函数”不是不能被派生类继承，而是被派生类的默认“赋值运算符重载函数”给\n覆盖了。这就是 C++赋值运算符重载函数不能被派生类继承的真实原因！ ） ，更详细的解释传\n送门：http://blog.csdn.net/wuyuan2011woaini/article/details/9407933，感谢这位网友。\n*基类的友元函数（父亲的朋友不一定是你的朋友）\n————————————————\n版权声明：本文为CSDN博主「spu20134823091」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/spu20134823091/article/details/53836192\n","description":"","id":4,"section":"posts","tags":["public，private，protected"],"title":"public，private，protected的区别，继承方法与访问权限","uri":"https://yslinwe.github.io/posts/public-private-protected/"},{"content":"说明：本页面是书籍《Unity Shader入门精要》的随书彩图集锦，包含了书中所有的插图，使用时可通过图片编号进行搜索。\n作者：冯乐乐\n邮箱：lelefeng1992@gmail.com\n前言 第2章 渲染流水线 图2.1　真实生活中的流水线\n图2.2 渲染流水线中的三个概念阶段\n图2.3 渲染所需的数据（两张纹理以及3个网格）从硬盘最终加载到显存中。在渲染时，GPU可以快速访问这些数据\n图2.4 在同一状态下渲染三个网格。由于没有更改渲染状态，因此三个网格的外观看起来像是同一种材质的物体。\n图2.5 CPU通过调用Draw Call来告诉GPU开始进行一个渲染过程。一个Draw Call会指向本次调用需要渲染的图元列表\n图2.6 GPU的渲染流水线实现。颜色表示了不同阶段的可配置性或可编程性：绿色表示该流水线阶段是完全可编程控制的，黄色表示该流水线阶段可以配置但不是可编程的，蓝色表示该流水线阶段是由GPU固定实现的，开发者没有任何控制权。实线表示该shader必须由开发者编程实现，虚线表示该Shader是可选的\n图2.7 GPU在每个输入的网格顶点上都会调用顶点着色器。顶点着色器必须进行顶点的坐标变换，需要时还可以计算和输出顶点的颜色。例如，我们可能需要进行逐顶点的光照\n图2.8 顶点着色器会将模型顶点的位置变换到齐次裁剪坐标空间下，进行输出后再由硬件做透视除法得到NDC下的坐标\n图2.9 只有在单位立方体的图元才需要被继续处理。因此，完全在单位立方体外部的图元（红色三角形）被舍弃，完全在单位立方体内部的图元（绿色三角形）将被保留。和单位立方体相交的图元（黄色三角形）会被裁剪，新的顶点会被生成，原来在外部的顶点会被舍弃\n图2.10 屏幕映射将x、y坐标从（-1, 1）范围转换到屏幕坐标系中\n图2.11 OpenGL和DirectX的屏幕坐标系差异。对于一张512*512大小的图像，在OpenGL中其（0, 0）点在左下角，而在DirectX中其(0, 0)点在左上角\n图2.12 三角形遍历的过程。根据几何阶段输出的顶点信息，最终得到该三角网格覆盖的像素位置。对应像素会生成一个片元，而片元中的状态是对三个顶点的信息进行插值得到的。例如，对图2.12中三个顶点的深度进行插值得到其重心位置对应的片元的深度值为-10.0\n图2.13 根据上一步插值后的片元信息，片元着色器计算该片元的输出颜色\n图2.14 逐片元操作阶段所做的操作。只有通过了所有的测试后，新生成的片元才能和颜色缓冲区中已经存在的像素颜色进行混合，最后再写入颜色缓冲区中\n图2.15 模板测试和深度测试的简化流程图。\n图2.16 混合操作的简化流程图\n图2.17 图示场景中包含了两个对象：球和长方体，绘制顺序是先绘制球（在屏幕上显示为圆），再绘制长方体（在屏幕上显示为长方形）。如果深度测试在片元着色器之后执行，那么在渲染长方体时，虽然它的大部分区域都被遮挡在球的后面，即它所覆盖的绝大部分片元根本无法通过深度测试，但是我们仍然需要对这些片元执行片元着色器，造成了很大的性能浪费\n图2.18 CPU、OpenGL/DirectX、显卡驱动和GPU之间的关系\n图2.19 命令缓冲区。CPU通过图像编程接口向命令缓冲区中添加命令，而GPU从中读取命令并执行。黄色方框内的命令就是Draw Call，而红色方框内的命令用于改变渲染状态。我们使用红色方框来表示改变渲染状态的命令，\u2028是因为这些命令往往更加耗时\n图2.20 命令缓冲区中的虚线方框表示GPU已经完成的命令。此时，命令缓冲区中没有可以执行的命令了，GPU处于空闲状态，而CPU还没有准备好下一个渲染命令。\n图2.21 利用批处理，CPU在RAM把多个网格合并成一个更大的网格，再发送给GPU，然后在一个Draw Call中渲染它们。但要注意的是，使用批处理合并的网格将会使用同一种渲染状态。也就是说，如果网格之间需要使用不同的渲染状态，那么就无法使用批处理技术\n第3章 Unity Shader基础 图3.1 Unity Shader和材质。首先创建需要的Unity Shader和材质，然后把Unity Shader赋给材质，并在材质面板上调整属性（如使用的纹理、漫反射系数等）。最后，将材质赋给相应的模型来查看最终的渲染效果\n图3.2 将材质直接拖曳到模型的Mesh Renderer组件中\n图3.3 材质提供了一种可视化的方式来调整着色器中使用的参数\n图3.4 Unity Shader的导入设置面板\n图3.5 Gompile and show code下拉列表\n图3.6 Unity Shader为控制渲染过程提供了一层抽象。如果没有使用Unity Shader（左图），开发者需要和很多文件和设置打交道，才能让画面呈现出想要的效果；而在Unity Shader的帮助下（右图），开发者只需要使用ShaderLab来编写Unity Shader文件就可以完成所有的工作\n图3.7 在Unity Shader的名称定义中利用\u2028斜杠来组织在材质面板中的位置\n图3.8 不同属性类型在材质\u2028面板中的显示结果\n图3.9 在Unity Shader的导入设置面板中可以通过Compile and show code按钮来查看Unity对CG片段编译后的代码。通过单击Compile and show code按钮右端的倒三角可以打开下拉菜单，在这个下拉菜单中可以选择编译的平台种类，如只为当前的显卡设备编译特定的汇编代码，或为所有的平台编译汇编代码，我们也可以自定义选择编译到哪些平台上\n第4章 学习Shader所需的数学基础 图4.1 我们的农场游戏。我们的主角妞妞是一头长得最壮、好奇心很强的奶牛\n图4.2 传说，笛卡尔坐标系来源于笛卡尔对天花板上一只苍蝇的运动轨迹的观察。笛卡尔发现，可以使用苍蝇距不同墙面的距离来描述它的当前位置\n图4.3 一个二维笛卡尔坐标系\n图4.4 在屏幕映射时，OpenGL和DirectX使用了不同方向的二维笛卡尔坐标系\n图4.5 笛卡尔坐标系可以让妞妞精确表述自己的位置\n图4.6 一个三维笛卡尔坐标系\n图4.7 左手坐标系\n图4.8 右手坐标系\n图4.9 用左手法则和右手法则来判断旋转正方向\n图4.10 为了移动到新的位置，妞妞需要首先向某个方向平移1个单位，再向另一个方向平移4个单位，最后再向一个方向旋转60°\n图4.11 左图和右图分别表示了在左手坐标系和右手坐标系中描述妞妞这次运动的结果，得到的数学描述是不同的\n图4.12 在模型空间和世界空间中，Unity使用的是左手坐标系。图中，球的坐标轴显示了它在模型空间中的3个坐标轴（红色为x轴，绿色是y轴，蓝色是z轴）\n图4.13 在Unity中，观察空间使用的是右手坐标系，摄像机的前向是z轴的负方向，\u2028z轴越小，物体的深度越大，离摄像机越远\n图4.14 摄像机的位置是（0, 1, -10），球体的位置是（0, 1, 0）\n图4.15 一个二维向量以及它的头和尾\n图4.16 点和矢量之间的关系\n图4.17 二维矢量和一些标量的乘法和除法\n图4.18 二维矢量的加法和减法\n图4.19 使用矢量减法来计算从点a到点b的位移\n图4.20 矢量的模\n图4.21 二维空间的单位矢量都会落在单位圆上\n图4.22 矢量b在单位矢量a方向上的投影\n图4.23 点积的符号\n图4.24 两个单位矢量进行点积\n图4.25 三维矢量叉积的计算规律。不同颜色的线表示了计算结果矢量中对应颜色的分量的计算路径。以红色为例，即结果矢量的第一个分量，它是从第一个矢量的y分量出发乘以第二个矢量的z分量，再减去第一个矢量的z分量和第二矢量的y分量的乘积\n图4.26 使用矢量a和矢量b构建一个平行四边形\n图4.27 分别使用左手坐标系和右手坐标系得到的叉积结果\n图4.28 使用右手法则判断右手坐标系中a×b的方向\n图4.29 三角形的三个顶点位于xy平面上，人眼位于z轴负方向，向z轴正方向观察\n图4.30 计算c23的过程\n图4.31 场景中的妞妞（左图）和屏幕上的妞妞（右图）。妞妞想知道，自己的鼻子是如何被画到屏幕上的\n图4.32 在我们的农场游戏中，每个奶牛都有自己的模型坐标系。在模型坐标系中妞妞鼻子的位置是(0, 2, 4, 1)\n图4.33 Unity的Transform组件可以调节模型的位置.如果Transform有父节点，如图中的“Mesh”，那么Position将是在其父节点（这里是“Cow”）的模型空间中的位置；如果没有父节点，Position就是在世界空间中的位置\n图4.34 农场游戏中的世界空间。世界空间的原点被放置在农场的中心。左下角显示了妞妞在世界空间中所做的变换。我们想要把妞妞的鼻子从模型空间变换到世界空间中\n图4.35 农场游戏中摄像机的观察空间。观察空间的原点位于摄像机处。注意在观察空间中，摄像机的前向是z轴的负方向（图中只画出了z轴正方向），这是因为Unity在观察空间中使用了右手坐标系。左下角显示了摄像机在世界空间中所做的变换。我们想要把妞妞的鼻子从世界空间变换到观察空间中\n图4.36 透视投影（左图）和正交投影（右图）。左下角分别显示了当前摄像机的投影模式和相关属性\n图4.37 视锥体和裁剪平面。左图显示了透视投影的视锥体，右图显示了正交投影的视锥体\n图4.38 透视摄像机的参数对透视投影视锥体的影响\n图4.39 在透视投影中，投影矩阵对顶点进行了缩放。图3.38中标注了4个关键点经过投影矩阵变换后的结果。从这些结果可以看出x、y、z和w分量的范围发生的变化\n图4.40 正交摄像机的参数对正交投影视锥体的影响\n图4.41 在正交投影中，投影矩阵对顶点进行了缩放。图中标注了4个关键点经过投影矩阵变换后的结果。从这些结果可以看出x、y、z和w分量范围发生的变化\n图4.42 农场游戏使用的摄像机参数和游戏画面的横纵比\n图4.43 经过齐次除法后，透视投影的裁剪空间会变换到一个立方体\n图4.44 经过齐次除法后，正交投影的裁剪空间会变换到一个立方体\n图4.45 渲染流水线中顶点的空间变换过程\n图4.46 Unity中各个坐标空间的旋向性\n图4.47 顶点的切线和法线。切线和法线互相垂直\n图4.48 进行非统一缩放时，如果使用和变换顶点相同的变换矩阵来变换法线，就会得到错误的结果，即变换后的法线方向与平面不再垂直\n图4.49 由片元的像素位置得到的图像\n图4.50 图中两个坐标系的x轴和y轴是重合的，区别仅在于z轴的方向。左手坐标系的（0, 0, 1）点和右手坐标系中的（0, 0, 1）点是不同的，但它们旋转后的点却对应到了同一点\n图4.51 绝对空间中的同一点，在左手和右手坐标系中进行同样角度的旋转，其旋转方向是不一样的。在左手坐标系中将按顺时针方向旋转，在右手坐标系中将按逆时针方向旋转\n图4.52 在左手坐标系中，如果叉积结果为负，那么3点的顺序是顺时针方向\n第5章 开始Unity Shader学习之旅 图5.1 在Unity 5中新建一个场景得到的效果\n图5.2 用一个最简单的顶点/片元着色器得到一个白色的球\n图5.3 Unity的内置着色器\n图5.4 用假彩色对Unity Shader进行调试\n图5.5 使用颜色拾取器来查看调试信息\n图5.6 帧调试器\n图5.7 单击Knot的深度图渲染事件，在Game视图会显示该事件的效果，在Hierarchy视图中会高亮显示Knot对象，在帧调试器的右侧窗口会显示出该事件的细节\n图5.8 OpenGL和DirectX使用了不同的屏幕空间坐标\n第6章 Unity中的基础光照 图6.1 在左图中，光是垂直照射到物体表面，因此光线之间的垂直距离保持不变；而在右图中，光是斜着照射到物体表面，在物体表面光线之间的距离是d/cosθ，因此单位面积上接收到的光线数目要少于左图\n图6.2 散射时，光线会发生折射和反射现象。对于不透明物体，折射的光线会在物体内部继续传播，最终有一部分光线会重新从物体表面被发射出去\n图6.3 使用Phong模型计算高光反射\n图6.4 Blinn模型\n图6.5 在Unity的Window -\u0026gt; Lighting面板中，我们可以通过Ambient Source/Ambient Color/Ambient Intensity来控制场景中的环境光的颜色和强度\n图6.6 逐顶点的漫反射光照效果\n图6.7 逐像素的漫反射光照效果\n图6.8 逐顶点漫反射光照、逐像素漫反射光照、半兰伯特光照的对比效果\n图6.9 CG的reflect函数\n图6.10 逐顶点的高光反射光照效果\n图6.11 逐像素的高光反射光照效果\n图6.12 逐顶点的高光反射光照、逐像素的高光反射光照（Phong光照模型）和Blinn-Phong高光反射光照的对比结果\n第7章 基础纹理 图7.1 Unity中的纹理坐标\n图7.2 使用单张纹理\n图7.3 调节纹理的平铺（缩放）和偏移（平移）属性\n图7.4 纹理的属性\n图7.5 Wrap Mode决定了当纹理坐标超过[0, 1]范围后将会如何被平铺\n图7.6 偏移（Offset）属性决定了纹理坐标的偏移量\n图7.7 在放大纹理时，分别使用三种Filter Mode得到的结果\n图7.8 在Advanced模式下可以设置多级渐远纹理的相关属性\n图7.9 从上到下： Point滤波 + 多级渐远纹理技术，Bilinear滤波 + 多级渐远纹理技术，Trilinear滤波 + 多级渐远纹理技术\n图7.10 选择纹理的最大尺寸和纹理模式\n图7.11 高度图\n图7.12 模型顶点的切线空间。其中，原点对应了顶点坐标，x轴是切线方向（t），y轴是副切线方向（b），z轴是法线方向（n）\n图7.13 左图：模型空间下的法线纹理。右图：切线空间下的法线纹理\n图7.14 使用法线纹理\n图7.15 使用Bump Scale属性来调整模型的凹凸程度\n图7.16 当使用UnpackNormal函数计算法线纹理中的法线方向时，需要把纹理类型标识为Normal map\n图7.17 当勾选了Create from Grayscale后，Unity会根据高度图来生成一张切线空间下的法线纹理\n图7.18 使用不同的渐变纹理控制漫反射光照，左下角给出了每张图使用的渐变纹理\n图7.19 Wrap Mode分别为Repeat和Clamp模式的效果对比\n图7.20 使用高光遮罩纹理。从左到右：只包含漫反射，未使用遮罩的高光反射，使用遮罩的高光反射\n图7.21 本节使用的高光遮罩纹理\n第8章 透明效果 图8.1 场景中有两个物体，其中A（黄色）是半透明物体，B（紫色）是不透明物体\n图8.2 场景中有两个物体，其中A和B都是半透明物体\n图8.3 循环重叠的半透明物体总是无法得到正确的半透明效果\n图8.4 使用哪个深度对物体进行排序。红色点分别标明了网格上距离摄像机最近的点、最远的点以及网格中点\n图8.5 一张透明纹理，其中每个方格的透明度都不同\n图8.6 透明度测试\n图8.7 随着Alpha cutoff参数的增大，更多的像素由于不满足透明度测试条件而被剔除\n图8.8 透明度混合\n图8.9 随着Alpha Scale参数的增大，模型变得越来越透明\n图8.10 当模型网格之间有互相交叉的结构时，往往会得到错误的半透明效果\n图8.11 开启了深度写入的半透明效果\n图8.12 不同混合状态设置得到的效果\n图8.13 双面渲染的透明度测试的物体\n图8.14 双面渲染的透明度混合的物体\n第9章 更复杂的光照 图9.1 设置Unity项目的渲染路径\n图9.2 摄像机组件的Rendering Path中的设置可以覆盖Project Settings中的设置\n图9.3 设置光源的类型和渲染模式\n图9.4 前向渲染的两种Pass\n图9.5 平行光\n图9.6 点光源\n图9.7 开启Scene视图中的光照\n图9.8 聚光灯\n图9.9 使用一个平行光和一个点光源共同照亮物体。右图显示了胶囊体、平行光和点光源在场景中的相对位置\n图9.10 使用1个平行光 + 4个点光源照亮一个物体\n图9.11 打开帧调试器查看场景的绘制事件\n图9.12 本例中的6个渲染事件，绘制顺序是从左到右、从上到下进行的\n图9.13 如果物体不在一个光源的光照范围内（从右图可以看出，胶囊体不在最左方的点光源的照明范围内），Unity是不会调用Additional Pass来为该物体处理该光源的\n图9.14 当把光源的Render Mode设为Not Important时，这些光源就不会按逐像素光来处理\n图9.15 开启光源的阴影效果\n图9.16 Mesh Renderer组件的Cast Shadows和Receive Shadows属性可以控制该物体是否投射/接收阴影\n图9.17 开启Cast Shadows和Receive Shadows，从而让正方体可以投射和接收阴影\n图9.18 把Cast Shadows设置为Two Sided可以让右侧平面的背光面也产生阴影\n图9.19 正方体可以接收来自右侧平面的阴影\n图9.20 使用帧调试器查看阴影绘制过程\n图9.21 正方体对深度纹理的更新结果\n图9.22 屏幕空间的阴影图\n图9.23 Unity绘制屏幕阴影的过程\n图9.24 可以投射阴影的使用透明度测试的物体\n图9.25 正确设置了Fallback的使用透明度测试的物体\n图9.26 正确设置了Cast Shadow属性的使用透明度测试的物体\n图9.27 把使用了透明度混合的Unity Shader的Fallback设置为内置的Transparent/VertexLit。半透明物体不会向下方的平面投射阴影，也不会接收来自右侧平面的阴影，它看起来就像是完全透明一样\n图9.28 把Fallback设为VertexLit来强制为半透明物体生成阴影\n第10章 高级纹理 图10.1 对立方体纹理的采样\n图10.2 天空盒子材质\n图10.3 为场景使用自定义的天空盒子\n图10.4 使用了天空盒子的场景\n图10.5 使用脚本创建立方体纹理\n图10.6 使用脚本渲染立方体纹理\n图10.7 使用了反射效果的Teapot模型\n图10.8 斯涅尔定律\n图10.9 使用了折射效果的Teapot模型\n图10.10 使用了菲涅耳反射的Teapot模型\n图10.11 镜子效果\n图10.12 左图：把摄像机的Target Texture设置成自定义的渲染纹理。右图：渲染纹理使用的纹理设置\n图10.13 玻璃效果\n图10.14 本例使用的立方体纹理\n图10.15 脚本生成的程序纹理\n图10.16　调整程序纹理的参数来得到不同的程序纹理\n图10.17　后缀为.sbsar的Substance材质\n图10.18　程序纹理资源\n图10.19　调整程序纹理属性可以得到看似完全不同的程序材质效果\n第11章 让画面动起来 图11.1 本节使用的序列帧图像\n图11.2 使用序列帧动画来实现爆炸效果\n图11.3 无限滚动的背景（纹理来源：forest-background © 2012-2013 Julien Jorge julien.jorge@stuff-o-matic.com）\n图11.4 使用顶点动画来模拟2D的河流\n图11.5 法线固定（总是指向视角方向）时，计算广告牌技术中的三个正交基的过程\n图11.6 广告牌效果。左图显示了摄像机和5个广告牌之间的位置关系，摄像机是从斜上方向下观察它们的。中间的图显示了当Vertical Restraints属性为1，即固定法线方向为观察视角时所得到的效果，可以看出，所有的广告牌都完全面朝摄像机。右图显示了当Vertical Restraints属性为0，即固定指向上的方向为(0, 1, 0)时所得到的效果，可以看出，广告牌虽然最大限度地面朝摄像机，但其指向上的方向并未发生改变\n图11.7 当进行顶点动画时，如果仍然使用内置的ShadowCaster Pass来渲染阴影，可能会得到错误的阴影效果\n图11.8 使用自定义的ShadowCaster Pass\u2028为变形物体绘制正确的阴影\n第12章 屏幕后处理效果 图12.1 左图：原效果。右图：调整了亮度（值为1.2）、饱和度（值为1.6）和对比度（值为1.2）后的效果\n图12.2 为脚本设置Shader的默认值\n图12.3 左图：12.2节得到的结果。\u2028右图：进行边缘检测后的效果\n图12.4 卷积核与卷积。使用一个3×3大小的卷积核对一张5×5大小的图像进行卷积操作，当计算图中红色方块对应的像素的卷积结果时，我们首先把卷积核的中心放置在该像素位置，翻转核之后再依次计算核中每个元素和其覆盖的图像像素值的乘积并求和，得到新的像素值\n图12.5 三种常见的边缘检测算子\n图12.6 只显示边缘的屏幕效果\n图12.7 左图：原效果。右图：高斯模糊后的效果\n图12.8 一个5×5大小的高斯核。左图显示了标准方差为1的高斯核的权重分布。我们可以把这个二维高斯核拆分成两个一维的高斯核（右图）\n图12.9 动画短片《大象之梦》中的Bloom效果。光线透过门扩散到了周围较暗的区域中\n图12.10 左图：原效果。右图：Bloom处理后的效果\n图12.11 左图：原效果。右图：应用运动模糊后的效果\n第13章 使用深度和法线纹理 图13.1 在透视投影中，投影矩阵首先对顶点进行了缩放。在经过齐次除法后，透视投影的裁剪空间会变换到一个立方体。图中标注了4个关键点经过投影矩阵变换后的结果\n图13.2 在正交投影中，投影矩阵对顶点进行了缩放。在经过齐次除法后，正交投影的裁剪空间会变换到一个立方体。图中标注了4个关键点经过投影矩阵变换后的结果\n图13.3 使用Frame Debugger查看深度纹理（左）和深度+法线纹理（右）。如果当前摄像机需要生成深度和法线纹理，帧调试器的面板中就会出现相应的渲染事件。只要单击对应的事件就可以查看得到的深度和法线纹理\n图13.4 左图：线性空间下的深度纹理。右图：解码后并且被映射到[0, 1]范围内的视角空间下的法线纹理\n图13.5 左图：原效果。右图：添加全局雾效后的效果\n图13.6 计算interpolatedRay\n图13.7 采样得到的深度值并非是点到摄像机的欧式距离\n图13.8 左图：原效果。右图：直接对颜色图像进行边缘检测的结果\n图13.9 在深度和法线纹理上进行更健壮的边缘检测。左图：在原图上描边的效果。右图：只显示描边的效果\n图13.10 Roberts算子\n第14章 非真实感渲染 图14.1 游戏《大神》（英文名：Okami）的游戏截图\n图14.2 卡通风格的渲染效果\n图14.3 左图：未对高光区域进行抗锯齿处理。右图：使用fwidth函数对高光区域进行抗锯齿处理\n图14.4 一个TAM的例子（来源：Praun E, et al. Real-time hatching4）\n图14.5 素描风格的渲染效果\n第15章 使用噪声 图15.1 箱子的消融效果\n图15.2 消融效果使用的噪声纹理\n图15.3 包含菲涅耳反射的水面波动效果。在左图中，视角方向和水面法线的夹角越大，反射效果越强。在右图中，视角方向和水面法线的夹角越大，折射效果越强\n图15.4 本例使用的立方体纹理\n图15.5 水波效果使用的噪声纹理。左图：噪声纹理的灰度图。右图：由左图生成的法线纹理\n图15.6 左图：均匀雾效。右图：使用噪声纹理后的非均匀雾效\n图15.7 本节使用的噪声纹理\n第16章 Unity中的渲染优化技术 图16.1 Unity 5的渲染统计窗口\n图16.2 使用Unity的性能分析器中的渲染区域来查看更多关于渲染的统计信息\n图16.3 使用帧调试器来查看单独的draw call的绘制结果\n图16.4 动态批处理\n图16.5 多光源对动态批处理的影响结果\n图16.6 静态批处理前的渲染统计数据\n图16.7 把物体标志为Static\n图16.8 静态批处理\n图16.9 静态批处理中Unity会合并所有被标识为“Static”的物体\n图16.10 静态批处理会占用更多的内存。左图：静态批处理前的渲染统计数据。右图：静态批处理后的渲染统计数据\n图16.11 处理其他逐像素光的Pass不会被静态批处理\n图16.12 Unity的高级纹理设置面板\n第17章 Surface Shader探秘 图17.1 表面着色器的例子。左图：在一个平行光下的效果。右图：添加了一个点光源（蓝色）和一个聚光灯（紫色）后的效果\n图17.2 查看表面着色器生成的代码\n图17.3 表面着色器的渲染计算流水线。黄色：可以自定义的函数。灰色：Unity自动生成的计算步骤\n图17.4 沿顶点法线对模型进行膨胀。左图：膨胀前。右图：膨胀后\n第18章 基于物理的渲染 图18.1 在理想的边界处，折射率的突变会把光线分成两个方向\n图18.2 左图：光滑表面的微平面的法线变化较小，反射光线的方向变化也更小。\u2028右图：粗糙表面的微平面的法线变化较大，反射光线的方向变化也更大\n图18.3 微表面对光的折射。这些被折射的光中一部分被吸收，一部分又被散射到外部\n图18.4 次表面散射。左图：次表面散射的光线会从不同于入射点的位置射出。如果这些距离值小于需要被着色的像素大小，那么渲染就可以完全在局部完成（右图）。否则，就需要使用次表面散射渲染技术\n图18.5 BRDF描述的两种现象。高光反射部分用于描述反射，漫反射部分用于描述次表面散射\n图18.6 （a）那些m=h的微面元会恰好把入射光从I反射到v上，只有这部分微面元才可以添加到BRDF的计算中。（b）一部分满足（a）的微面元会在I方向上被其他微面元遮挡住，它们不会接受到光照，因此会形成阴影。（c）还有一部分满足（a）的微面元会在反射方向v上被其他微面元挡住，因此，这部分反射光也不会被看到\n图18.7 Standard Shader中前向渲染路径使用的Pass（简化版本的PBS使用了VertexOutputBaseSimple等结构体来代替相应的结构体）\n图18.8 Unity提供的校准表格。左图：金属工作流\u2028使用的校准表格。右图：高光反射工作流使用的校准表格\n图18.9 使用金属工作流来实现不同类型的材质。左边的球体：金属材质。右边的球体：塑料材质\n图18.10 在Unity 5中使用基于物理的渲染技术，场景在不同光照下的渲染结果\n图18.11 光照面板下的Scene标签页\n图18.12 左图：当关闭场景中的所有光源并把环境光照强度设为0后，使用了Standard Shader的物体仍然具有光照效果。右图：在左图的基础上，把反射源设置为空，使得物体不接受任何默认的反射信息\n图18.13 使用的平行光\n图18.14 左图：将Bounce Intensity设置为0，物体不再受到间接光照的影响，木屋内阴影部分的可见细节很少。右图：将Bounce Intensity设为8，阴影部分的细节更加清楚\n图18.15 左图：未使用反射探针。右图：在场景中放置了两个反射探针，注意墙上的盾牌与左图的差别\n图18.16 使用反射探针实现相互反射的效果\n图18.17 左图：在线性空间下的渲染结果。右图：在伽马空间下的渲染结果\n图18.18 人眼更容易感知暗部区域的变换，而对较亮区域的变化比较不敏感\n图18.19 编码伽马和显示伽马\n![gamma_light.png-32.1k《Unity Shader入门精要》随书彩色插图\n说明：本页面是书籍《Unity Shader入门精要》的随书彩图集锦，包含了书中所有的插图，使用时可通过图片编号进行搜索。\n作者：冯乐乐\n邮箱：lelefeng1992@gmail.com\n前言 第2章 渲染流水线 图2.1　真实生活中的流水线\n图2.2 渲染流水线中的三个概念阶段\n图2.3 渲染所需的数据（两张纹理以及3个网格）从硬盘最终加载到显存中。在渲染时，GPU可以快速访问这些数据\n图2.4 在同一状态下渲染三个网格。由于没有更改渲染状态，因此三个网格的外观看起来像是同一种材质的物体。\n图2.5 CPU通过调用Draw Call来告诉GPU开始进行一个渲染过程。一个Draw Call会指向本次调用需要渲染的图元列表\n图2.6 GPU的渲染流水线实现。颜色表示了不同阶段的可配置性或可编程性：绿色表示该流水线阶段是完全可编程控制的，黄色表示该流水线阶段可以配置但不是可编程的，蓝色表示该流水线阶段是由GPU固定实现的，开发者没有任何控制权。实线表示该shader必须由开发者编程实现，虚线表示该Shader是可选的\n图2.7 GPU在每个输入的网格顶点上都会调用顶点着色器。顶点着色器必须进行顶点的坐标变换，需要时还可以计算和输出顶点的颜色。例如，我们可能需要进行逐顶点的光照\n图2.8 顶点着色器会将模型顶点的位置变换到齐次裁剪坐标空间下，进行输出后再由硬件做透视除法得到NDC下的坐标\n图2.9 只有在单位立方体的图元才需要被继续处理。因此，完全在单位立方体外部的图元（红色三角形）被舍弃，完全在单位立方体内部的图元（绿色三角形）将被保留。和单位立方体相交的图元（黄色三角形）会被裁剪，新的顶点会被生成，原来在外部的顶点会被舍弃\n图2.10 屏幕映射将x、y坐标从（-1, 1）范围转换到屏幕坐标系中\n图2.11 OpenGL和DirectX的屏幕坐标系差异。对于一张512*512大小的图像，在OpenGL中其（0, 0）点在左下角，而在DirectX中其(0, 0)点在左上角\n图2.12 三角形遍历的过程。根据几何阶段输出的顶点信息，最终得到该三角网格覆盖的像素位置。对应像素会生成一个片元，而片元中的状态是对三个顶点的信息进行插值得到的。例如，对图2.12中三个顶点的深度进行插值得到其重心位置对应的片元的深度值为-10.0\n图2.13 根据上一步插值后的片元信息，片元着色器计算该片元的输出颜色\n图2.14 逐片元操作阶段所做的操作。只有通过了所有的测试后，新生成的片元才能和颜色缓冲区中已经存在的像素颜色进行混合，最后再写入颜色缓冲区中\n图2.15 模板测试和深度测试的简化流程图。\n图2.16 混合操作的简化流程图\n图2.17 图示场景中包含了两个对象：球和长方体，绘制顺序是先绘制球（在屏幕上显示为圆），再绘制长方体（在屏幕上显示为长方形）。如果深度测试在片元着色器之后执行，那么在渲染长方体时，虽然它的大部分区域都被遮挡在球的后面，即它所覆盖的绝大部分片元根本无法通过深度测试，但是我们仍然需要对这些片元执行片元着色器，造成了很大的性能浪费\n图2.18 CPU、OpenGL/DirectX、显卡驱动和GPU之间的关系\n图2.19 命令缓冲区。CPU通过图像编程接口向命令缓冲区中添加命令，而GPU从中读取命令并执行。黄色方框内的命令就是Draw Call，而红色方框内的命令用于改变渲染状态。我们使用红色方框来表示改变渲染状态的命令，\u2028是因为这些命令往往更加耗时\n图2.20 命令缓冲区中的虚线方框表示GPU已经完成的命令。此时，命令缓冲区中没有可以执行的命令了，GPU处于空闲状态，而CPU还没有准备好下一个渲染命令。\n图2.21 利用批处理，CPU在RAM把多个网格合并成一个更大的网格，再发送给GPU，然后在一个Draw Call中渲染它们。但要注意的是，使用批处理合并的网格将会使用同一种渲染状态。也就是说，如果网格之间需要使用不同的渲染状态，那么就无法使用批处理技术\n第3章 Unity Shader基础 图3.1 Unity Shader和材质。首先创建需要的Unity Shader和材质，然后把Unity Shader赋给材质，并在材质面板上调整属性（如使用的纹理、漫反射系数等）。最后，将材质赋给相应的模型来查看最终的渲染效果\n图3.2 将材质直接拖曳到模型的Mesh Renderer组件中\n图3.3 材质提供了一种可视化的方式来调整着色器中使用的参数\n图3.4 Unity Shader的导入设置面板\n图3.5 Gompile and show code下拉列表\n图3.6 Unity Shader为控制渲染过程提供了一层抽象。如果没有使用Unity Shader（左图），开发者需要和很多文件和设置打交道，才能让画面呈现出想要的效果；而在Unity Shader的帮助下（右图），开发者只需要使用ShaderLab来编写Unity Shader文件就可以完成所有的工作\n图3.7 在Unity Shader的名称定义中利用\u2028斜杠来组织在材质面板中的位置\n图3.8 不同属性类型在材质\u2028面板中的显示结果\n图3.9 在Unity Shader的导入设置面板中可以通过Compile and show code按钮来查看Unity对CG片段编译后的代码。通过单击Compile and show code按钮右端的倒三角可以打开下拉菜单，在这个下拉菜单中可以选择编译的平台种类，如只为当前的显卡设备编译特定的汇编代码，或为所有的平台编译汇编代码，我们也可以自定义选择编译到哪些平台上\n第4章 学习Shader所需的数学基础 图4.1 我们的农场游戏。我们的主角妞妞是一头长得最壮、好奇心很强的奶牛\n图4.2 传说，笛卡尔坐标系来源于笛卡尔对天花板上一只苍蝇的运动轨迹的观察。笛卡尔发现，可以使用苍蝇距不同墙面的距离来描述它的当前位置\n图4.3 一个二维笛卡尔坐标系\n图4.4 在屏幕映射时，OpenGL和DirectX使用了不同方向的二维笛卡尔坐标系\n图4.5 笛卡尔坐标系可以让妞妞精确表述自己的位置\n图4.6 一个三维笛卡尔坐标系\n图4.7 左手坐标系\n图4.8 右手坐标系\n图4.9 用左手法则和右手法则来判断旋转正方向\n图4.10 为了移动到新的位置，妞妞需要首先向某个方向平移1个单位，再向另一个方向平移4个单位，最后再向一个方向旋转60°\n图4.11 左图和右图分别表示了在左手坐标系和右手坐标系中描述妞妞这次运动的结果，得到的数学描述是不同的\n图4.12 在模型空间和世界空间中，Unity使用的是左手坐标系。图中，球的坐标轴显示了它在模型空间中的3个坐标轴（红色为x轴，绿色是y轴，蓝色是z轴）\n图4.13 在Unity中，观察空间使用的是右手坐标系，摄像机的前向是z轴的负方向，\u2028z轴越小，物体的深度越大，离摄像机越远\n图4.14 摄像机的位置是（0, 1, -10），球体的位置是（0, 1, 0）\n图4.15 一个二维向量以及它的头和尾\n图4.16 点和矢量之间的关系\n图4.17 二维矢量和一些标量的乘法和除法\n图4.18 二维矢量的加法和减法\n图4.19 使用矢量减法来计算从点a到点b的位移\n图4.20 矢量的模\n图4.21 二维空间的单位矢量都会落在单位圆上\n图4.22 矢量b在单位矢量a方向上的投影\n图4.23 点积的符号\n图4.24 两个单位矢量进行点积\n图4.25 三维矢量叉积的计算规律。不同颜色的线表示了计算结果矢量中对应颜色的分量的计算路径。以红色为例，即结果矢量的第一个分量，它是从第一个矢量的y分量出发乘以第二个矢量的z分量，再减去第一个矢量的z分量和第二矢量的y分量的乘积\n图4.26 使用矢量a和矢量b构建一个平行四边形\n图4.27 分别使用左手坐标系和右手坐标系得到的叉积结果\n图4.28 使用右手法则判断右手坐标系中a×b的方向\n图4.29 三角形的三个顶点位于xy平面上，人眼位于z轴负方向，向z轴正方向观察\n图4.30 计算c23的过程\n图4.31 场景中的妞妞（左图）和屏幕上的妞妞（右图）。妞妞想知道，自己的鼻子是如何被画到屏幕上的\n图4.32 在我们的农场游戏中，每个奶牛都有自己的模型坐标系。在模型坐标系中妞妞鼻子的位置是(0, 2, 4, 1)\n图4.33 Unity的Transform组件可以调节模型的位置.如果Transform有父节点，如图中的“Mesh”，那么Position将是在其父节点（这里是“Cow”）的模型空间中的位置；如果没有父节点，Position就是在世界空间中的位置\n图4.34 农场游戏中的世界空间。世界空间的原点被放置在农场的中心。左下角显示了妞妞在世界空间中所做的变换。我们想要把妞妞的鼻子从模型空间变换到世界空间中\n图4.35 农场游戏中摄像机的观察空间。观察空间的原点位于摄像机处。注意在观察空间中，摄像机的前向是z轴的负方向（图中只画出了z轴正方向），这是因为Unity在观察空间中使用了右手坐标系。左下角显示了摄像机在世界空间中所做的变换。我们想要把妞妞的鼻子从世界空间变换到观察空间中\n图4.36 透视投影（左图）和正交投影（右图）。左下角分别显示了当前摄像机的投影模式和相关属性\n图4.37 视锥体和裁剪平面。左图显示了透视投影的视锥体，右图显示了正交投影的视锥体\n图4.38 透视摄像机的参数对透视投影视锥体的影响\n图4.39 在透视投影中，投影矩阵对顶点进行了缩放。图3.38中标注了4个关键点经过投影矩阵变换后的结果。从这些结果可以看出x、y、z和w分量的范围发生的变化\n图4.40 正交摄像机的参数对正交投影视锥体的影响\n图4.41 在正交投影中，投影矩阵对顶点进行了缩放。图中标注了4个关键点经过投影矩阵变换后的结果。从这些结果可以看出x、y、z和w分量范围发生的变化\n图4.42 农场游戏使用的摄像机参数和游戏画面的横纵比\n图4.43 经过齐次除法后，透视投影的裁剪空间会变换到一个立方体\n图4.44 经过齐次除法后，正交投影的裁剪空间会变换到一个立方体\n图4.45 渲染流水线中顶点的空间变换过程\n图4.46 Unity中各个坐标空间的旋向性\n图4.47 顶点的切线和法线。切线和法线互相垂直\n图4.48 进行非统一缩放时，如果使用和变换顶点相同的变换矩阵来变换法线，就会得到错误的结果，即变换后的法线方向与平面不再垂直\n图4.49 由片元的像素位置得到的图像\n图4.50 图中两个坐标系的x轴和y轴是重合的，区别仅在于z轴的方向。左手坐标系的（0, 0, 1）点和右手坐标系中的（0, 0, 1）点是不同的，但它们旋转后的点却对应到了同一点\n图4.51 绝对空间中的同一点，在左手和右手坐标系中进行同样角度的旋转，其旋转方向是不一样的。在左手坐标系中将按顺时针方向旋转，在右手坐标系中将按逆时针方向旋转\n图4.52 在左手坐标系中，如果叉积结果为负，那么3点的顺序是顺时针方向\n第5章 开始Unity Shader学习之旅 图5.1 在Unity 5中新建一个场景得到的效果\n图5.2 用一个最简单的顶点/片元着色器得到一个白色的球\n图5.3 Unity的内置着色器\n图5.4 用假彩色对Unity Shader进行调试\n图5.5 使用颜色拾取器来查看调试信息\n图5.6 帧调试器\n图5.7 单击Knot的深度图渲染事件，在Game视图会显示该事件的效果，在Hierarchy视图中会高亮显示Knot对象，在帧调试器的右侧窗口会显示出该事件的细节\n图5.8 OpenGL和DirectX使用了不同的屏幕空间坐标\n第6章 Unity中的基础光照 图6.1 在左图中，光是垂直照射到物体表面，因此光线之间的垂直距离保持不变；而在右图中，光是斜着照射到物体表面，在物体表面光线之间的距离是d/cosθ，因此单位面积上接收到的光线数目要少于左图\n图6.2 散射时，光线会发生折射和反射现象。对于不透明物体，折射的光线会在物体内部继续传播，最终有一部分光线会重新从物体表面被发射出去\n图6.3 使用Phong模型计算高光反射\n图6.4 Blinn模型\n图6.5 在Unity的Window -\u0026gt; Lighting面板中，我们可以通过Ambient Source/Ambient Color/Ambient Intensity来控制场景中的环境光的颜色和强度\n图6.6 逐顶点的漫反射光照效果\n图6.7 逐像素的漫反射光照效果\n图6.8 逐顶点漫反射光照、逐像素漫反射光照、半兰伯特光照的对比效果\n图6.9 CG的reflect函数\n图6.10 逐顶点的高光反射光照效果\n图6.11 逐像素的高光反射光照效果\n图6.12 逐顶点的高光反射光照、逐像素的高光反射光照（Phong光照模型）和Blinn-Phong高光反射光照的对比结果\n第7章 基础纹理 图7.1 Unity中的纹理坐标\n图7.2 使用单张纹理\n图7.3 调节纹理的平铺（缩放）和偏移（平移）属性\n图7.4 纹理的属性\n图7.5 Wrap Mode决定了当纹理坐标超过[0, 1]范围后将会如何被平铺\n图7.6 偏移（Offset）属性决定了纹理坐标的偏移量\n图7.7 在放大纹理时，分别使用三种Filter Mode得到的结果\n图7.8 在Advanced模式下可以设置多级渐远纹理的相关属性\n图7.9 从上到下： Point滤波 + 多级渐远纹理技术，Bilinear滤波 + 多级渐远纹理技术，Trilinear滤波 + 多级渐远纹理技术\n图7.10 选择纹理的最大尺寸和纹理模式\n图7.11 高度图\n图7.12 模型顶点的切线空间。其中，原点对应了顶点坐标，x轴是切线方向（t），y轴是副切线方向（b），z轴是法线方向（n）\n图7.13 左图：模型空间下的法线纹理。右图：切线空间下的法线纹理\n图7.14 使用法线纹理\n图7.15 使用Bump Scale属性来调整模型的凹凸程度\n图7.16 当使用UnpackNormal函数计算法线纹理中的法线方向时，需要把纹理类型标识为Normal map\n图7.17 当勾选了Create from Grayscale后，Unity会根据高度图来生成一张切线空间下的法线纹理\n图7.18 使用不同的渐变纹理控制漫反射光照，左下角给出了每张图使用的渐变纹理\n图7.19 Wrap Mode分别为Repeat和Clamp模式的效果对比\n图7.20 使用高光遮罩纹理。从左到右：只包含漫反射，未使用遮罩的高光反射，使用遮罩的高光反射\n图7.21 本节使用的高光遮罩纹理\n第8章 透明效果 图8.1 场景中有两个物体，其中A（黄色）是半透明物体，B（紫色）是不透明物体\n图8.2 场景中有两个物体，其中A和B都是半透明物体\n图8.3 循环重叠的半透明物体总是无法得到正确的半透明效果\n图8.4 使用哪个深度对物体进行排序。红色点分别标明了网格上距离摄像机最近的点、最远的点以及网格中点\n图8.5 一张透明纹理，其中每个方格的透明度都不同\n图8.6 透明度测试\n图8.7 随着Alpha cutoff参数的增大，更多的像素由于不满足透明度测试条件而被剔除\n图8.8 透明度混合\n图8.9 随着Alpha Scale参数的增大，模型变得越来越透明\n图8.10 当模型网格之间有互相交叉的结构时，往往会得到错误的半透明效果\n图8.11 开启了深度写入的半透明效果\n图8.12 不同混合状态设置得到的效果\n图8.13 双面渲染的透明度测试的物体\n图8.14 双面渲染的透明度混合的物体\n第9章 更复杂的光照 图9.1 设置Unity项目的渲染路径\n图9.2 摄像机组件的Rendering Path中的设置可以覆盖Project Settings中的设置\n图9.3 设置光源的类型和渲染模式\n图9.4 前向渲染的两种Pass\n图9.5 平行光\n图9.6 点光源\n图9.7 开启Scene视图中的光照\n图9.8 聚光灯\n图9.9 使用一个平行光和一个点光源共同照亮物体。右图显示了胶囊体、平行光和点光源在场景中的相对位置\n图9.10 使用1个平行光 + 4个点光源照亮一个物体\n图9.11 打开帧调试器查看场景的绘制事件\n图9.12 本例中的6个渲染事件，绘制顺序是从左到右、从上到下进行的\n图9.13 如果物体不在一个光源的光照范围内（从右图可以看出，胶囊体不在最左方的点光源的照明范围内），Unity是不会调用Additional Pass来为该物体处理该光源的\n图9.14 当把光源的Render Mode设为Not Important时，这些光源就不会按逐像素光来处理\n图9.15 开启光源的阴影效果\n图9.16 Mesh Renderer组件的Cast Shadows和Receive Shadows属性可以控制该物体是否投射/接收阴影\n图9.17 开启Cast Shadows和Receive Shadows，从而让正方体可以投射和接收阴影\n图9.18 把Cast Shadows设置为Two Sided可以让右侧平面的背光面也产生阴影\n图9.19 正方体可以接收来自右侧平面的阴影\n图9.20 使用帧调试器查看阴影绘制过程\n图9.21 正方体对深度纹理的更新结果\n图9.22 屏幕空间的阴影图\n图9.23 Unity绘制屏幕阴影的过程\n图9.24 可以投射阴影的使用透明度测试的物体\n图9.25 正确设置了Fallback的使用透明度测试的物体\n图9.26 正确设置了Cast Shadow属性的使用透明度测试的物体\n图9.27 把使用了透明度混合的Unity Shader的Fallback设置为内置的Transparent/VertexLit。半透明物体不会向下方的平面投射阴影，也不会接收来自右侧平面的阴影，它看起来就像是完全透明一样\n图9.28 把Fallback设为VertexLit来强制为半透明物体生成阴影\n第10章 高级纹理 图10.1 对立方体纹理的采样\n图10.2 天空盒子材质\n图10.3 为场景使用自定义的天空盒子\n图10.4 使用了天空盒子的场景\n图10.5 使用脚本创建立方体纹理\n图10.6 使用脚本渲染立方体纹理\n图10.7 使用了反射效果的Teapot模型\n图10.8 斯涅尔定律\n图10.9 使用了折射效果的Teapot模型\n图10.10 使用了菲涅耳反射的Teapot模型\n图10.11 镜子效果\n图10.12 左图：把摄像机的Target Texture设置成自定义的渲染纹理。右图：渲染纹理使用的纹理设置\n图10.13 玻璃效果\n图10.14 本例使用的立方体纹理\n图10.15 脚本生成的程序纹理\n图10.16　调整程序纹理的参数来得到不同的程序纹理\n图10.17　后缀为.sbsar的Substance材质\n图10.18　程序纹理资源\n图10.19　调整程序纹理属性可以得到看似完全不同的程序材质效果\n第11章 让画面动起来 图11.1 本节使用的序列帧图像\n图11.2 使用序列帧动画来实现爆炸效果\n图11.3 无限滚动的背景（纹理来源：forest-background © 2012-2013 Julien Jorge julien.jorge@stuff-o-matic.com）\n图11.4 使用顶点动画来模拟2D的河流\n图11.5 法线固定（总是指向视角方向）时，计算广告牌技术中的三个正交基的过程\n图11.6 广告牌效果。左图显示了摄像机和5个广告牌之间的位置关系，摄像机是从斜上方向下观察它们的。中间的图显示了当Vertical Restraints属性为1，即固定法线方向为观察视角时所得到的效果，可以看出，所有的广告牌都完全面朝摄像机。右图显示了当Vertical Restraints属性为0，即固定指向上的方向为(0, 1, 0)时所得到的效果，可以看出，广告牌虽然最大限度地面朝摄像机，但其指向上的方向并未发生改变\n图11.7 当进行顶点动画时，如果仍然使用内置的ShadowCaster Pass来渲染阴影，可能会得到错误的阴影效果\n图11.8 使用自定义的ShadowCaster Pass\u2028为变形物体绘制正确的阴影\n第12章 屏幕后处理效果 图12.1 左图：原效果。右图：调整了亮度（值为1.2）、饱和度（值为1.6）和对比度（值为1.2）后的效果\n图12.2 为脚本设置Shader的默认值\n图12.3 左图：12.2节得到的结果。\u2028右图：进行边缘检测后的效果\n图12.4 卷积核与卷积。使用一个3×3大小的卷积核对一张5×5大小的图像进行卷积操作，当计算图中红色方块对应的像素的卷积结果时，我们首先把卷积核的中心放置在该像素位置，翻转核之后再依次计算核中每个元素和其覆盖的图像像素值的乘积并求和，得到新的像素值\n图12.5 三种常见的边缘检测算子\n图12.6 只显示边缘的屏幕效果\n图12.7 左图：原效果。右图：高斯模糊后的效果\n图12.8 一个5×5大小的高斯核。左图显示了标准方差为1的高斯核的权重分布。我们可以把这个二维高斯核拆分成两个一维的高斯核（右图）\n图12.9 动画短片《大象之梦》中的Bloom效果。光线透过门扩散到了周围较暗的区域中\n图12.10 左图：原效果。右图：Bloom处理后的效果\n图12.11 左图：原效果。右图：应用运动模糊后的效果\n第13章 使用深度和法线纹理 图13.1 在透视投影中，投影矩阵首先对顶点进行了缩放。在经过齐次除法后，透视投影的裁剪空间会变换到一个立方体。图中标注了4个关键点经过投影矩阵变换后的结果\n图13.2 在正交投影中，投影矩阵对顶点进行了缩放。在经过齐次除法后，正交投影的裁剪空间会变换到一个立方体。图中标注了4个关键点经过投影矩阵变换后的结果\n图13.3 使用Frame Debugger查看深度纹理（左）和深度+法线纹理（右）。如果当前摄像机需要生成深度和法线纹理，帧调试器的面板中就会出现相应的渲染事件。只要单击对应的事件就可以查看得到的深度和法线纹理\n图13.4 左图：线性空间下的深度纹理。右图：解码后并且被映射到[0, 1]范围内的视角空间下的法线纹理\n图13.5 左图：原效果。右图：添加全局雾效后的效果\n图13.6 计算interpolatedRay\n图13.7 采样得到的深度值并非是点到摄像机的欧式距离\n图13.8 左图：原效果。右图：直接对颜色图像进行边缘检测的结果\n图13.9 在深度和法线纹理上进行更健壮的边缘检测。左图：在原图上描边的效果。右图：只显示描边的效果\n图13.10 Roberts算子\n第14章 非真实感渲染 图14.1 游戏《大神》（英文名：Okami）的游戏截图\n图14.2 卡通风格的渲染效果\n图14.3 左图：未对高光区域进行抗锯齿处理。右图：使用fwidth函数对高光区域进行抗锯齿处理\n图14.4 一个TAM的例子（来源：Praun E, et al. Real-time hatching4）\n图14.5 素描风格的渲染效果\n第15章 使用噪声 图15.1 箱子的消融效果\n图15.2 消融效果使用的噪声纹理\n图15.3 包含菲涅耳反射的水面波动效果。在左图中，视角方向和水面法线的夹角越大，反射效果越强。在右图中，视角方向和水面法线的夹角越大，折射效果越强\n图15.4 本例使用的立方体纹理\n图15.5 水波效果使用的噪声纹理。左图：噪声纹理的灰度图。右图：由左图生成的法线纹理\n图15.6 左图：均匀雾效。右图：使用噪声纹理后的非均匀雾效\n图15.7 本节使用的噪声纹理\n第16章 Unity中的渲染优化技术 图16.1 Unity 5的渲染统计窗口\n图16.2 使用Unity的性能分析器中的渲染区域来查看更多关于渲染的统计信息\n图16.3 使用帧调试器来查看单独的draw call的绘制结果\n图16.4 动态批处理\n图16.5 多光源对动态批处理的影响结果\n图16.6 静态批处理前的渲染统计数据\n图16.7 把物体标志为Static\n图16.8 静态批处理\n图16.9 静态批处理中Unity会合并所有被标识为“Static”的物体\n图16.10 静态批处理会占用更多的内存。左图：静态批处理前的渲染统计数据。右图：静态批处理后的渲染统计数据\n图16.11 处理其他逐像素光的Pass不会被静态批处理\n图16.12 Unity的高级纹理设置面板\n第17章 Surface Shader探秘 图17.1 表面着色器的例子。左图：在一个平行光下的效果。右图：添加了一个点光源（蓝色）和一个聚光灯（紫色）后的效果\n图17.2 查看表面着色器生成的代码\n图17.3 表面着色器的渲染计算流水线。黄色：可以自定义的函数。灰色：Unity自动生成的计算步骤\n图17.4 沿顶点法线对模型进行膨胀。左图：膨胀前。右图：膨胀后\n第18章 基于物理的渲染 图18.1 在理想的边界处，折射率的突变会把光线分成两个方向\n图18.2 左图：光滑表面的微平面的法线变化较小，反射光线的方向变化也更小。\u2028右图：粗糙表面的微平面的法线变化较大，反射光线的方向变化也更大\n图18.3 微表面对光的折射。这些被折射的光中一部分被吸收，一部分又被散射到外部\n图18.4 次表面散射。左图：次表面散射的光线会从不同于入射点的位置射出。如果这些距离值小于需要被着色的像素大小，那么渲染就可以完全在局部完成（右图）。否则，就需要使用次表面散射渲染技术\n图18.5 BRDF描述的两种现象。高光反射部分用于描述反射，漫反射部分用于描述次表面散射\n图18.6 （a）那些m=h的微面元会恰好把入射光从I反射到v上，只有这部分微面元才可以添加到BRDF的计算中。（b）一部分满足（a）的微面元会在I方向上被其他微面元遮挡住，它们不会接受到光照，因此会形成阴影。（c）还有一部分满足（a）的微面元会在反射方向v上被其他微面元挡住，因此，这部分反射光也不会被看到\n图18.7 Standard Shader中前向渲染路径使用的Pass（简化版本的PBS使用了VertexOutputBaseSimple等结构体来代替相应的结构体）\n图18.8 Unity提供的校准表格。左图：金属工作流\u2028使用的校准表格。右图：高光反射工作流使用的校准表格\n图18.9 使用金属工作流来实现不同类型的材质。左边的球体：金属材质。右边的球体：塑料材质\n图18.10 在Unity 5中使用基于物理的渲染技术，场景在不同光照下的渲染结果\n图18.11 光照面板下的Scene标签页\n图18.12 左图：当关闭场景中的所有光源并把环境光照强度设为0后，使用了Standard Shader的物体仍然具有光照效果。右图：在左图的基础上，把反射源设置为空，使得物体不接受任何默认的反射信息\n图18.13 使用的平行光\n图18.14 左图：将Bounce Intensity设置为0，物体不再受到间接光照的影响，木屋内阴影部分的可见细节很少。右图：将Bounce Intensity设为8，阴影部分的细节更加清楚\n图18.15 左图：未使用反射探针。右图：在场景中放置了两个反射探针，注意墙上的盾牌与左图的差别\n图18.16 使用反射探针实现相互反射的效果\n图18.17 左图：在线性空间下的渲染结果。右图：在伽马空间下的渲染结果\n图18.18 人眼更容易感知暗部区域的变换，而对较亮区域的变化比较不敏感\n图18.19 编码伽马和显示伽马\n图18.20 左图：伽马空间下的渲染结果。右图：线性空间下的渲染结果\n图18.21 左图：伽马空间下的混合结果。右图：线性空间下的混合结果\n第19章 Unity 5更新了什么 图19.1 在shader的导入面板中，单击图中按钮可查看Unity为该固定管线着色器生成的顶点/片元着色器代码B](http://static.zybuluo.com/candycat/xuxe7bp91pykknxybt6yu2wu/gamma_light.png)\n图18.20 左图：伽马空间下的渲染结果。右图：线性空间下的渲染结果\n图18.21 左图：伽马空间下的混合结果。右图：线性空间下的混合结果\n第19章 Unity 5更新了什么 图19.1 在shader的导入面板中，单击图中按钮可查看Unity为该固定管线着色器生成的顶点/片元着色器代码\n","description":"","id":5,"section":"posts","tags":["Unity Shader入门精要"],"title":"《Unity Shader入门精要》随书彩色插图","uri":"https://yslinwe.github.io/posts/unity-shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E9%9A%8F%E4%B9%A6%E5%BD%A9%E8%89%B2%E6%8F%92%E5%9B%BE/"},{"content":"题目描述：\nchar szNum[]=\u0026ldquo;123456789\u0026rdquo;;\nint n=(short)(szNum+4)- (short)(szNum);\n问n = ？\n答案大家可以编程实现，n=1028。就这题来说，无论是小端还是大端 都是1028。\n看你的系统是小端还是大端可以用下面这个函数测试：\n//如果字节序为big-endian，返回true;\n//反之为 little-endian，返回false\nbool IsBig_Endian()\n{\nunsigned short test = 0x1234;\nif(( (unsigned char) \u0026amp;test ) == 0x12)\nreturn TRUE;\nelse\nreturn FALSE;\n}//IsBig_Endian()\n(short)(szNum+4) 这句话 首先是将szNum + 4 这个字符型地址 强制转换成short型地址，因为地址都是4个字节存储的，所以值不会变。也就是说，这个地址由指向字符的地址变成了指向short型变量的地址了。而这个地址值没有变。那么这个区别在哪里呢？\n因为地址指向的都是相同的地方，那么区别就在于取值了。\n如果是小端，那么计算机存储的是高位在高地址，低位在低地址，而short型是两个字节的变量。所以(short*)(szNum+4) 这个指向的值是低位，它只指了一个字节，而short有两个字节，而第二个字节就是这个地址的下一个地址所指向的值，这个值就是高位，例如问题里，szNum+4 指向的是字符‘5’，这个只是一个字节，它代表的是低位，而下一个字节自然就是字符‘6’，它代表的是高位，所以*(short*)(szNum+4)取出来的值就是0x36 35 ，这里因为字符’5‘的十六进制为35 字符‘6’的十六进制为36 所以取出的即为此值。\n同理取*(short*)(szNum) 也是这个原理，取‘1’， ‘2’ 两个字节，值为0x32 31 ，结果即为0x36 35 - 0x32 31 = 1028\n如果是大端，就只是将高低位转换一下，和小端类似，小端对计算机易于处理，而大端符合人类正常思维。\n————————————————\n版权声明：本文为CSDN博主「娜一笑最倾城」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/ljd4305/article/details/8929345\n","description":"","id":6,"section":"posts","tags":["关于一个指针取值的问题"],"title":"关于一个指针取值的问题","uri":"https://yslinwe.github.io/posts/%E5%85%B3%E4%BA%8E%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E5%8F%96%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/"},{"content":"字节、字、位、比特之间的关系是：  1位=1比特；1字=2字节；1字节=8位；1字=16位。\n  位  位是计算机存储的最小单位，简记为b，也称为比特（bit）计算机中用二进制中的0和1来表示数据，一个0或1就代表一位。位数通常指计算机中一次能处理的数据大小；\n比特  比特（bit）是由英文BIT音译而来，比特同时也是二进制数字中的位，是信息量的度量单位，为信息量的最小单位；\n字节  字节，英文Byte，是计算机用于计量存储容量的一种计量单位，通常情况下一字节等于八位，字节同时也在一些计算机编程语言中表示数据类型和语言字符，在现代计算机中，一个字节等于八位；\n字  字是表示计算机自然数据单位的术语，在某个特定计算机中，字是其用来一次性处理事务的一个固定长度的位（bit）组，在现代计算机中，一个字等于两个字节。\n\n扩展资料：\n计算机中的存储单位有：bit、B、KB、MB、GB、TB、PB、EB、ZB、YB、BB、NB、DB等。\n这些单位中最小的单位是——位 bit (比特)(Binary Digits)，一个位存放一位二进制数，即 0 或 1，它是计算机存储中最小的存储单位。\n其他的单位相互之间的换算关系入下：\n1 Byte（B）= 8 bit；\n1 Kilo Byte（KB） = 1024B；\n1 Mega Byte（MB） = 1024 KB；\n1 Giga Byte （GB）= 1024 MB；\n1 Tera Byte（TB）= 1024 GB；\n1 Peta Byte（PB） = 1024 TB；\n1 Exa Byte（EB） = 1024 PB；\n1 Zetta Byte（ZB） = 1024 EB；\n1Yotta Byte（YB）= 1024 ZB；\n1 Bronto Byte（BB） = 1024 YB；\n1 Nona Byte（NB）=1024 BB；\n1 Dogga Byte（DB）=1024 NB；\n1 Corydon Byte（CB）=1024DB；\n1 Xero Byte （XB）=1024CB；\n","description":"","id":7,"section":"posts","tags":["字节、字、位、比特"],"title":"字节、字、位、比特之间的关系","uri":"https://yslinwe.github.io/posts/%E5%AD%97%E8%8A%82%E5%AD%97%E4%BD%8D%E6%AF%94%E7%89%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"content":"顶点、 图元、片元、像素的含义 *阶段1. 顶点 -\u0026gt;图元*\n几何顶点被组合为图元（点，线段或多边形），然后图元被合成片元，最后片元被转换为帧缓存中的象素数据。\n*阶段2. 图元 -\u0026gt;片元*\n图元被分几步转换为片元：图元被适当的裁剪，颜色和纹理数据也相应作出必要的调整，相关的坐标被转换为窗口坐标。最后，光栅化将裁剪好的图元转换为片元。\n 裁剪  在裁剪时点，线段和多边形处理略微不同。对于点，要么保留原始状态（在裁剪体内部），要么被裁掉（在裁剪体外部）。对于线段和多边形来说，如果部分在裁剪体外部，则需要在裁剪点生成新的几何顶点。对于多边形，还需要在新增的顶点间增加完整的边。不论裁剪了线段还是多边形，都需要给新增几何点赋予边界标志、法线、颜色和纹理坐标信息。\n裁剪过程时两步：\na 应用程序指定裁剪（Application-specific clipping），一旦组合图元完成后，如果在程序中用glClipPlane()函数定义了任意的裁剪面，就进行裁剪。\nb 视景体裁剪（View volume clipping），随后，图元被投影矩阵投影（进入裁剪坐标系），被相应的视景体裁剪。投影矩阵可以由glFrustum() 或者glOrtho()定义，投影矩阵的操作和上面其他矩阵变换的操作相同。\n2） 转换到窗口坐标\n裁剪坐标在转换为窗口坐标之前，要除以规格化设备坐标（normalized device coordinates）的w值进行规范化。然后对这些规范化数据进行视口变换（viewport）计算生成窗口坐标。可以用glDepthRange()和glViewport()控制视口大小，决定屏幕上显示图象的区域。\n光栅化  光栅化是将一个图元转变为一个二维图象（其实只是布满平面，没有真正的替换帧缓存区）的过程。二维图象上每个点都包含了颜色、深度和纹理数据。将该点和相关信息叫做一个片元（fragment）。（yuyu注：这就是片元和像素之间的关键区别，虽然两者的直观印象都是的像素，但是片元比像素多了许多信息，在光栅化中纹理映射之后图元信息转化为了像素）在这个阶段，对象素绘制和位图进行操作需要用到当前栅格位置（用glRasterPos*()定义）。正如上面讨论的，三种图元的光栅化方法是不同的，另外，象素块和位图也需要光栅化。\na）图元\n采用glPointSize(), glLineWidth(), glLineStipple()和 glPolygonStipple()函数可以选择图元的光栅化维数和模式。另外，还可以用glCullFace(), glFrontFace()和glPolygonMode()控制多边形正反面不同的光栅化效果。\nb）象素\n有几个函数实现象素保存和转换。函数glPixelStore*()用于内存中的象素是如何保存的。glPixelTransfer*() and glPixelMap*()用于象素在写入帧缓冲区前是如何处理的。glDrawPixels()定义了一个象素矩形。用glPixelZoom()实现象素的缩放。\nc）位图\n位图是具有特定片元模式的0和1的矩形。每个片元有相同的相关数据。可以用glBitmap()定义。\nd）纹理存储\n纹理贴图是将指定的部分纹理图象映射到每个图元上。每个片元（fragment）具有的纹理坐标属性，该坐标与纹理图象坐标对应，得到纹理图象该位置的颜色值来修改片元的RGBA颜色，从而完成这个映射过程。用glTexImage2D()或glTexImage1D()来定义纹理图象。glTexParameter*()和glTexEnv*()来控制纹理如何解释和应用到一个片元上。\ne)雾\n已经光栅化的片元具有纹理贴图修正后颜色，可以采用融合因子再融合雾颜色，该融合因子大小根据视点和片元间的距离来定。用glFog*()指定雾化颜色和融合因子。\n*阶段3. 片元-\u0026gt;像素*\nOpenGL允许光栅化生成一个片元，只要该片元通过一系列检测就可以修改帧缓冲区中对应象素。如果它通过测试，片元数据可以直接替换帧缓冲区中的已有值，或者和已有值合并，这取决于设置的模式。\n1）象素所有权（ownership）检测\n第一个测试是判断在帧缓冲区中的象素所对应的某个片元是否属于当前OpenGL上下文。如果属于，片元进行下一个测试。如果不属于，窗口系统决定是否忽略该片元，或者是否进行下一步片元操作。\n2）裁剪检测\n用glScissor()函数，可以定义一个任意屏幕校准矩形，在该矩形外的片元将被忽略。\n3）Alpha检测\nAlpha测试只能在RGBA模式下进行，如果片元的alpha值超出一个固定参照值，片元将被忽略，这个比较函数可以用glAlphaFunc()实现并设定参考值。\n4）模版检测\n当模版缓冲区的值超出一个参照值，模版测试将有条件的忽略该片元。这个比较函数和固定值可以用glStencilFunc()实现。不论图元通过或没有通过模版测试，模版缓冲区中的值会根据glStencilOp()函数进行修改。\n5）深度检测\n当深度缓冲区的值与参照值的比较失败，深度测试忽略该片元。GlDepthFuc()用来执行这个比较命令。如果模版启用，深度比较的结果会影响模版缓冲区值的更新。\n6）融合\n融合合并了一个片元R、G、B和A值和存储在帧缓冲区对应位置的这些值。融合只能在RGBA模式下实现，它的实现需要片元的alpha值和对应当前存储象素，还需要RGB值。用glBendFun()控制，可以修改融合因子的源和目标。\n7）抖动\n如果启动抖动，片元的颜色或者颜色索引采用抖动算法。这个算法只需要片元的颜色值和它的x和y坐标。\n8）逻辑操作\n最后，在片元和帧缓冲区对应值之间要进行一个逻辑操作，结果将替换当前帧缓冲区的值。用glLogicOp定义想要的逻辑操作。这个逻辑操作只能在颜色索引模式下运行，而不能在RGBA模式运行。\n*象素*\n在OpenGL流水线的上个阶段，片元转换为帧缓冲区中的象素。帧缓冲区实际上是一组逻辑缓冲区——包括颜色缓冲区、深度缓冲区、模版缓冲区和累积缓冲区。颜色缓冲区包括左、前右、后左、后右和一些辅助缓存值（auxiliary buffers）。可以直接从中读取或者复制。对于OpenGL不同上下文，这些缓冲区可能不全\n1）帧缓冲区操作\n用glDrawBuffer为绘图选择一个颜色缓冲区。另外在预片元化（per-fragment）操作后，可以用四个不同函数保留写入这些逻辑缓冲区的操作，glIndexMask(), glColorMask(), glDepthMask(), and glStencilMask()。glAccum()对累积缓冲区进行操作。最后glClearColor(), glClearIndex(), glClearDepth(), glClearStencil()和glClearAccum().对不同缓冲区中指定相对应的颜色值、颜色索引值、深度值、模板值和累积值。\n2)读取和复制象素\n用glReadPixel()从帧缓冲区中把象素读到内存中，进行各种操作，保存处理结果。另外，可以用glCopyPixel()从帧缓冲区中复制一块象素到另一个帧混存。glReadBuffer()可以读取和复制颜色缓冲区中的象素。\n转载： https://blog.csdn.net/u014800094/article/details/53035889\n","description":"","id":8,"section":"posts","tags":["顶点、 图元、片元、像素"],"title":"顶点、 图元、片元、像素的含义","uri":"https://yslinwe.github.io/posts/%E9%A1%B6%E7%82%B9-%E5%9B%BE%E5%85%83%E7%89%87%E5%85%83%E5%83%8F%E7%B4%A0%E7%9A%84%E5%90%AB%E4%B9%89/"},{"content":"数据结构笔记 顺序栈和顺序队列使用动态数组实现\n以下不是C++中stack的实现\n顺序栈 特点：后进先出，先进后出\n栈可以用数组或者链表写\n开始时，栈顶Top=-1\n顺序栈操作 Push（栈顶添加元素）\nTop（返回当前栈顶数据）\nPop （删除栈顶数据）\nIsEmpty（检查栈是否为空）\n数组实现 实现自动扩大数组大小 模板类实现和声明要写在一起 1 2 3 4 5 6 7 8 9 10  template\u0026lt;class T\u0026gt; void ChangeSize1D(T* \u0026amp;a,const int oldSize, const int newSize) { if(newSize\u0026lt;0) throw \u0026#34;newSize must be \u0026gt;=0\u0026#34;; T* temp =new T[newSize]; int number = min(oldSize,newSize); std::copy(a,a+number,temp); delete[] a; a=temp; }   顺序队列（Queue） 特点：先进先出，后进后出\n队列操作  Push（队尾添加元素） Pop （队首删除元素） Front（返回当前队首数据） Rear（返回当前队尾数据） IsEmpty（检查队列是否为空）  实现回绕（利用数组删除后留下的空间）  rear=front front++ 如果front=rear表示队列满了，要自动扩大数组大小  链表  链表：1.数据域 2.链接域 数组缺点：插入数据时慢，需要向后移动，删除数据时，需要向前移动。 链表可以弥补这些缺点。  树  数组缺点：插入数据，数据要移动。 数组优点：二分查找 链表缺点：无法二分查找 链表优点: 插入删除数据快 树 = 数组的优点 + 链表的优点  ","description":"","id":10,"section":"posts","tags":["数据结构"],"title":"数据结构学习","uri":"https://yslinwe.github.io/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"},{"content":"搭建网盘过程 1.安装docker 通过yum源安装docker 1  sudo yum -y install docker   启动docker 1  sudo systemctl start docker   开机自启 1  sudo systemctl enable docker   2.获取nextcloud镜像, 完成网盘搭建 1  docker run -d -p 8080:80 nextcloud   ","description":"","id":11,"section":"posts","tags":["nextcloud"],"title":"nextcloud搭建","uri":"https://yslinwe.github.io/posts/nextcloud-%E6%90%AD%E5%BB%BA/"},{"content":"aria2 简单使用 整体方案是 独立的 aria2 程序 + aria2-conf + Chrome 插件\naria2 在 https://github.com/aria2/aria2/releases 下载最新的 Release\naria2-conf 使用 https://github.com/ttttmr/aria2-conf 的配置文件，下载 zip 包即可（或者 git clone）\n配置 把下好的压缩包解压，存一起，重命名一下\naria2-1.34.0-win-64bit-build1` -\u0026gt; `bin aria2-conf-master` -\u0026gt; `conf \n先给 aria2 的 bin 配上环境变量，也方便命令行里用\n然后配置一下 conf/aria2.conf 文件就可以用了\n主要更改如下\n#设置密码 18 rpc-secret = xxxxxx ... 89 dir = D:\\Download #填默认下载目录 双击 HideRun.vbs 就可以启动 aria2 了，需要自启的话可以将快捷方式发送到开始菜单 startup 里\n startup 在这里 %APPDATA%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\n  启动双击 start.bat ，后台运行双击 HideRun.vbs ，关闭双击 stop.bat ，重启双击 restart.bat\n Chrome 联动 Chrome 插件用的是 Aria2 for Chrome\n一共有 2 个要填密码的地方\n一个是在插件设置填 RPC 地址\nhttp://token:xxxx@localhost:6800/jsonrpc xxx 是你设置的密码\n一个是 ariang 的 RPC 配置\n\n","description":"","id":12,"section":"posts","tags":["aria2"],"title":"aria2 简单使用","uri":"https://yslinwe.github.io/posts/aria2-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"content":"Mac安装Homebrew 国内安装(可用)： /bin/zsh -c \u0026quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)\u0026quot; 以上方法来自：https://zhuanlan.zhihu.com/p/111014448\n","description":"","id":13,"section":"posts","tags":["Mac"],"title":"Mac 安装homebrew","uri":"https://yslinwe.github.io/posts/mac/mac-%E5%AE%89%E8%A3%85homebrew/"},{"content":"Docker删除镜像和容器 查看运行的容器 1  docker ps   查看已经退出的容器 1  docker ps -a   删除镜像 1  docker rmi -f 镜像id   删除容器 1  docker rm -f 容器id   ","description":"","id":14,"section":"posts","tags":["Docker"],"title":"Docker删除镜像和容器","uri":"https://yslinwe.github.io/posts/docker%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F%E5%92%8C%E5%AE%B9%E5%99%A8/"},{"content":"剑指office（一）二维数组查找\n剑指office（二）替换空格\n剑指office（三）从尾到头打印链表\n剑指office（四）重建二叉树\n剑指office（五）用两个栈实现队列\n剑指office（六）用两个栈实现队列\n剑指office（七）用两个栈实现队列\n剑指office（八）跳台阶\n剑指office（九）跳台阶扩展问题\n剑指office（十）矩形覆盖\n剑指office（十一）二进制中1的个数\n剑指office（十二）数值的整数次方\n剑指office（十三）调整数组顺序使奇数位于偶数前面\n剑指office（十四）链表中倒数第k个结点\n剑指office（十五）反转链表\n剑指office（十六）合并两个排序的链表\n剑指office（十七）树的子结构\n剑指office（十八）二叉树的镜像\n剑指office（十九）顺时针打印矩阵\n剑指office（二十）包含min函数的栈\n剑指office（二十一）栈的压入、弹出序列\n剑指office（二十二）从上往下打印二叉树\n剑指office（二十三）二叉树搜索树的后序遍历序列\n剑指office（二十四）二叉树中和为某一值的路径\n剑指office（二十五）复杂链表的复制\n剑指office（二十六）二叉树搜索树与双向链表\n","description":"剑指office","id":15,"section":"posts","tags":["剑指office"],"title":"剑指office","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer%E7%9B%AE%E5%BD%95/"},{"content":"Git Flow 的正确使用姿势 Git Flow 的概念 在使用Git的过程中如果没有清晰流程和规划，否则,每个人都提交一堆杂乱无章的commit,项目很快就会变得难以协调和维护。\nGit版本管理同样需要一个清晰的流程和规范。\nVincent Driessen 为了解决这个问题提出了 A Successful Git Branching Model\n以下是基于Vincent Driessen提出的Git Flow 流程图\nGit Flow 的常用分支   Production 分支 也就是我们经常使用的Master分支，这个分支最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支直接修改\n  Develop 分支 这个分支是我们是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支\n  Feature 分支 这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release\n  Release分支 当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支\n  Hotfix分支 当我们在Production发现新的Bug时候，我们需要创建一个Hotfix, 完成Hotfix后，我们合并回Master和Develop分支，所以Hotfix的改动会进入下一个Release。\n  Git Flow 如何使用   Master/Devlop 分支 所有在Master分支上的Commit应该打上Tag，一般情况下Master不存在Commit，Devlop分支基于Master分支创建。\n  Feature 分支 Feature分支做完后，必须合并回Develop分支, 合并完分支后一般会删点这个Feature分支，毕竟保留下来意义也不大。  Release 分支 Release分支基于Develop分支创建，打完Release分支之后，我们可以在这个Release分支上测试，修改Bug等。同时，其它开发人员可以基于Develop分支新建Feature (记住：一旦打了Release分支之后不要从Develop分支上合并新的改动到Release分支)发布Release分支时，合并Release到Master和Develop， 同时在Master分支上打个Tag记住Release版本号，然后可以删除Release分支了。\n  Hotfix 分支 hotfix分支基于Master分支创建，开发完后需要合并回Master和Develop分支，同时在Master上打一个tag。\n  Git Flow 命令示例 创建 Devlop 1 2  git branch develop git push -u origin develop   开始 Feature 1 2 3 4 5 6 7 8 9  # 通过develop新建feaeure分支 git checkout -b feature develop # 或者, 推送至远程服务器: git push -u origin feature # 修改md文件  git status git add . git commit   完成 Feature 1 2 3 4 5 6 7 8 9 10 11 12 13  git pull origin develop git checkout develop #--no-ff：不使用fast-forward方式合并，保留分支的commit历史 #--squash：使用squash方式合并，把多次分支commit历史压缩为一次 git merge --no-ff feature git push origin develop git branch -d some-feature # 如果需要删除远程feature分支: git push origin --delete feature   开始 Release 1  git checkout -b release-0.1.0 develop   完成 Release 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  git checkout master git merge --no-ff release-0.1.0 git push git checkout develop git merge --no-ff release-0.1.0 git push git branch -d release-0.1.0 git push origin --delete release-0.1.0 # 合并master/devlop分支之后，打上tag  git tag -a v0.1.0 master git push --tags   开始 Hotfix 1  git checkout -b hotfix-0.1.1 master   完成 Hotfix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  git checkout master git merge --no-ff hotfix-0.1.1 git push git checkout develop git merge --no-ff hotfix-0.1.1 git push git branch -d hotfix-0.1.1 git push origin --delete hotfix-0.1.1 git tag -a v0.1.1 master git push --tags   使用建议 如果你的代码没有清晰流程和规划，那么强烈推荐使用Vincent Driessen 提出的GIt flow让你的代码管理骚起来。\n结尾 本站文章图片等等来源于网络,仅作为学习之用,版权归原作者所有.如果侵犯了您的权益,请来信告知,我会尽快删除.\n","description":"","id":16,"section":"posts","tags":["git"],"title":"Git Flow 的正确使用姿势","uri":"https://yslinwe.github.io/posts/github/git-flow-%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/"},{"content":"删除 .DS_Store 如果你的项目中还没有自动生成的 .DS_Store 文件，那么直接将 .DS_Store 加入到 .gitignore 文件就可以了。如果你的项目中已经存在 .DS_Store 文件，那就需要先从项目中将其删除，再将它加入到 .gitignore。如下：\n删除项目中的所有.DS_Store。这会跳过不在项目中的 .DS_Store   find . -name .DS_Store -print0 | xargs -0 git rm -f \u0026ndash;ignore-unmatch\n将 .DS_Store 加入到 .gitignore\n  echo .DS_Store \u0026raquo; ~/.gitignore\n  更新项目  git add \u0026ndash;all\n  git commit -m \u0026lsquo;.DS_Store banished!\u0026rsquo;\n  如果你只需要删除磁盘上的 .DS_Store，可以使用下面的命令来删除当前目录及其子目录下的所有.DS_Store 文件:\n1  find . -name \u0026#39;*.DS_Store\u0026#39; -type f -delete   禁用或启用自动生成\n禁止.DS_store生成：\n1  defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE   恢复.DS_store生成：恢复.DS_store生成：\n1  defaults delete com.apple.desktopservices DSDontWriteNetworkStores   ","description":"","id":17,"section":"posts","tags":["Mac"],"title":"Mac中删除.DS_Store","uri":"https://yslinwe.github.io/posts/mac/mac%E4%B8%AD%E5%88%A0%E9%99%A4.ds_store/"},{"content":"入参    参数 描述 是否必传 默认值     gitee-username Gitee用户名 是 -   gitee-password Gitee密码 是 -   gitee-repo Gitee仓库（严格区分大小写） 是 -   branch 要部署的分支 否 master   directory 要部署的分支上的目录 否 ''   https 是否强制使用https 否 true    示例 在GitHub的仓库创建 .github/workflows/ 文件夹并且创建一个**sync.yml** 文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  name:Syncon:push:branches:[giteePage ]jobs:build:runs-on:ubuntu-lateststeps:- name:Sync to Giteeuses:wearerequired/git-mirror-action@masterenv:# 注意在 Settings-\u0026gt;Secrets 配置 PRIVATE SSH_PRIVATE_KEY:${{ secrets.PRIVATE }}with:# 注意替换为你的 GitHub 源仓库地址source-repo:\u0026#34;git@github.com:username/username.github.io.git\u0026#34;# 注意替换为你的 Gitee 目标仓库地址destination-repo:\u0026#34;git@gitee.com:username/username.git\u0026#34;- name:Build Gitee Pagesuses:yanglbme/gitee-pages-action@masterwith:# 注意替换为你的 Gitee 用户名gitee-username:username# 注意在 Settings-\u0026gt;Secrets 配置 PASSWORDgitee-password:${{ secrets.PASSWORD }}# 注意替换为你的 Gitee 仓库gitee-repo:username/username# 提交到gitee的github仓库的分支branch:giteePage  先使用 wearerequired/git-mirror-action 将 GitHub 仓库同步到 Gitee 仓库，再使用 yanglbme/gitee-pages-action 实现 Gitee Pages 的自动部署。\n运行需要在 GitHub 项目的 Settings -\u0026gt; Secrets 路径下配置好 **PRIVATE **以及 PASSWORD 两个密钥。其中：\n **PRIVATE **: 存放你的 id_rsa 私钥。PASSWORD: 存放你的 Gitee 账户密码。\n 1. 配置PRIVATE   生成SSH密钥\n1  ssh-keygen -t rsa -C \u0026#34;name\u0026#34;   \u0026ldquo;name\u0026quot;是任意指定的标识\n 获取公钥  1  cat ~/.ssh/id_rsa.pub    绑定Gitee    复制公钥，通过仓库主页个人图像下拉设置-\u0026gt;SSH公钥添加公钥\n  测试\n打开终端输入：\n1  ssh -T git@gitee.com   显示如下图则成功\n    绑定Github\n复制公钥，通过仓库主页个人图像下拉Setting-\u0026gt;SSH and GPG keys添加公钥\n  测试\n打开终端输入：\n1  ssh -T git@github.com   显示如下图则成功\n    配置\n  获取私钥\n1  cat ~/.ssh/id_rsa    复制私钥，在仓库的Setting-\u0026gt;Secrets路径下命名PRIVATE，Value添加私钥（记得复制全部内容）\n     2. 配置PASSWORD  在仓库的Setting-\u0026gt;Secrets路径下命名PASSWORD，Value添加**Gitee**账户密码。\n 如果一切配置正常，并成功触发 Gitee Pages Action ，我们可能会收到一封来自 Gitee 的告警邮件/站内信。放心，这是 GitHub Action 程序帮我们登录到 Gitee 官网，并为我们点击了项目的部署按钮。\nFAQ 问题 1：遇到短信验证码导致无法自动部署，怎么解决？ 因为 Gitee Pages Action 使用的是 GitHub 自家的服务器（美国），在这种情况下，当 Action 自动\t帮我们登录 Gitee 的时候，会触发 Gitee 帐号异常登录告警，提示用户在非正常的 IP 地址登陆\tGitee，需要输入验证码。\n解决方案是：关注「码云 Gitee」 微信公众号，绑定个人微信到码云帐号。这样 Action 在登录的过程中，Gitee 就不会下发短信验证码，而是通过「码云 Gitee」公众号给我们发送一个登录通知，Action 就能成功登录了。\n问题 2：报 deploy error occurred, message: \u0026lsquo;NoneType\u0026rsquo; object has no attribute \u0026lsquo;group\u0026rsquo; 错误，怎么办？ 报了这个错误，说明 Action 已经成功帮我们登录 Gitee 帐号了，但在访问 Gitee Repo 的过程中出现问题。\n这种情况，一般是 Gitee Pages Action 的参数配置错误导致，请仔细检查你的配置信息。\n 注意：gitee-repo 参数严格区分大小写，请准确填写，比如 doocs/advanced-java，当你写成 doocs/Advanced-java 的时候，是访问不到的，不信你可以试试访问：https://gitee.com/Doocs/Advanced-java\n ","description":"","id":18,"section":"posts","tags":["Github Action","github"],"title":"Github Action 同步gitee和github单个仓库","uri":"https://yslinwe.github.io/posts/github/github-action-%E5%90%8C%E6%AD%A5gitee%E5%92%8Cgithub%E5%8D%95%E4%B8%AA%E4%BB%93%E5%BA%93/"},{"content":"插入图片 使用 Markdown 编写文档或博客时，经常需要对图片的位置与尺寸进行调整。\n插入图片后，Markdown 表示图片的语法格式如下：\n![图片描述](图片链接) 调整图片位置 居左 （1）方法一：添加位置标识。\n1  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200822014538211.png#pic_left)   （2）方法二：嵌入 HTML 代码。\n1 2 3  \u0026lt;div align=\u0026#34;left\u0026#34;\u0026gt; \u0026lt;img src=https://img-blog.csdnimg.cn/20200822014538211.png /\u0026gt; \u0026lt;/div\u0026gt;   居中 （1）方法一：添加位置标识。\n1  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200822014538211.png#pic_center)   （2）方法二：嵌入 HTML 代码。\n1 2 3  \u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;img src=https://img-blog.csdnimg.cn/20200822014538211.png /\u0026gt; \u0026lt;/div\u0026gt;   居右 （1）方法一：添加位置标识。\n1  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200822014538211.png#pic_right)   （2）方法二：嵌入 HTML 代码。\n1 2 3  \u0026lt;div align=\u0026#34;right\u0026#34;\u0026gt; \u0026lt;img src=https://img-blog.csdnimg.cn/20200822014538211.png /\u0026gt; \u0026lt;/div\u0026gt;   调整图片大小 等比缩放 相对于父级窗口 使用百分比只定义宽即可等比例缩放。注意：宽度相对于图片所在父级窗口。\n1  \u0026lt;img src=https://img-blog.csdnimg.cn/20200822014538211.png width=60% /\u0026gt;   相对于自身 非等比缩放 将图片的宽高缩小或放大为原来的指定百分比。\n固定宽高 1  \u0026lt;img src=https://img-blog.csdnimg.cn/20200822014538211.png width=200 height=100 /\u0026gt;   ","description":"","id":19,"section":"posts","tags":["Markdown"],"title":"Markdown 调整图片位置与大小","uri":"https://yslinwe.github.io/posts/markdown/markdown-%E8%B0%83%E6%95%B4%E5%9B%BE%E7%89%87%E4%BD%8D%E7%BD%AE%E4%B8%8E%E5%A4%A7%E5%B0%8F/"},{"content":"安装软件   安装 node.js 下载地址\n  安装PicGO客户端 下载地址\n  在Picgo里面安装Gitee扩展插件\n  安装完成后重启应用在图床设置会显示gitee\n注册Gitee账号并创建图床仓库，获取Token   自行注册账号，创建仓库，仓库记得初始化。 Gitee官网\n  1  个人图片下拉栏 -\u0026gt; 设置 -\u0026gt; 私人令牌   在设置中创建私人令牌（Token）自行保存好，它只会在创建的时候显示一次，之后就不再显示，只能重新生成或者创建\n    配置Picgo上的Gitee 至此Picgo搭配Gitee的图床就搭建完了\n刚快尝试上传图片吧。\n使用Typora的Picgo插件   下载 Typora 下载地址\n  配置Picgo\n  进入Typora设置\n    该设置完成之后，直接将图片复制进Typora 的编辑区即可完成图片的上传，并且文章使用的图片Url就是图床相应的Url。\n  ","description":"","id":20,"section":"posts","tags":["PicGo","个人图床"],"title":"PicGo配合gtiee实现个人图床","uri":"https://yslinwe.github.io/posts/picgo%E9%85%8D%E5%90%88gtiee%E5%AE%9E%E7%8E%B0%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/"},{"content":"git回退到上个版本 1  git reset --hard HEAD^   回退到前3次提交之前，以此类推，回退到n次提交之前 1  git reset --hard HEAD~3   查看commit的sha码 1  git log   1  git show dde8c25694f34acf8971f0782b1a676f39bf0a46   退到/进到 指定commit的sha码 1  git reset --hard dde8c25694f34acf8971f0782b1a676f39bf0a46   强推到远程 git push origin HEAD --force 把git add添加进去的文件撤销添加 git reset HEAD 相对路径名\n1  git reset HEAD public/uploads/   git练习地址: https://learngitbranching.js.org/?locale=en_US\n","description":"","id":21,"section":"posts","tags":["git"],"title":"git回退上一个版本","uri":"https://yslinwe.github.io/posts/github/git%E5%9B%9E%E9%80%80%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"content":"创建repo repo名称为\u0026lt;username\u0026gt;.github.io  设置github actions自动部署 将博客源码放到一个private repo 或者 public repo 中，\n创建一个blogSite分支。\nblogSite分支，用于存放博客源码\nmaster分支，用于存放博客网页代码\n需要获取一个personal_token或者deploy_key来获取repo的权限，这里选择personal_token的方式，这种方式更简单，后者可以自行了解。\n生成一个personal_token 点击GitHub头像在下拉栏里进入Setting-Developer -\u0026gt; Setting-Personal access\n选择 Generate new token\n在上方填入名字ACTION_ACCESS_TOKEN，并勾选repo里的所有选项，还有admin:repo_hook\n点击 Generate token 生成 token，\n并先复制保存该token（记得保存后面要用到）\n然后执行以下几步：\n1.在源码repo里新建一个blogSite分支：git checkout -b blogSite 2.在repo根目录新建嵌套的两个文件夹.github/workflows 3.在workflows里新建一个后缀为.yml的配置文件，名字自取。 4.写进去以下配置（从hugo官方文档修改而来）：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  name:github pages# 名字自取on:push:branches:- blogSite # 这个是博客源码分支jobs:deploy:# 任务名自取runs-on:ubuntu-18.04\t# 在什么环境运行任务steps:- uses:actions/checkout@v2\t# 引用actions/checkout这个action，与所在的github仓库同名with:submodules:true# Fetch Hugo themes (true OR recursive) 获取submodule主题fetch-depth:0# Fetch all history for .GitInfo and .Lastmod- name:Setup Hugo\t# 步骤名自取uses:peaceiris/actions-hugo@v2\t# hugo官方提供的action，用于在任务环境中获取hugowith:hugo-version:\u0026#39;latest\u0026#39;# 获取最新版本的hugo# extended: true- name:Buildrun:hugo --minify\t# 使用hugo构建静态网页- name:Deployuses:peaceiris/actions-gh-pages@v3\t# 一个自动发布github pages的actionwith:# github_token: ${{ secrets.GITHUB_TOKEN }} 该项适用于发布到源码相同repo的情况，不能用于发布到其他repoexternal_repository:username/username.github.io\t# username 是你的仓库repo的名称，也是你的用户名personal_token:${{ secrets.ACTION_ACCESS_TOKEN }}\t# 发布到其他repo需要提供上面生成的personal access tokenpublish_dir:./public\t# 注意这里指的是要发布哪个文件夹的内容，而不是指发布到目的仓库的什么位置，因为hugo默认生成静态网页到public文件夹，所以这里发布public文件夹里的内容publish_branch:master\t# 发布到哪个branch   记得修改 external_repository中的username  接下来在源码repo中添加上面的personal access token： 进入repo的Settings-Secrets一栏，选择New repository secret\n在下面填入刚才生成的token，名字注意需要与上面yml文件里XXX相同\npersonal_token: ${{ secrets.XXX }}\n这里的名称是ACTION_ACCESS_TOKEN\n添加token之后，进入github actions里点击刚才失败的任务，点击右上角Re-run jobs\n这时应该能够成功运行该任务，这说明自动部署已经开始在工作了，以后往blogSite分支push新文章时github actions会自动生成静态博客并发布到master中。\n","description":"","id":22,"section":"posts","tags":["Github Action","Hugo"],"title":"Hugo使用Github Action自动部署博客到Github Pages","uri":"https://yslinwe.github.io/posts/github/hugo%E4%BD%BF%E7%94%A8github-action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0github-pages/"},{"content":"配置后的效果如下: 1. 安装Unity 2.下载安装.Net Core SDK https://dotnet.microsoft.com/download/dotnet\n运行命令检查安装是否成功\n1  dotnet --version   3.下载安装Mono SDK https://www.mono-project.com/download/stable/\n运行命令检查安装是否成功\n1  mono --version   4. 安装VsCode 4.1 安装VsCode插件 1 2 3 4 5 6 7  C# C# Extensions C# FixFormat Fixed Debugger for Unity Unity Tools Unity Code Snippets Unity Snippets   4.2 VsCode 配置omnisharp路径 设置路径\nCode -\u0026gt; Preferences -\u0026gt; Settings, 检索mono, 点击settings.json 配置omnisharp(很重要) 1 2  \u0026#34;omnisharp.monoPath\u0026#34;: \u0026#34;/Library/Frameworks/Mono.framework/Versions/Current/Commands/mono\u0026#34;, \u0026#34;omnisharp.useGlobalMono\u0026#34;: \u0026#34;always\u0026#34;   设置.zshrc/.bash_profile环境变量(很重要) 1  export FrameworkPathOverride=/Library/Frameworks/Mono.framework/Versions/Current   5.设置Unity代码编辑器 ","description":"","id":23,"section":"posts","tags":["VSCode Unity环境搭建"],"title":"Mac VSCode开发Unity环境搭建","uri":"https://yslinwe.github.io/posts/mac/mac-vscode%E5%BC%80%E5%8F%91unity%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"content":"获取宝塔面板的登陆链接和用户名、密码 /etc/init.d/bt default ","description":"","id":24,"section":"posts","tags":["宝塔面板","服务器"],"title":"宝塔面板命令行","uri":"https://yslinwe.github.io/posts/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/"},{"content":"Part1 安装oh-my-zsh  第一步 clone oh-my-zsh项目  1  git clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh    第二步 复制 .zshrc  1  cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc    第三步 更改你的默认 Shell  1  chsh -s /bin/zsh    第四步 新打开终端  compaudit | xargs chmod g-w,o-w 修改后终端变为这样\nps:这里选择了steeef主题，不是默认的robbyrussell主题\n终端的命令提示符 Part2 主题配置  修改.zshrc  cd ~ vim ~/.zshrc  更改主题\n  将 ZSH_THEME=\u0026ldquo;robbyrussell\u0026rdquo; 改成 ZSH_THEME=\u0026ldquo;steeef\u0026rdquo;\n 应用到.zshrc  source ~/.zshrc P.S. 这些主题都保存在 \u0026ldquo;~/.oh-my-zsh/themes\u0026rdquo; 目录中\n插件\noh-my-zsh 的自带插件都储存在 \u0026ldquo;~/.oh-my-zsh/plugins\u0026rdquo; 目录中,\n在 ~/.zshrc 中的 plugins 加入插件名称，这样设置就完成了。\n   安装 zsh-syntax-highlighting   对于oh-my-zsh\n git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 在 ~/.zshrc 中加入插件的名字\nplugins=(zsh-syntax-highlighting)\n，最后source生效\nsource ~/.zshrc  对于osx\n可以直接\n brew install zsh-syntax-highlighting 并且source生效\nsource /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh Ps 新打开终端才会显示。\n","description":"","id":25,"section":"posts","tags":["Mac"],"title":"Mac终端美化","uri":"https://yslinwe.github.io/posts/mac/mac%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96/"},{"content":"一级标题 二级标题 一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 Markdown 段落 Runoob.com\nGoogle.com\n字体 斜体字体\n粗体\n斜粗体\n分割线 删除线 baidu.com 双波浪线是英文字符\n下划线 带下划线\n脚注 格式 [^要注明的文本]\n创建脚注格式类似这样1\nMarkdown 列表 无序  第一 第二 第三   第一 第二 第三   第一 第二 第三  有序  第一 第二 第三  列表嵌套  第一项  第一项嵌套的第一个元素 第一项嵌套的第二个元素   第二项  第二项嵌套的第一个元素 第二项嵌套的第二个元素    Markdown 区块  区块引用\n菜鸟教程\n学的不仅是技术更是梦想\n 区块嵌套  最外层\n 第一层嵌套\n 第二层嵌套\n   区块中列表   第一项 第二项   第一项 第二项 第三项   列表中使用区块  第一项  菜鸟教程\n学的不仅是技术更是梦想\n  第二项  Markdown 代码 printf() 函数\n\u0026lt;?php echo 'RUNOOB'; function test(){ echo 'test' }  可以指定一种语言或者不指定\n1 2 3  $(document).ready(function()){ alert(\u0026#39;RUNOOB\u0026#39;); });   1  print(\u0026#34;hello world\u0026#34;)   Markdown 链接 格式 链接名称\n这个是一个链接 菜鸟教程\n直接使用链接\nhttps://runoob.com\n高级链接 这个链接用 1 作为网址变量 Google\n这个链接用 runoob 作为网址变量 Runoob\n注意至少空一行\nMarkdown 图片 格式 使用实例：\n图片地址引用：\n这个链接用 1 作为网址变量RUNOOB\n指定图片的高度 宽度\nMarkdown 表格 Markdown 制作表格使用 | 来分隔不同的单元格 使用 - 来分隔表头和其它行\n   表头 表头     单元格 单元格   单元格 单元格    对齐方式：\n -: 设置右对齐 :- 设置左对齐 :-: 设置居中对齐     左对齐 右对齐 居中对齐     单元格 单元格 单元格   单元格 单元格 单元格    Markdown 高级技巧 支持的HTML元素\n目前支持的HTML元素有： \u0026lt;kbd\u0026gt; \u0026lt;b\u0026gt; \u0026lt;i\u0026gt; \u0026lt;em\u0026gt; \u0026lt;sup\u0026gt; \u0026lt;sub\u0026gt; \u0026lt;br\u0026gt; 等\n使用Ctrl+Alt+Del 重启电脑\n  斜体\n斜体\n图片上移动\n图片下移动\n\u0026lt;br\u0026gt;我换行了\n \n我换行了\n加反斜杆转义特殊字符  ** 正常显示星号 **\n Markdown 支持以下符号加上反斜杠变成普通字符\n \\反斜线\n` 反引号\n* 星号\n_ 下划线\n{} 花括号\n[] 方括号\n() 小括号\n# 井字号\n+ 加号\n- 减号\n. 英文句号\n! 感叹号\n 1. 横向流程图源码格式：\ngraph LR A[方形] --\u0026gt;B(圆角) B --\u0026gt; C{条件a} C --\u0026gt;|a=1| D[结果1] C --\u0026gt;|a=2| E[结果2] F[横向流程图] 2. 竖向流程图源码格式：\ngraph TD A[方形] --\u0026gt; B(圆角) B --\u0026gt; C{条件a} C --\u0026gt; |a=1| D[结果1] C --\u0026gt; |a=2| E[结果2] F[竖向流程图] 3. 标准流程图源码格式：\nst=\u0026gt;start: 开始框 op=\u0026gt;operation: 处理框 cond=\u0026gt;condition: 判断框(是或否?) sub1=\u0026gt;subroutine: 子流程 io=\u0026gt;inputoutput: 输入输出框 e=\u0026gt;end: 结束框 st-\u0026gt;op-\u0026gt;cond cond(yes)-\u0026gt;io-\u0026gt;e cond(no)-\u0026gt;sub1(right)-\u0026gt;op 4. 标准流程图源码格式（横向）：\nst=\u0026gt;start: 开始框 op=\u0026gt;operation: 处理框 cond=\u0026gt;condition: 判断框(是或否?) sub1=\u0026gt;subroutine: 子流程 io=\u0026gt;inputoutput: 输入输出框 e=\u0026gt;end: 结束框 st(right)-\u0026gt;op(right)-\u0026gt;cond cond(yes)-\u0026gt;io(bottom)-\u0026gt;e cond(no)-\u0026gt;sub1(right)-\u0026gt;op 5. UML时序图源码样例：\n对象A-\u0026gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--\u0026gt;对象A: 我很好(响应) 对象A-\u0026gt;对象B: 你真的好吗？ 6. UML时序图源码复杂样例：\nTitle: 标题：复杂使用 对象A-\u0026gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--\u0026gt;对象A: 我很好(响应) 对象B-\u0026gt;小三: 你好吗 小三--\u0026gt;\u0026gt;对象A: 对象B找我了 对象A-\u0026gt;对象B: 你真的好吗？ Note over 小三,对象B: 我们是朋友 participant C Note right of C: 没人陪我玩 7. UML标准时序图样例：\n%% 时序图例子,-\u0026gt; 直线，--\u0026gt;虚线，-\u0026gt;\u0026gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-\u0026gt;王五: 王五你好吗？ loop 健康检查 王五-\u0026gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 \u0026lt;br/\u0026gt;看医生... 李四--\u0026gt;\u0026gt;张三: 很好! 王五-\u0026gt;李四: 你怎么样? 李四--\u0026gt;王五: 很好!  菜鸟教程 \u0026ndash; 早点歇息\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","description":"","id":26,"section":"posts","tags":["markdown"],"title":"Markdown显示","uri":"https://yslinwe.github.io/posts/markdown/markdown%E6%98%BE%E7%A4%BA/"},{"content":"Markdown语法整理   目录\n  一.分级目录\n  二.斜体与粗体\n  三.超链接\n 3.1.行内式 3.2.参考式 3.3.自动连接    四.锚点\n 4.1.页内超链接 4.2.文章内部标题链接    五.列表\n 5.1.无需列表 5.2.有序列表 5.3.定义型列表 5.4.列表缩进 5.5.包含段落的列表 5.6.任务列表    六.表格\n 6.1.竖杠|下划线-写法 6.2.html写法    七.创建和突出显示代码块\n 7.1.栅栏代码块 7.2.语法高亮显示 7.3.引用代码 7.4.引用文字 7.5.删除线    使用LaTeX方法\n 说明：本文中中语法里面的代码就是需要写的Markdown语法，展示效果就是最后生成的页面\n此语法编写和测试环境：windows上使用MarkdownPad2的GitHub离线风格的Markdown语法，使用在线风格好像不支持文章内部链接跳转\n     一.分级目录 语法： * 总目录 * 一级目录 * 二级目录 * 三级目录 说明：层级列表一般只支持三级列表，第一级实心圆点，第二级空心圆点，第三级以后都是实心方点。要实现层级列表，每下一级都要比上一级多输入2个空格或者一个Tab，而且第一级前面不要超过3个空格.\n展示效果：  总目录  一级目录  二级目录  三级目录        二.斜体与粗体 语法： *斜体* **粗体** 展示效果： 斜体\n粗体\n三.超链接 Markdown支持两种形式的链接语法：行内式和参考式，行内式一般用的比较多。 3.1.行内式： 语法：  [打开百度](http://www.baidu.com) [打开百度](http://www.baidu.com \u0026quot;打开百度\u0026quot;) 说明:[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。[链接文字](链接地址 “链接标题”)这样的形式。链接地址与链接标题前有一个空格。\n展示效果: 打开百度\n打开百度\n3.2.参考式: 参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。\n语法:  我经常浏览的几个网站[Google][1]、[Baidu][2]、[51CTO][3]和看视频的网站[爱奇艺][4]感觉都是很不错的[网站][]. [1]:http://www.google.com \u0026quot;google\u0026quot; [2]:http://www.baidu.com \u0026quot;Baidu\u0026quot; [3]:http://www.51cto.com \u0026quot;51cto\u0026quot; [4]:http://www.aiqiyi.com \u0026quot;aiqiyi\u0026quot; [网站]:http://www.qq.com 展示效果： 我经常浏览的几个网站Google、Baidu、51CTO和看视频的网站爱奇艺感觉都是很不错的网站.\n3.3.自动连接： 语法：  \u0026lt;http://www.baidu.com/\u0026gt; \u0026lt;admin@baidu.com\u0026gt; 说明：Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用\u0026lt;\u0026gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样。\n展示效果： http://www.baidu.com/\nadmin@baidu.com\n四.锚点 网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。\n注意：Markdown Extra 只支持在标题后插入锚点，其它地方无效\n4.1.页内超链接: 语法： # 1.分级目录{#index} 跳转到[标题]{#index}  说明：在你准备跳转到的指定标题后插入锚点{#标记}，然后在文档的其它地方写上连接到锚点的链接。此处使用的是GitHub风格的Markdown语法所以无法正常显示效果，推荐使用以下4.2.文章内部标题链接。\n 展示效果： 1.分级目录 跳转到1.分级目录\n 说明：这里是在本文的分级目录设置的，不然效果不明显\n 4.2.文章内部标题链接： 语法： * [目录1](#40) * [标题1](#41) * [标题2](#42) * [标题3](#43) * [标题4](#44) \u0026lt;h3 id=\u0026quot;41\u0026quot;\u0026gt;标题1\u0026lt;/h3\u0026gt; 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 \u0026lt;h3 id=\u0026quot;42\u0026quot;\u0026gt;标题2\u0026lt;/h3\u0026gt; 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 \u0026lt;h3 id=\u0026quot;43\u0026quot;\u0026gt;标题3\u0026lt;/h3\u0026gt; 我轻轻的招手， 作别西天的云彩。 \u0026lt;h3 id=\u0026quot;44\u0026quot;\u0026gt;标题4\u0026lt;/h3\u0026gt; 作别西天的云彩。 展示效果：  目录1  标题1 标题2 标题3 标题4    标题1 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。\n标题2 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。\n标题3 我轻轻的招手， 作别西天的云彩。\n标题4 作别西天的云彩。\n五.列表 5.1.无需列表:  使用 *，+，- 表示无序列表\n 语法：  - 无序列表一 + 无序列表二 * 无序列表三 展现效果：   无序列表一\n  无序列表二\n  无序列表三\n  5.2.有序列表：  有序列表则使用数字接着一个英文句点\n 语法：  1.有序列表一 2.有序列表二 3.有序列表三 展现效果：  有序列表一 有序列表二 有序列表三  5.3.定义型列表: 语法：  名词1 : 定义 1（左侧有一个可见的冒号和四个不可见的空格） 代码块 2 : 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格）  说明：\n定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab)\n 展现效果：  名词1 定义 1（左侧有一个可见的冒号和四个不可见的空格） 代码块 2 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）   代码块（左侧有八个不可见的空格） 5.4.列表缩进： 语法：  * 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ * 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。  说明：列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。\n 效果：  轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。\n那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。\n软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。\n但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！\n悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。  5.5.包含段落的列表: 语法：  * 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ * 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。  说明：\n列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符（显示效果与代码一致）：如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许\n 效果：   轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。\n那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。\n软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！\n那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。\n寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。\n但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！\n  悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。\n  5.6.任务列表:  要创建任务列表，前缀列表项[ ]。要将任务标记为完整，请使用[x]\n 语法：  - [] 跑步 - [] 骑车 - [x] 吃饭 - [] 睡觉 展现效果：  跑步 骑车 吃饭 睡觉  六.表格 6.1.竖杠|下划线-写法:  使用竖杠|下划线-写法\n 语法：  |名字|性别|年龄|国籍| |---|----|----|---| |张三|男|23|中国| |小红|女|18|中国| |Tom|男|46|美国| 展现效果：    名字 性别 年龄 国籍     张三 男 23 中国   小红 女 18 中国   Tom 男 46 美国    6.2.html写法:  使用\u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt;\n 语法：  \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;车次\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;开车时间\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;到达时间\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;D110\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;10:22\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;11:00\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 展现效果：    车次 开车时间 到达时间     D110 10:22 11:00     这里是因为使用github离线风格导致空格，使用在线就没有了\n 七.创建和突出显示代码块 7.1.栅栏代码块: 语法： function test() {\nconsole.log（“在此函数之前注意空白行?\u0026quot;);\n}\n展现效果：  function test() { console.log(\u0026quot;在此函数之前注意空白行?\u0026quot;); } 7.2.语法高亮显示:  高亮度需要使用github在线风格才能显示颜色\n 语法： ```ruby require 'redcarpet' markdown = Redcarpet.new(\u0026quot;Hello World!\u0026quot;) puts markdown.to_html ​``` 展现效果：  ruby语法：\n ​```ruby\nrequire \u0026lsquo;redcarpet\u0026rsquo;\nmarkdown = Redcarpet.new(\u0026ldquo;Hello World!\u0026quot;)\nputs markdown.to_html\n \u0026gt; python语法： ```python def foo(): if not bar: return True  本文使用的markdownPad2需要使用github在线markdown风格才会显示，其他不显示。\n 7.3.引用代码:  您可以使用单个反引号来调用句子中的代码或命令。反引号内的文本将不被格式化。\n 语法：  Use `git status` to list all new or modified files that haven't yet been committed. 展现效果: Use git status to list all new or modified files that haven\u0026rsquo;t yet been committed.\n7.4.引用文字:  你可以用引用文本\u0026gt;.\n 语法： In the words of Abraham Lincoln: \u0026gt; Pardon my French 展现效果: In the words of Abraham Lincoln:\n Pardon my French\n 7.5.删除线: 语法： ~~This was mistaken text~~ 展现效果: This was mistaken text\n使用LaTeX方法 使用LaTeX方法：  下面还有些没有显示出效果，先扔着把，毕竟才开始玩，先这样吧\nMathJax是一款相当强悍的在网页显示数学公式的插件。本教程介绍MathJax如何使用LaTeX语法编写数学公式。\n 如何插入公式 L aTeX的数学公式有两种：行中公式和独立公式。行中公式放在文中与其它文字混编，独立公式单独成行。\n行中公式可以用如下两种方法表示：\n1  ＼(数学公式＼)　或　￥数学公式￥（要把人民币符号换成美元符号）   独立公式可以用如下两种方法表示：\n1  ＼[数学公式＼]　或　￥￥数学公式￥￥（要把人民币符号换成美元符号）   例子：\n1  $$ ＼[J\\alpha(x) = \\sum{m=0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha}＼] $$   显示：\n$$ \\J*\\alpha(x) = \\sum*{m=0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha}\\ ] $$\n如何输入上下标 ^表示上标,_表示下标。如果上下标的内容多于一个字符，要用{}把这些内容括起来当成一个整体。上下标是可以嵌套的，也可以同时使用。\n例子：\n1  $$ x^{y^z}=(1+{\\rm e}^x)^{-2xy^w} $$   显示：\n$$ x^{y^z}=(1+{\\rm e}^x)^{-2xy^w} $$\n另外，如果要在左右两边都有上下标，可以用\\sideset命令。\n例子：\n1  \\sideset{^12}{^34}\\bigotimes   显示：\n$$ \\sideset{^12}{^34}\\bigotimes $$\n如何输入括号和分隔符 ()、[]和|表示自己，{}表示{}。当要显示大号的括号或分隔符时，要用\\left和\\right命令。\n例子：\n1  $$ f(x,y,z) = 3y^2z \\left( 3+\\frac{7x+5}{1+y^2} \\right) $$   显示：\n$$ f(x,y,z) = 3y^2z \\left( 3+\\frac{7x+5}{1+y^2} \\right) $$\n有时候要用\\left.或\\right.进行匹配而不显示本身。\n例子：\n1  $$ \\left. \\frac{{\\rm d}u}{{\\rm d}x} \\right| _{x=0} $$   显示：\n$$ \\left. \\frac{{\\rm d}u}{{\\rm d}x} \\right| _{x=0} $$\n如何输入分数 例子：\n1  $$ \\frac{1}{3}　或　1 \\over 3 $$   显示：\n$$ \\frac{1}{3} 或 1 \\over 3 $$\n如何输入开方 语法：\n1  $$ \\sqrt{2}　和　\\sqrt[n]{3} $$   显示：\n$$ \\sqrt{2} 和　\\sqrt[n]{3} $$\n如何输入省略号 数学公式中常见的省略号有两种，\\ldots表示与文本底线对齐的省略号，\\cdots表示与文本中线对齐的省略号。\n语法：\n1  f(x1,x2,\\ldots,xn) = x1^2 + x2^2 + \\cdots + xn^2   显示：\n$$ f(x1,x2,\\ldots,xn) = x1^2 + x2^2 + \\cdots + xn^2 $$\n如何输入矢量 语法：\n1  \\vec{a} \\cdot \\vec{b}=0   显示：\n$$ \\vec{a} \\cdot \\vec{b}=0 $$\n如何输入积分 语法：\n1  \\int_0^1 x^2 {\\rm d}x   显示：\n$$ \\int_0^1 x^2 {\\rm d}x $$\n如何输入极限运算 语法：\n1  \\lim_{n \\rightarrow +\\infty} \\frac{1}{n(n+1)}   显示：\n$$ \\lim_{n \\rightarrow +\\infty} \\frac{1}{n(n+1)} $$\n如何输入累加、累乘运算 语法：\n1  \\sum{i=0}^n \\frac{1}{i^2}　和　\\prod{i=0}^n \\frac{1}{i^2}   显示：\n\\sum*{i=0}^n \\frac{1}{i^2} 和　\\prod*{i=0}^n \\frac{1}{i^2}\n如何进行公式应用 先要在［mathjax］后添加：\n1 2 3 4  \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; ＜script type=\u0026#34;text/x-mathjax-config\u0026#34;＞ MathJax.Hub.Config({ TeX: {equationNumbers: { autoNumber: [\u0026#34;AMS\u0026#34;], useLabelIds: true}}, \u0026#34;HTML-CSS\u0026#34;: {linebreaks: {automatic: true}}, SVG: {linebreaks: {automatic: true}} }); ＜/script＞    只要按照这个添加代码就能实现本页的效果，包的下载自己找吧，就这样,想在线就得这样\n 语法：\n1  ＼begin{equation}\\label{equation1}r = rF+ \\beta(rM – r_F) + \\epsilon＼end{equation}   显示：\n\\begin{equation}\\label{equation1}r = rF+ \\beta(rM – r_F) + \\epsilon\\end{equation}\n 引用：请见公式( \\ref{equation1} )\n 如何输入希腊字母  哎，这里的空白这蛋疼，目前还没有最终得解决发子\n    语法 显示效果     $$ \\alpha $$ $$ \\alpha $$   $$ \\beta $$ $$ \\beta $$   $$\\gamma $$ $$\\gamma $$   $$ \\Gamma $$ $$ \\Gamma $$   $$ \\delta $$ $$ \\delta $$   $$ \\Delta $$ $$ \\Delta $$   $$ \\epsilon $$ $$ \\epsilon $$   $$ \\varepsilon $$ $$ \\varepsilon $$   $$ \\zeta $$ $$ \\zeta $$   $$ \\eta $$ $$ \\eta $$   $$ \\theta $$ $$ \\theta $$   $$ \\Theta $$ $$ \\Theta $$   $$ \\vartheta $$ $$ \\vartheta $$   $$ \\iota $$ $$ \\iota $$   $$ \\kappa $$ $$ \\kappa $$   $$ \\lambda$$ $$ \\lambda$$   $$ \\Lambda $ $$ \\Lambda $$   $$ \\mu $$ $$ \\mu $$   $$ \\nu $$ $$ \\nu $$   $$ \\Xi $$ $$ \\Xi $$   $$ \\pi $$ $$ \\pi $$   $$ \\Pi $$ $$ \\Pi $$   $$ \\varpi $$ $$ \\varpi $$   $$ \\rho $$ $$ \\rho $$   $$\\varrho $$ $$\\varrho $$   $$ \\sigma $$ $$ \\sigma $$   $$ \\Sigma $$ $$ \\Sigma $$   $$ \\varsigma $$ $$ \\varsigma $$   $$ \\tau $$ $$ \\tau $$   $$ \\upsilon $$ $$ \\upsilon $$   $$ \\Upsilon $$ $$ \\Upsilon $$   $$ \\xi $$ $$ \\xi $$   $$ \\Phi $$ $$ \\Phi $$   $$ \\varphi $$ $$ \\varphi $$   $$ \\chi $$ $$ \\chi $$   $$ \\psi $$ $$ \\psi $$   $$ \\Psi $$ $$ \\Psi $$   $$ \\omega $$ $$ \\omega $$   $$ \\Omega $$ $$ \\Omega $$    如何输入其它特殊字符 关系运算符：\n   语法 显示效果     $$ \\pm $$ $$ \\pm $$   $$ \\times $$ $$ \\times $$   $$ \\div $$ $$ \\div $$   $$ \\mid $$ $$ \\mid $$   $$ \\nmid $$ $$ \\nmid $$   $$ \\cdot $$ $$ \\cdot $$   $$ \\circ $$ $$ \\circ $$   $$ \\ast $$ $$ \\ast $$   $$ \\bigodot $$ $$ \\bigodot $$   $$ \\bigotimes $$ $$ \\bigotimes$$   $$ \\bigoplus $$ $$ \\bigoplus $$   $$ \\leq $$ $$ \\leq $$   $$ \\geq $$ $$ \\geq $$   $$ \\neq $$ $$ \\neq $$   $$ \\approx $$ $$ \\approx $$   $$ \\equiv $$ $$ \\equiv $$   $$ \\sum $$ $$ \\sum $$   $$ \\prod $$ $$ \\prod $$   $$ \\coprod $$ $$ \\coprod $$    集合运算符：    语法 显示效果     $$ \\emptyset $$ $$ \\emptyset $$   $$ \\in $$ $$ \\in $$   $$ \\notin $$ $$ \\notin $$   $$ \\subset $$ $$ \\subset $$   $$ \\supset $$ $$ \\supset $$   $$ \\subseteq $$ $$ \\subseteq $$   $$ \\supseteq $$ $$ \\supseteq $$   $$ \\bigcap $$ $$ \\bigcap $$   $$ \\bigcup $$ $$ \\bigcup $$   $$ \\bigvee $$ $$ \\bigvee $$   $$ \\bigwedge $$ $$ \\bigwedge $$   $$ \\biguplus $$ $$ \\biguplus $$   $$ \\bigsqcup $$ $$ \\bigsqcup $$    对数运算符：    语法 显示效果     $$ \\log $$ $$ \\log $$   $$ \\lg $$ $$ \\lg $$   $$ \\ln $$ $$ \\ln $$    三角运算符：    语法 显示效果     $$ \\bot $$ $$ \\bot $$   $$ \\angle $$ $$ \\angle $$   $$ 30^\\circ $$ $$ 30^\\circ $$   $$ \\sin $$ $$ \\sin $$   $$ \\cos $$ $$ \\cos $$   $$ \\tan $$ $$ \\tan $$   $$ \\cot $$ $$ \\cot $$   $$ \\sec $$ $$ \\sec $$   $$ \\csc $$ $$ \\csc $$    微积分运算符：    语法 显示效果     $$ \\prime $$ $$ \\prime $$   $$ \\int $$ $$ \\int $$   $$ \\iint $$ $$ \\iint $$   $$ \\iiint $$ $$ \\iiint $$   $$ \\iiiint $$ $$ \\iiiint $$   $$ \\oint $$ $$ \\oint $$   $$ \\lim $$ $$ \\lim $$   $$ \\infty $$ $$ \\infty $$   $$ \\nabla $$ $$ \\nabla $$    逻辑运算符：    语法 显示效果     $$ \\because $$ $$ \\because $$   $$ \\therefore $$ $$ \\therefore $$   $$ \\forall $$ $$ \\forall $$   $$ \\exists $$ $$ \\exists $$   $$ \\not= $$ $$ \\not= $$   $$ \\not\u0026gt; $$ $$ \\not\u0026gt; $$   $$ \\not\\subset $$ $$ \\not\\subset $$    戴帽符号：    语法 显示效果     $$ \\hat{y} $$ $$ \\hat{y} $$   $$ \\check{y} $$ $$ \\check{y} $$   $$ \\breve{y} $$ $$ \\breve{y} $$    连线符号：    语法 显示效果     $$ \\overline{a+b+c+d} $$ $$ \\overline{a+b+c+d} $$   $$ \\underline{a+b+c+d} $$ $$ \\underline{a+b+c+d} $$   $$ \\overbrace{a+\\underbrace{b+c}\u0026lt;em\u0026gt;{1.0}+d}^{2.0} $$ $$ \\overbrace{a+\\underbrace{b+c}{1.0}+d}^{2.0} $$    箭头符号：  哎，这里的空白这蛋疼，目前还没有最终得解决发子\n    语法 显示效果     $$ \\uparrow $$ $$ \\uparrow $$   $$ \\downarrow $$ $$ \\downarrow $$   $$ \\Uparrow $$ $$ \\Uparrow $$   $$ \\Downarrow $$ $$ \\Downarrow $$   $$ \\rightarrow $$ $$ \\rightarrow $$   $$ \\leftarrow $$ $$ \\leftarrow $$   $$ \\Rightarrow $$ $$ \\Rightarrow $$   $$ \\Leftarrow $$ $$ \\Leftarrow $$   $$ \\longrightarrow $$ $$ \\longrightarrow $$   $$ \\longleftarrow $$ $$ \\longleftarrow $$   $$ \\Longrightarrow $$ $$ \\Longrightarrow $$   $$ \\Longleftarrow $$ $$ \\Longleftarrow $$    要输出字符  哎，这里的空白这蛋疼，目前还没有最终得解决发子\n 　　　　　   语法 显示效果     \\空格 a\\ b   \\# #   \\$ $   \\% %   \\\u0026amp; \u0026amp;   _ _   {　} { }     这里的空格没有搞定，显示没有按预期的效果来，#下面的，在MarkdownPad2中默认是不需要转换，所以加\\没效果\n 如何进行字体转换 要对公式的某一部分字符进行字体转换，可以用$$ {\\rm 需转换的部分字符 } $$命令，其中\\rm可以参照下表选择合适的字体。\n一般情况下，公式默认为意大利体。\n　　　　   语法 字体名称 显示效果     $$ {\\rm 需转换的部分字符} $$ 罗马体 $$ {\\rm ABCD} $$   $$ {\\it 需转换的部分字符} $$ 意大利体 $$ {\\it ABCD} $$   $$ {\\Bbbr 需转换的部分字符} $$ 黑板粗体字 $$ {\\Bbb ABCD} $$   $$ {\\bf 需转换的部分字符} $$ 黑体 $$ {\\bf　ABCD} $$   $$ {\\cal 需转换的部分字符} $$ 花体 $$ {\\cal　ABCD} $$   $$ {\\sl 需转换的部分字符} $$ 倾斜体 $$ {\\sl ABCD} $$   $$ {\\sf 需转换的部分字符} $$ 等线体 $$ {\\sf　ABCD} $$   $$ {\\mit 需转换的部分字符} $$ 数学斜体 $$ {\\mit　ABCD} $$   $$ {\\tt 需转换的部分字符} $$ 打字机字体 $$ {\\tt ABCD} $$   $$ {\\scr 需转换的部分字符} $$ 小体大写字母 $$ {\\scr ABCD} $$   $$ {\\frakr 需转换的部分字符} $$ Fraktur字母（一种德国字体） $$ {\\frak ABCD} $$     先到这里把，这个字体转换还没有彻底的明白，其中有几个还没有成功，对于MarkdownPad2支持Latex确实有点蛋疼，实时预览看不到，需要F6 html预览才行，另外还得额外加载相关js代码\n跳转至首页\n ","description":"","id":27,"section":"posts","tags":["markdown"],"title":"Markdown语法整理","uri":"https://yslinwe.github.io/posts/markdown/markdown%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86/"},{"content":"一级标题 ======= 二级标题 ------- # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 ## Markdown 段落 Runoob.com Google.com ### 字体 *斜体字体* **粗体** ***斜粗体*** ### 分割线 *** ******* ### 删除线 ~~baidu.com~~ `双波浪线是英文字符` ### 下划线 \u0026lt;u\u0026gt;带下划线\u0026lt;/u\u0026gt; ### 脚注 格式 [^要注明的文本] 创建脚注格式类似这样[^RunooB] [^RunooB]: 菜鸟教程 -- 早点歇息 ## Markdown 列表 ##### 无序 * 第一 * 第二 * 第三 + 第一 + 第二 + 第三 - 第一 - 第二 - 第三 ##### 有序 1. 第一 2. 第二 3. 第三 ##### 列表嵌套 1. 第一项 * 第一项嵌套的第一个元素 * 第一项嵌套的第二个元素 2. 第二项 * 第二项嵌套的第一个元素 * 第二项嵌套的第二个元素 ## Markdown 区块 \u0026gt; 区块引用 \u0026gt; 菜鸟教程 \u0026gt; 学的不仅是技术更是梦想 ##### 区块嵌套 \u0026gt; 最外层 \u0026gt; \u0026gt; 第一层嵌套 \u0026gt; \u0026gt; \u0026gt; 第二层嵌套 ##### 区块中列表 \u0026gt; 1. 第一项 \u0026gt; 2. 第二项 \u0026gt; * 第一项 \u0026gt; * 第二项 \u0026gt; * 第三项 ##### 列表中使用区块 * 第一项 \u0026gt; 菜鸟教程 \u0026gt; 学的不仅是技术更是梦想 * 第二项 ## Markdown 代码 `printf()` 函数 \u0026lt;?php echo 'RUNOOB'; function test(){ echo 'test' } 可以指定一种语言或者不指定 ```javascript $(document).ready(function()){ alert('RUNOOB'); }); ```python print(\u0026quot;hello world\u0026quot;) ## Markdown 链接 ##### 格式 [链接名称](链接地址) 这个是一个链接 [菜鸟教程](https://runoob.com) 直接使用链接 \u0026lt;https://runoob.com\u0026gt; ##### 高级链接 这个链接用 1 作为网址变量 [Google][1] 这个链接用 runoob 作为网址变量 [Runoob][runoob] 注意至少空一行 [runoob]:http://www.runoob.com [1]:http://www.google.com/ ## Markdown 图片 ##### 格式 ![alt 属性文本](图片地址) ![alt 属性文本](图片地址 \u0026quot;可选标题\u0026quot;) 使用实例： ![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png) ![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png \u0026quot;RUNOOB\u0026quot;) ![](./image/1.jpeg) \u0026lt;img src=\u0026quot;./image/1.jpeg\u0026quot; width=\u0026quot;20%\u0026quot;\u0026gt; \u0026lt;img src=\u0026quot;./image/1.jpeg\u0026quot; height=\u0026quot;10%\u0026quot;\u0026gt; 图片地址引用： 这个链接用 1 作为网址变量[RUNOOB][2] [2]:http://static.runoob.com/images/runoob-logo.png **指定图片的高度 宽度** \u0026lt;img src=\u0026quot;http://static.runoob.com/images/runoob-logo.png\u0026quot; width=\u0026quot;20%\u0026quot;\u0026gt; \u0026lt;img src=\u0026quot;http://static.runoob.com/images/runoob-logo.png\u0026quot; height=\u0026quot;20%\u0026quot;\u0026gt; ## Markdown 表格 Markdown 制作表格使用 | 来分隔不同的单元格 使用 - 来分隔表头和其它行 |表头|表头| |-|-| |单元格|单元格| |单元格|单元格| 对齐方式： * -: 设置右对齐 * :- 设置左对齐 * :-: 设置居中对齐 |左对齐|右对齐|居中对齐| |:-|-:|:-:| |单元格|单元格|单元格| |单元格|单元格|单元格| ## Markdown 高级技巧 支持的**HTML**元素 目前支持的HTML元素有： `\u0026lt;kbd\u0026gt; \u0026lt;b\u0026gt; \u0026lt;i\u0026gt; \u0026lt;em\u0026gt; \u0026lt;sup\u0026gt; \u0026lt;sub\u0026gt; \u0026lt;br\u0026gt;` 等 使用\u0026lt;kbd\u0026gt;Ctrl\u0026lt;/kbd\u0026gt;+\u0026lt;kbd\u0026gt;Alt\u0026lt;/kbd\u0026gt;+\u0026lt;kbd\u0026gt;Del\u0026lt;/kbd\u0026gt; 重启电脑 \u0026gt;\u0026lt;i\u0026gt; 斜体\u0026lt;/i\u0026gt; \u0026lt;em\u0026gt;斜体\u0026lt;/em\u0026gt; 图片\u0026lt;sup\u0026gt;上移动\u0026lt;/sup\u0026gt; 图片\u0026lt;sub\u0026gt;下移动\u0026lt;/sub\u0026gt; `\u0026lt;br\u0026gt;我换行了` \u0026lt;br\u0026gt;我换行了 ##### **加反斜杆转义特殊字符** \u0026gt;\\*\\* 正常显示星号 \\*\\* **Markdown 支持以下符号加上反斜杠变成普通字符** \u0026gt;\\\\反斜线 \\` 反引号 \u0026gt;\\* 星号 \u0026gt;\\_ 下划线 \u0026gt;\\{} 花括号 \u0026gt;\\[] 方括号 \u0026gt;\\() 小括号 \u0026gt;\\# 井字号 \u0026gt;\\+ 加号 \u0026gt;\\- 减号 \u0026gt;\\. 英文句号 \u0026gt;\\! 感叹号 **1. 横向流程图源码格式：** ```mermaid graph LR A[方形] --\u0026gt;B(圆角) B --\u0026gt; C{条件a} C --\u0026gt;|a=1| D[结果1] C --\u0026gt;|a=2| E[结果2] F[横向流程图] **2. 竖向流程图源码格式：** ```mermaid graph TD A[方形] --\u0026gt; B(圆角) B --\u0026gt; C{条件a} C --\u0026gt; |a=1| D[结果1] C --\u0026gt; |a=2| E[结果2] F[竖向流程图] **3. 标准流程图源码格式：** ```flow st=\u0026gt;start: 开始框 op=\u0026gt;operation: 处理框 cond=\u0026gt;condition: 判断框(是或否?) sub1=\u0026gt;subroutine: 子流程 io=\u0026gt;inputoutput: 输入输出框 e=\u0026gt;end: 结束框 st-\u0026gt;op-\u0026gt;cond cond(yes)-\u0026gt;io-\u0026gt;e cond(no)-\u0026gt;sub1(right)-\u0026gt;op **4. 标准流程图源码格式（横向）：** ```flow st=\u0026gt;start: 开始框 op=\u0026gt;operation: 处理框 cond=\u0026gt;condition: 判断框(是或否?) sub1=\u0026gt;subroutine: 子流程 io=\u0026gt;inputoutput: 输入输出框 e=\u0026gt;end: 结束框 st(right)-\u0026gt;op(right)-\u0026gt;cond cond(yes)-\u0026gt;io(bottom)-\u0026gt;e cond(no)-\u0026gt;sub1(right)-\u0026gt;op **5. UML时序图源码样例：** ```sequence 对象A-\u0026gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--\u0026gt;对象A: 我很好(响应) 对象A-\u0026gt;对象B: 你真的好吗？ **6. UML时序图源码复杂样例：** ```sequence Title: 标题：复杂使用 对象A-\u0026gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--\u0026gt;对象A: 我很好(响应) 对象B-\u0026gt;小三: 你好吗 小三--\u0026gt;\u0026gt;对象A: 对象B找我了 对象A-\u0026gt;对象B: 你真的好吗？ Note over 小三,对象B: 我们是朋友 participant C Note right of C: 没人陪我玩 **7. UML标准时序图样例：** ```mermaid %% 时序图例子,-\u0026gt; 直线，--\u0026gt;虚线，-\u0026gt;\u0026gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-\u0026gt;王五: 王五你好吗？ loop 健康检查 王五-\u0026gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 \u0026lt;br/\u0026gt;看医生... 李四--\u0026gt;\u0026gt;张三: 很好! 王五-\u0026gt;李四: 你怎么样? 李四--\u0026gt;王五: 很好! ","description":"","id":28,"section":"posts","tags":["markdown"],"title":"MarkdownLearn","uri":"https://yslinwe.github.io/posts/markdown/markdownlearn/"},{"content":"牛客网IO练习 https://ac.nowcoder.com/acm/contest/5657#question\n计算a+b (1) 题目描述 打开以下链接可以查看正确的代码\n https://ac.nowcoder.com/acm/contest/5657#question\n 输入描述:  输入包括两个正整数a,b(1 \u0026lt;= a, b \u0026lt;= 10^9),输入数据包括多组。\n 输出描述:  输出a+b的结果\n 示例1 输入  1 5\n10 20\n 输出  6\n30\n 1 2 3 4 5 6 7 8 9  #include\u0026lt;iostream\u0026gt;using namespace std; int main(){ int a, b; while(cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b) cout\u0026lt;\u0026lt;a+b\u0026lt;\u0026lt;endl; return 0; }   计算a+b (2) 题目描述 计算a+b\n打开以下链接可以查看正确的代码\n https://ac.nowcoder.com/acm/contest/5657#question\n 输入描述:  输入第一行包括一个数据组数t(1 \u0026lt;= t \u0026lt;= 100)\n接下来每行包括两个正整数a,b(1 \u0026lt;= a, b \u0026lt;= 10^9)\n 输出描述:  输出a+b的结果\n 示例1 输入  2\n1 5\n10 20\n 输出  6\n30\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include\u0026lt;iostream\u0026gt;using namespace std; int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--){ int a, b; while(cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b) cout\u0026lt;\u0026lt;a+b\u0026lt;\u0026lt;endl; } return 0; }   计算a+b (3) 题目描述 计算a+b\n打开以下链接可以查看正确的代码\n https://ac.nowcoder.com/acm/contest/5657#question\n 输入描述:  输入包括两个正整数a,b(1 \u0026lt;= a, b \u0026lt;= 10^9),输入数据有多组, 如果输入为0 0则结束输入\n 输出描述:  输出a+b的结果\n 示例1 输入  1 5\n10 20\n0 0\n 输出  6\n30\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include\u0026lt;iostream\u0026gt;using namespace std; int main(){ int a, b; while(cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b){ if(a==0\u0026amp;\u0026amp;b==0) break; cout\u0026lt;\u0026lt;a+b\u0026lt;\u0026lt;endl; } return 0; }   计算a+b (4) 题目描述 计算一系列数的和\n打开以下链接可以查看正确的代码\n https://ac.nowcoder.com/acm/contest/5657#question\n 输入描述:  输入数据包括多组。\n每组数据一行,每行的第一个整数为整数的个数n(1 \u0026lt;= n \u0026lt;= 100), n为0的时候结束输入。\n接下来n个正整数,即需要求和的每个正整数。\n 输出描述:  每组数据输出求和的结果\n 示例1 输入  4 1 2 3 4\n5 1 2 3 4 5\n0\n 输出  10\n15\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include\u0026lt;iostream\u0026gt;using namespace std; int main(){ int n; while(cin\u0026gt;\u0026gt;n){ if(n==0) break; int sum = 0,temp; while(n--){ cin\u0026gt;\u0026gt;temp; sum += temp; } cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } return 0; }   计算a+b (5) 题目描述 计算一系列数的和\n打开以下链接可以查看正确的代码\n https://ac.nowcoder.com/acm/contest/5657#question\n 输入描述:  输入的第一行包括一个正整数t(1 \u0026lt;= t \u0026lt;= 100), 表示数据组数。\n接下来t行, 每行一组数据。\n每行的第一个整数为整数的个数n(1 \u0026lt;= n \u0026lt;= 100)。\n接下来n个正整数, 即需要求和的每个正整数。\n 输出描述: 每组数据输出求和的结果\n示例1 输入  2\n4 1 2 3 4\n5 1 2 3 4 5\n 输出  10\n15\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include\u0026lt;iostream\u0026gt;using namespace std; int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--){ int n; cin\u0026gt;\u0026gt;n; int sum = 0,temp; while(n--){ cin\u0026gt;\u0026gt;temp; sum += temp; } cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } return 0; }   计算a+b (6) 题目描述 计算一系列数的和\n打开以下链接可以查看正确的代码\n https://ac.nowcoder.com/acm/contest/5657#question\n 输入描述:  输入数据有多组, 每行表示一组输入数据。\n每行的第一个整数为整数的个数n(1 \u0026lt;= n \u0026lt;= 100)。\n接下来n个正整数, 即需要求和的每个正整数。\n 输出描述:  每组数据输出求和的结果\n 示例1 输入  4 1 2 3 4\n5 1 2 3 4 5\n 输出  10\n15\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include\u0026lt;iostream\u0026gt;using namespace std; int main(){ int t; while(cin\u0026gt;\u0026gt;t){ int sum = 0; while(t--){ int temp; cin\u0026gt;\u0026gt;temp; sum += temp; } cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } return 0; }   计算a+b (7) 题目描述 计算一系列数的和\n打开以下链接可以查看正确的代码\n https://ac.nowcoder.com/acm/contest/5657#question\n 输入描述:  输入数据有多组, 每行表示一组输入数据。\n每行不定有n个整数，空格隔开。(1 \u0026lt;= n \u0026lt;= 100)。\n 输出描述:  每组数据输出求和的结果\n 示例1 输入  1 2 3\n4 5\n0 0 0 0 0\n 输出  6\n9\n0\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #include\u0026lt;iostream\u0026gt;using namespace std; int main(){ int temp,sum = 0; while(cin\u0026gt;\u0026gt;temp){ sum += temp; if(cin.get()==\u0026#39;\\n\u0026#39;){ cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; sum = 0; } } return 0; }   字符串排序（1） 题目描述 对输入的字符串进行排序后输出\n打开以下链接可以查看正确的代码\n https://ac.nowcoder.com/acm/contest/5657#question\n 输入描述:  输入有两行，第一行n\n第二行是n个空格隔开的字符串\n 输出描述:  输出一行排序后的字符串，空格隔开，无结尾空格\n 示例1 输入  5\nc d a bb e\n 输出  a bb c d e\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; int main() { int n; string *pstr; vector\u0026lt;string\u0026gt; que; cin \u0026gt;\u0026gt; n; pstr = new string[n]; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; pstr[i]; que.push_back(pstr[i]); } sort(que.begin(), que.end()); for (int i = 0; i \u0026lt; n; i++) { cout \u0026lt;\u0026lt; que[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }   字符串排序 （2） 题目描述 对输入的字符串进行排序后输出\n打开以下链接可以查看正确的代码\n https://ac.nowcoder.com/acm/contest/5657#question\n 输入描述:  多个测试用例，每个测试用例一行。\n每行通过空格隔开，有n个字符，n＜100\n 输出描述:  对于每组测试用例，输出一行排序过的字符串，每个字符串通过空格隔开\n 示例1 输入  a c bb\nf dddd\nnowcoder\n 输出  a bb c\ndddd f\nnowcoder\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  #include\u0026lt;iostream\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;algorithm\u0026gt;using namespace std; int main() { string str; vector\u0026lt;string\u0026gt; s; while(cin\u0026gt;\u0026gt;str) { s.push_back(str); if(cin.get()==\u0026#39;\\n\u0026#39;) { sort(s.begin(), s.end()); int n = s.size(); for(int i = 0;i\u0026lt;n;i++) { cout\u0026lt;\u0026lt;s[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } s.clear(); cout\u0026lt;\u0026lt;endl; } } }   字符串排序 （3） 题目描述 对输入的字符串进行排序后输出\n打开以下链接可以查看正确的代码\n https://ac.nowcoder.com/acm/contest/5657#question\n 输入描述:  多个测试用例，每个测试用例一行。\n每行通过,隔开，有n个字符，n＜100\n 输出描述:  对于每组用例输出一行排序后的字符串，用',\u0026lsquo;隔开，无结尾空格\n 示例1 输入  a,c,bb\nf,dddd\nnowcoder\n 输出  a,bb,c\ndddd,f\nnowcoder\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  #include\u0026lt;iostream\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;sstream\u0026gt; using namespace std; int main() { string line; string str; vector\u0026lt;string\u0026gt; s; while(cin\u0026gt;\u0026gt;line) { stringstream ss(line); while(getline(ss, str, \u0026#39;,\u0026#39;)) { s.push_back(str); } sort(s.begin(),s.end()); if(s.size()==1) cout\u0026lt;\u0026lt;s[0]; else for(int i = 0;i\u0026lt;s.size();i++) { if(i!=s.size()-1) cout\u0026lt;\u0026lt;s[i]\u0026lt;\u0026lt;\u0026#39;,\u0026#39;; else cout\u0026lt;\u0026lt;s[i]; } s.clear(); cout\u0026lt;\u0026lt;endl; } }   ","description":"","id":29,"section":"posts","tags":["牛客网"],"title":"C++IO牛客网","uri":"https://yslinwe.github.io/posts/c++io%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0/"},{"content":"Mac启动台App问号 1 2  defaults write com.apple.dock ResetLaunchPad -bool TRUE killall Dock   ","description":"","id":30,"section":"posts","tags":["Mac"],"title":"Mac启动台App问号","uri":"https://yslinwe.github.io/posts/mac/mac%E5%90%AF%E5%8A%A8%E5%8F%B0app%E9%97%AE%E5%8F%B7/"},{"content":"方法一：   第一步：打开「终端」应用程序。\n  第二步：输入如下命令：\n  1  defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder   第三步：按下「Return」键确认。  现在你将会在 Finder 窗口中看到那些隐藏的文件和文件夹了。\n如果你想再次隐藏原本的隐藏文件和文件夹的话，将上述命令替换成\n1  defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder   即可。\n方法二： Finder界面是，最上方，通过“前往”进入“电脑”或文件夹，\n先进入到需要显示隐藏文件的文件夹下\n接着按Command苹果键+F,在窗格上会显示搜索栏\n然后将第一个下列选择项“种类kind”选择为“其它Other”，当选择“其它”时，\n弹出新的搜索窗口，找到下面的“文件不可见File invisible”项，\n勾上后面的对勾，再单击“好OK”即可，返回文件夹，就可以看到，\n隐藏的文件已经显示出来了\n","description":"","id":31,"section":"posts","tags":["Mac"],"title":"Mac上显示和隐藏文件","uri":"https://yslinwe.github.io/posts/mac/mac%E4%B8%8A%E6%98%BE%E7%A4%BA%E5%92%8C%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/"},{"content":"题目描述 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。\n输入描述: 输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 示例1 输入 \u0026quot;ab\u0026quot; 返回值 [\u0026quot;ab\u0026quot;,\u0026quot;ba\u0026quot;] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: void PermutationCore(string str,int begin) { if(str.length()== begin) { result.push_back(str); return; } for(int i=begin;i\u0026lt;str.length();i++) { if(i!=begin\u0026amp;\u0026amp;str[i]==str[begin]) continue; swap(str[begin], str[i]); PermutationCore(str,begin+1); } } vector\u0026lt;string\u0026gt; Permutation(string str) { if(str.length()==0) return result; PermutationCore(str,0); return result; } private: vector\u0026lt;string\u0026gt; result; };   ","description":"剑指office（二十七）字符串的排列","id":32,"section":"posts","tags":["剑指office"],"title":"剑指office（二十七）字符串的排列","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/27%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"},{"content":"题目描述 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。你可以假设数组是非空的，并且给定的数组总是存在多数元素。1\u0026lt;=数组长度\u0026lt;=50000\n示例1 输入 [1,2,3,2,2,2,5,4,2] 返回值 2 方法一: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class Solution { public: int MoreThanHalfNum_Solution(vector\u0026lt;int\u0026gt; numbers) { if(numbers.empty()) return 0; int time = 0; int result = 0; for(int i=0;i\u0026lt;numbers.size();i++) { if(time==0) { result = numbers[i]; time = 1; } else if(numbers[i]==result) time++; else time--; } time = 0; for(int i = 0;i\u0026lt;numbers.size();i++) if(numbers[i]==result) time++; return time\u0026gt;numbers.size()\u0026gt;\u0026gt;1?result:0; } };   方法二: 1 2 3 4 5 6 7 8 9 10 11  class Solution { public: int MoreThanHalfNum_Solution(vector\u0026lt;int\u0026gt; numbers) { map\u0026lt;int, int\u0026gt; mp; for(const int val:numbers) mp[val]++; for(const auto \u0026amp;val:mp) if(val.second \u0026gt; (numbers.size()\u0026gt;\u0026gt;1)) return val.first; } };   ","description":"剑指office（二十八）数组中出现次数超过一半的数字","id":33,"section":"posts","tags":["剑指office"],"title":"剑指office（二十八）数组中出现次数超过一半的数字","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/28%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"},{"content":"题目描述 给定一个数组，找出其中最小的K个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。如果K\u0026gt;数组的长度，那么返回一个空的数组\n示例1 输入 [4,5,1,6,2,7,3,8],4 返回值 [1,2,3,4] 方法一: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  class Solution { public: vector\u0026lt;int\u0026gt; GetLeastNumbers_Solution(vector\u0026lt;int\u0026gt; input, int k) { vector\u0026lt;int\u0026gt; result; if(input.empty()||k\u0026gt;input.size()) return result; ListNode *node = new ListNode(input[0]); node-\u0026gt;next = NULL; ListNode *lastNode = NULL; ListNode *head = node; //插入排除  for(int i=1;i\u0026lt;input.size();i++) { while(node) { ListNode *newNode = new ListNode(input[i]); if(input[i]\u0026gt;node-\u0026gt;val) { lastNode = node; node = node-\u0026gt;next; if(node==NULL) { //表尾处理  newNode-\u0026gt;next = lastNode-\u0026gt;next; lastNode-\u0026gt;next = newNode; } } else { if(lastNode) { //中间处理  newNode-\u0026gt;next = lastNode-\u0026gt;next; lastNode-\u0026gt;next = newNode; }else { //表头处理  newNode-\u0026gt;next = node; node = newNode; head = node; } break; } } node = head; lastNode = NULL; } for(int i= 0;i\u0026lt;k;i++) { result.push_back(node-\u0026gt;val); node = node-\u0026gt;next; } return result; } };   方法二: class Solution { public: vector\u0026lt;int\u0026gt; GetLeastNumbers_Solution(vector\u0026lt;int\u0026gt; input, int k) { vector\u0026lt;int\u0026gt; result; if(input.empty()||k\u0026gt;input.size()) return result; sort(input.begin(),input.end()); result.insert(result.begin(),input.begin(), input.begin()+k); return result; } }; ","description":"剑指office（二十八）数组中出现次数超过一半的数字","id":34,"section":"posts","tags":["剑指office"],"title":"剑指office（二十八）数组中出现次数超过一半的数字","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/29%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"},{"content":"题目描述 输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n).\n示例1 输入 [1,-2,3,10,-4,7,2,-5] 返回值 18 方法一: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution { public: int FindGreatestSumOfSubArray(vector\u0026lt;int\u0026gt; array) { if(array.empty()) return 0; int maxsum = array[0]; int sum = 0; for(int i=0;i\u0026lt;array.size();i++) { if(sum\u0026lt;0) { sum = array[i]; }else { sum += array[i]; } if(sum\u0026gt;maxsum) maxsum = sum; } return maxsum; } };   方法二: class Solution { public: int FindGreatestSumOfSubArray(vector\u0026lt;int\u0026gt; array) { if(array.empty()) return 0; int sum = array[0]; int lastSum = 0; int ret = sum; for(int i=0;i\u0026lt;array.size();i++) { sum = max(array[i],lastSum+array[i]); lastSum = sum; ret = max(sum,ret); } return ret; } }; ","description":"剑指office（二十八）数组中出现次数超过一半的数字","id":35,"section":"posts","tags":["剑指office"],"title":"剑指office（二十八）数组中出现次数超过一半的数字","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/30%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"},{"content":"题目描述 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: void ConvertNode(TreeNode* crruentNode,TreeNode* \u0026amp;lastNode) { if(crruentNode==NULL) return; ConvertNode(crruentNode-\u0026gt;left,lastNode); crruentNode-\u0026gt;left = lastNode; if(lastNode!=NULL) lastNode-\u0026gt;right = crruentNode; lastNode = crruentNode; ConvertNode(crruentNode-\u0026gt;right,lastNode); } TreeNode* Convert(TreeNode* pRootOfTree) { TreeNode *lastNode = NULL; if(pRootOfTree==NULL) return pRootOfTree; ConvertNode(pRootOfTree,lastNode); while(pRootOfTree-\u0026gt;left!=NULL) { pRootOfTree = pRootOfTree-\u0026gt;left; } return pRootOfTree; } };   ","description":"剑指office（二十六）二叉树搜索树与双向链表","id":36,"section":"posts","tags":["剑指office"],"title":"剑指office（二十六）二叉树搜索树与双向链表","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/26%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"},{"content":"题目描述 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  /* struct RandomListNode { int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) { } }; */ class Solution { public: void Copy(RandomListNode* pHead) { RandomListNode* temp; while(pHead!=NULL) { temp = pHead-\u0026gt;next; RandomListNode* pNode = new RandomListNode(pHead-\u0026gt;label); pNode-\u0026gt;next = temp; pNode-\u0026gt;random = NULL; pHead-\u0026gt;next = pNode; pHead = temp; } } void AddRandom(RandomListNode* pHead) { while (pHead!=NULL) { if(pHead-\u0026gt;random!=NULL) { pHead-\u0026gt;next-\u0026gt;random = pHead-\u0026gt;random-\u0026gt;next; } if(pHead-\u0026gt;next!=NULL) pHead = pHead-\u0026gt;next-\u0026gt;next; } } RandomListNode* Detch(RandomListNode* pHead) { RandomListNode* pNode = pHead; RandomListNode* pCloneHead = NULL; RandomListNode* pClone = NULL; if(pNode != NULL){ pCloneHead = pNode-\u0026gt;next; pClone = pCloneHead; pNode-\u0026gt;next = pCloneHead-\u0026gt;next; pNode = pNode-\u0026gt;next; } while (pNode!=NULL) { pClone-\u0026gt;next = pNode-\u0026gt;next; pClone = pClone-\u0026gt;next; pNode-\u0026gt;next = pClone-\u0026gt;next; pNode = pNode-\u0026gt;next; } return pCloneHead; } RandomListNode* Clone(RandomListNode* pHead) { Copy(pHead); AddRandom(pHead); return Detch(pHead); } };   ","description":"剑指office（二十五）复杂链表的复制","id":37,"section":"posts","tags":["剑指office"],"title":"剑指office（二十五）复杂链表的复制","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/25%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"},{"content":"题目描述 输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。\n示例1 输入 {10,5,12,4,7},22 返回值 [[10,5,7],[10,12]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; FindPath(TreeNode* root,int expectNumber) { if(root==NULL) { return result; } temp.push_back(root-\u0026gt;val); if((expectNumber-root-\u0026gt;val)==0\u0026amp;\u0026amp;root-\u0026gt;left==NULL\u0026amp;\u0026amp;root-\u0026gt;right==NULL)//叶结点  result.push_back(temp); if(expectNumber-root-\u0026gt;val\u0026lt;0) temp.pop_back(); FindPath(root-\u0026gt;left, expectNumber-root-\u0026gt;val); FindPath(root-\u0026gt;right, expectNumber-root-\u0026gt;val); if(temp.size()\u0026gt;1) temp.pop_back();//栈回退  return result; } private: vector\u0026lt;int\u0026gt; temp; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; };   ","description":"剑指office（二十四）二叉树中和为某一值的路径","id":38,"section":"posts","tags":["剑指office"],"title":"剑指office（二十四）二叉树中和为某一值的路径","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/24%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"},{"content":"题目描述 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。（ps：我们约定空树不是二叉搜素树）\n示例1 输入 [4,8,6,12,16,14,10] 返回值 true 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  class Solution { public: bool VerifySquenceOfBST(vector\u0026lt;int\u0026gt; sequence) { if(sequence.empty()) return false; int end = *(sequence.end()-1); bool result = true; vector\u0026lt;int\u0026gt; left; vector\u0026lt;int\u0026gt; right; vector\u0026lt;int\u0026gt;::iterator iter = sequence.begin(); for(;iter!=sequence.end()-1;iter++) if(end\u0026lt;*iter) break; vector\u0026lt;int\u0026gt;::iterator splitP = iter; for(;iter!=sequence.end()-1;iter++) if(end\u0026gt;*iter) return false; vector\u0026lt;int\u0026gt;::iterator bei = sequence.begin(); left.insert(left.end(),sequence.begin(),splitP); right.insert(right.end(),splitP,sequence.end()-1); bool leftFlag = (left.size()\u0026gt;1)?VerifySquenceOfBST(left):result; bool rightFlag = (right.size()\u0026gt;1)?VerifySquenceOfBST(right):result; return leftFlag\u0026amp;\u0026amp;rightFlag; } };   ","description":"剑指office（二十三）二叉树搜索树的后序遍历序列","id":39,"section":"posts","tags":["剑指office"],"title":"剑指office（二十三）二叉树搜索树的后序遍历序列","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/23%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"},{"content":"题目描述 从上往下打印出二叉树的每个节点，同层节点从左至右打印。\n示例1 输入 {5,4,#,3,#,2,#,1} 返回值 [5,4,3,2,1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: vector\u0026lt;int\u0026gt; PrintFromTopToBottom(TreeNode* root) { vector\u0026lt;int\u0026gt; result; if(root==NULL) return result; result.push_back(root-\u0026gt;val); PrintLeftToRight(result,root); return result; } void PrintLeftToRight(vector\u0026lt;int\u0026gt;\u0026amp;result,TreeNode* root) { if(root==NULL||root-\u0026gt;left==NULL\u0026amp;\u0026amp;root-\u0026gt;right==NULL) return; if(root-\u0026gt;left) result.push_back(root-\u0026gt;left-\u0026gt;val); if(root-\u0026gt;right) result.push_back(root-\u0026gt;right-\u0026gt;val); PrintLeftToRight(result,root-\u0026gt;left); PrintLeftToRight(result,root-\u0026gt;right); } };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: vector\u0026lt;int\u0026gt; PrintFromTopToBottom(TreeNode* root) { vector\u0026lt;int\u0026gt; result; if(root==NULL) return result; queue\u0026lt;TreeNode*\u0026gt; nodeQ; nodeQ.push(root); while(!nodeQ.empty()) { TreeNode* cur = nodeQ.front(); nodeQ.pop(); result.push_back(cur-\u0026gt;val); if(cur-\u0026gt;left)nodeQ.push(cur-\u0026gt;left); if(cur-\u0026gt;right)nodeQ.push(cur-\u0026gt;right); } return result; } };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: vector\u0026lt;int\u0026gt; PrintFromTopToBottom(TreeNode* root) { vector\u0026lt;int\u0026gt; result; if(root==NULL) return result; queue\u0026lt;TreeNode*\u0026gt; nodeQ; nodeQ.push(root); int level = 0; while(!nodeQ.empty()) { int qS = nodeQ.size(); while(qS--) { TreeNode* cur = nodeQ.front(); nodeQ.pop(); result.push_back(cur-\u0026gt;val); if(cur-\u0026gt;left)nodeQ.push(cur-\u0026gt;left); if(cur-\u0026gt;right)nodeQ.push(cur-\u0026gt;right); } level++; } return result; } };   ","description":"剑指office（二十二）从上往下打印二叉树","id":40,"section":"posts","tags":["剑指office"],"title":"剑指office（二十二）从上往下打印二叉树","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/22%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"content":"题目描述 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）\n示例1 输入 [1,2,3,4,5],[4,3,5,1,2] 返回值 false 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  class Solution { public: bool IsPopOrder(vector\u0026lt;int\u0026gt; pushV,vector\u0026lt;int\u0026gt; popV) { bool result = false; stack\u0026lt;int\u0026gt; leftS; stack\u0026lt;int\u0026gt; rightS; int pushVSize = pushV.size(); int popVSize = popV.size(); int j = 0; bool isLeft = true; for(int i = 0;i\u0026lt;pushVSize;i++) { if(pushV[i] == popV[j]) { j++; isLeft = !isLeft; }else { if(isLeft) leftS.push(pushV[i]); else rightS.push(pushV[i]); } } if(j\u0026gt;=popVSize) return true; int left = 0; int right = 0; while(j\u0026lt;popVSize) { left = leftS.empty()?NULL:leftS.top(); right = rightS.empty()?NULL:rightS.top(); if(popV[j]==left) { leftS.pop(); result = true; } else if(popV[j]==right) { rightS.pop(); result = true; } else { result = false; break; } j++; } return result; } };   ","description":"剑指office（二十一）栈的压入、弹出序列","id":41,"section":"posts","tags":["剑指office"],"title":"剑指office（二十一）栈的压入、弹出序列","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/21%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"},{"content":"题目描述 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class Solution { public: stack\u0026lt;int\u0026gt; v; stack\u0026lt;int\u0026gt; minV; void push(int value) { v.push(value); if(minV.empty()) minV.push(value); if(minV.top()\u0026gt;value) { minV.push(value); } } void pop() { if(v.top()==minV.top()) minV.pop(); v.pop(); } int top() { return v.top(); } int min() { return minV.top(); } };   ","description":"剑指office（二十）包含min函数的栈","id":42,"section":"posts","tags":["剑指office"],"title":"剑指office（二十）包含min函数的栈","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/20%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"},{"content":"题目描述 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.\n示例1 输入 [[1,2],[3,4]] 返回值 [1,2,4,3] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  class Solution { public: vector\u0026lt;int\u0026gt; printMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; matrix) { vector\u0026lt;int\u0026gt; result; int cols = matrix[0].size(); int rows = matrix.size()-1; int startCol = 0; int startRow = 0; if(rows \u0026lt; 0 \u0026amp;\u0026amp; cols == 0) return result; if(cols==1) { for(int i= 0;i\u0026lt;=rows;i++) result.push_back(matrix[i][0]); return result; } if(rows==0) { for(int i= 0;i\u0026lt;cols;i++) result.push_back(matrix[0][i]); return result; } while(cols-startCol\u0026gt;0\u0026amp;\u0026amp;rows-startRow\u0026gt;=0) { for(int i = startCol;i\u0026lt;cols;i++) { result.push_back(matrix[startRow][i]); } for(int i = startRow+1;i\u0026lt;rows;i++) { result.push_back(matrix[i][cols-1]); } if(rows-startRow\u0026gt;0) for(int i = cols-1;i\u0026gt;=startCol;i--) { result.push_back(matrix[rows][i]); } if(cols-startCol\u0026gt;1) for(int i = rows-1;i\u0026gt;startRow;i--) { result.push_back(matrix[i][startCol]); } startCol++; startRow++; cols = cols-1; rows = rows-1; } return result; } };   ","description":"剑指office（十九）顺时针打印矩阵","id":43,"section":"posts","tags":["剑指office"],"title":"剑指office（十九）顺时针打印矩阵","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/19%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"},{"content":"题目描述 操作给定的二叉树，将其变换为源二叉树的镜像。\n比如： 源二叉树 8 / \\ 6 10 / \\ / \\ 5 7 9 11 镜像二叉树 8 / \\ 10 6 / \\ / \\ 11 9 7 5 示例1 输入 {8,6,10,5,7,9,11} 返回值 {8,10,6,11,9,7,5} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  /** * struct TreeNode { *\tint val; *\tstruct TreeNode *left; *\tstruct TreeNode *right; *\tTreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * }; */ class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param pRoot TreeNode类 * @return TreeNode类 */ TreeNode* Mirror(TreeNode* pRoot) { // write code here  if(pRoot==NULL||(pRoot-\u0026gt;left==NULL\u0026amp;\u0026amp;pRoot-\u0026gt;right==NULL)) return pRoot; swapNode(pRoot); Mirror(pRoot-\u0026gt;left); Mirror(pRoot-\u0026gt;right); return pRoot; } void swapNode(TreeNode* pRoot) { TreeNode* tempVal = pRoot-\u0026gt;left; pRoot-\u0026gt;left = pRoot-\u0026gt;right; pRoot-\u0026gt;right = tempVal; } };   ","description":"剑指office（十八）二叉树的镜像","id":44,"section":"posts","tags":["剑指office"],"title":"剑指office（十八）二叉树的镜像","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/18%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"},{"content":"题目描述 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）\n示例1 输入 {8,8,#,9,#,2,#,5},{8,9,#,2} 返回值 true 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) { bool result = false; if(pRoot1!=NULL\u0026amp;\u0026amp;pRoot2!=NULL) { if(pRoot1-\u0026gt;val==pRoot2-\u0026gt;val) result = isSame(pRoot1,pRoot2); if(!result) result = HasSubtree(pRoot1-\u0026gt;left, pRoot2); if(!result) result = HasSubtree(pRoot1-\u0026gt;right, pRoot2); } return result; } bool isSame(TreeNode* pRoot1,TreeNode* pRoot2) { if(pRoot2==NULL) return true; if(pRoot1==NULL) return false; if(pRoot1-\u0026gt;val!=pRoot2-\u0026gt;val) return false; else return isSame(pRoot1-\u0026gt;left, pRoot2-\u0026gt;left)\u0026amp;\u0026amp;isSame(pRoot1-\u0026gt;right, pRoot2-\u0026gt;right); } };   ","description":"剑指office（十七）树的子结构","id":45,"section":"posts","tags":["剑指office"],"title":"剑指office（十七）树的子结构","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/17%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"},{"content":"题目描述 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。\n示例1 输入 {1,3,5},{2,4,6} 返回值 {1,2,3,4,5,6} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) { ListNode* result = NULL; ListNode* cur = NULL; if(!pHead1) return pHead2; if(!pHead2) return pHead1; while(pHead1||pHead2) { if(pHead1\u0026amp;\u0026amp;pHead2) { if(pHead1-\u0026gt;val\u0026gt;=pHead2-\u0026gt;val) { ListNode* temp = pHead2-\u0026gt;next; if(!result) { result = pHead2; cur = result; } else { result-\u0026gt;next = pHead2; result = result-\u0026gt;next; } pHead2 = temp; } else { ListNode* temp = pHead1-\u0026gt;next; if(!result) { result = pHead1; cur = result; } else { result-\u0026gt;next = pHead1; result = result-\u0026gt;next; } pHead1 = temp; } } else { if(pHead1) { result-\u0026gt;next = pHead1; } else { result-\u0026gt;next = pHead2; } break; } } return cur; } };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) { ListNode* result = new ListNode(-1); ListNode* cur = result; if(!pHead1) return pHead2; if(!pHead2) return pHead1; while(pHead1||pHead2) { if(pHead1\u0026amp;\u0026amp;pHead2) { if(pHead1-\u0026gt;val\u0026gt;=pHead2-\u0026gt;val) { result-\u0026gt;next = pHead2; pHead2 = pHead2-\u0026gt;next; } else { result-\u0026gt;next = pHead1; pHead1 = pHead1-\u0026gt;next; } result = result-\u0026gt;next; } else { result-\u0026gt;next = pHead1?pHead1:pHead2; break; } } return cur-\u0026gt;next; } };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) { if(!pHead1) return pHead2; if(!pHead2) return pHead1; if(pHead1-\u0026gt;val\u0026gt;=pHead2-\u0026gt;val) { pHead2-\u0026gt;next = Merge(pHead1,pHead2-\u0026gt;next); return pHead2; }else { pHead1-\u0026gt;next = Merge(pHead1-\u0026gt;next, pHead2); return pHead1; } } };   ","description":"剑指office（十六）合并两个排序的链表","id":46,"section":"posts","tags":["剑指office"],"title":"剑指office（十六）合并两个排序的链表","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/16%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"},{"content":"题目描述 输入一个链表，反转链表后，输出新链表的表头。\n示例1 输入 {1,2,3} 返回值 {3,2,1} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* ReverseList(ListNode* pHead) { if (!pHead) return NULL; stack\u0026lt;ListNode*\u0026gt; stackNode; while(pHead) { stackNode.push(pHead); pHead = pHead-\u0026gt;next; } ListNode* result = stackNode.top(); stackNode.pop(); ListNode* cur = result; int S = stackNode.size(); for(int i = 0;i\u0026lt;S;i++) { cur-\u0026gt;next = stackNode.top(); stackNode.pop(); cur = cur-\u0026gt;next; } cur-\u0026gt;next = NULL; return result; } };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* ReverseList(ListNode* pHead) { ListNode* nextNode = NULL; ListNode* currentNode = pHead; ListNode* reverseNode = NULL; while(currentNode) { nextNode = currentNode-\u0026gt;next; currentNode-\u0026gt;next = reverseNode; reverseNode = currentNode; currentNode = nextNode; } return reverseNode; } };   ","description":"剑指office（十五）反转链表","id":47,"section":"posts","tags":["剑指office"],"title":"剑指office（十五）反转链表","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/15%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"content":"题目描述 输入一个链表，输出该链表中倒数第k个结点。\n如果该链表长度小于k，请返回空。\n示例1 输入 {1,2,3,4,5},1 返回值 {5} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  /** * struct ListNode { *\tint val; *\tstruct ListNode *next; *\tListNode(int x) : val(x), next(nullptr) {} * }; */ class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param pHead ListNode类 * @param k int整型 * @return ListNode类 */ ListNode* FindKthToTail(ListNode* pHead, int k) { // write code here  ListNode *result = pHead; while(pHead\u0026amp;\u0026amp;k--) { pHead = pHead-\u0026gt;next; } if(k\u0026gt;0) return NULL; while(pHead) { pHead = pHead-\u0026gt;next; result = result-\u0026gt;next; } return result; } };   ","description":"剑指office（十四）链表中倒数第k个结点","id":48,"section":"posts","tags":["剑指office"],"title":"剑指office（十四）链表中倒数第k个结点","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/14%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/"},{"content":"题目描述 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。\n示例1 输入 [1,2,3,4] 返回值 [1,3,2,4] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param array int整型vector * @return int整型vector */ vector\u0026lt;int\u0026gt; reOrderArray(vector\u0026lt;int\u0026gt;\u0026amp; array) { // write code here  for(int i=0;i\u0026lt;array.size();i++) { if(array[i]\u0026amp;1) { int j = i; if(j\u0026gt;0) while(!(array[j-1]\u0026amp;1)) { swap(array[j],array[j-1]); j--; if(j==0) break; } } } return array; } };   ","description":"剑指office（十三）调整数组顺序使奇数位于偶数前面","id":49,"section":"posts","tags":["剑指office"],"title":"剑指office（十三）调整数组顺序使奇数位于偶数前面","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/13%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"},{"content":"题目描述 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。\n保证base和exponent不同时为0。不得使用库函数，同时不需要考虑大数问题，也不用考虑小数点后面0的位数。\n示例1 输入 2.00000,3 返回值 8.00000 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public: double Power(double base, int exponent) { if(exponent == 0) return 1.0; else { double result = 1; for(int i= 0;i\u0026lt;abs(exponent);i++) result *= base; if(exponent \u0026gt; 0) return result; else return 1/result; } } };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Solution { public: double Power(double base,int exponent) { if(exponent\u0026lt;0) { exponent = -exponent; base = 1/base; } return q_power(base,exponent); } double q_power(double base, int exponent) { if(exponent == 0) return 1.0; else { double result = q_power(base, exponent/2); if(exponent\u0026amp;1) { return result*result*base; } else { return result * result; } } } };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class Solution { public: double Power(double base,int exponent) { if(exponent\u0026lt;0) { exponent = -exponent; base = 1/base; } return q_power(base,exponent); } double q_power(double base,int exponent) { double result = 1; while(exponent) { if(exponent\u0026amp;1) { result *= base; } base *= base; exponent\u0026gt;\u0026gt;=1; } return result; } };   ","description":"剑指office（十二）数值的整数次方","id":50,"section":"posts","tags":["剑指office"],"title":"剑指office（十二）数值的整数次方","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/12%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"},{"content":"题目描述 输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。\n示例1 输入 10 返回值 2 1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution { public: int NumberOf1(int n) { int cout = 0; int mark = 0x01; while(mark) { if(mark\u0026amp;n)cout++; mark\u0026lt;\u0026lt;=1; } return cout; } };   1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public: int NumberOf1(int n) { int count = 0; while(n) { count++; n = (n-1)\u0026amp;n; } return count; } };   ","description":"剑指office（十一）二进制中1的个数","id":51,"section":"posts","tags":["剑指office"],"title":"剑指office（十一）二进制中1的个数","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/11%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"content":"题目描述 我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？\n比如n=3时，2*3的矩形块有3种覆盖方法：\n示例1 输入 4 返回值 5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public: int rectCover(int number) { if(number\u0026lt;=2) return number; int first = 1; int second = 2; int result = 0; for(int i = 3;i\u0026lt;=number;i++) { result = first + second; first = second; second = result; } return result; } };   ","description":"剑指office（十）矩形覆盖","id":52,"section":"posts","tags":["剑指office"],"title":"剑指office（十）矩形覆盖","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/10%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/"},{"content":"题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。\n示例1 输入 3 返回值 4 1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution { public: int jumpFloorII(int number) { if(number\u0026lt;2) return 1; int result = 1; for(int i = 1;i\u0026lt;number;i++) { result *= 2; } return result; } };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public: int jumpFloorII(int number) { if(number\u0026lt;2) return 1; vector\u0026lt;int\u0026gt; dp(number+1,0); dp[0]=dp[1]=1; for(int i = 2;i\u0026lt;=number;i++) { for(int j=0;j\u0026lt;i;j++) { dp[i] += dp[j]; } } return dp[number]; } };   1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution { public: int jumpFloorII(int number) { if(number\u0026lt;2) return 1; int result = 1; for(int i=2;i\u0026lt;=number;i++) { result = result\u0026lt;\u0026lt;1;//左移乘 右移除  } return result; } };   ","description":"剑指office（九）跳台阶扩展问题","id":53,"section":"posts","tags":["剑指office"],"title":"剑指office（九）跳台阶扩展问题","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/9%E8%B7%B3%E5%8F%B0%E9%98%B6%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98/"},{"content":"题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public: int jumpFloor(int number) { if(number\u0026lt;=2) return number; int first = 1; int second = 2; int result = 0; for(int i = 2;i\u0026lt;number;i++) { result = first + second; first = second; second = result; } return result; } };   ","description":"剑指office（八）跳台阶","id":54,"section":"posts","tags":["剑指office"],"title":"剑指office（八）跳台阶","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/8%E8%B7%B3%E5%8F%B0%E9%98%B6/"},{"content":"题目描述 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。\nn≤39n≤39\n示例1 输入 4 返回值 3 1 2 3 4 5 6 7 8  class Solution { public: int Fibonacci(int n) { if(n\u0026lt;2) return n; return Fibonacci(n-1)+Fibonacci(n-2); } };   ","description":"剑指office（七）用两个栈实现队列","id":55,"section":"posts","tags":["剑指office"],"title":"剑指office（七）用两个栈实现队列","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/7%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"},{"content":"题目描述 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。\n输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。\nNOTE：给出的所有元素都大于0，若数组大小为0，请返回0。\n示例1 输入 [3,4,5,1,2] 返回值 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution { public: int minNumberInRotateArray(vector\u0026lt;int\u0026gt; rotateArray) { if(rotateArray.size()==0) return 0; int first = 0; int last = rotateArray.size()-1; int mid = 0; while(last!=first) { mid = floor((first + last)/2); if(rotateArray[last]\u0026gt;rotateArray[mid]) last = mid; else if(rotateArray[first]\u0026lt;rotateArray[mid]) first = mid+1; else first++; } return rotateArray[last]; } };   ","description":"剑指office（六）用两个栈实现队列","id":56,"section":"posts","tags":["剑指office"],"title":"剑指office（六）用两个栈实现队列","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/6%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"},{"content":"题目描述 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Solution { public: void push(int node) { stack1.push(node); } int pop() { if(stack2.empty()\u0026amp;\u0026amp;!stack1.empty()) { int stackS = stack1.size(); for(int i =0;i\u0026lt;stackS;i++) { int temp = stack1.top(); stack1.pop(); stack2.push(temp); } } int val = stack2.top(); stack2.pop(); return val; } private: stack\u0026lt;int\u0026gt; stack1; stack\u0026lt;int\u0026gt; stack2; };   ","description":"剑指office（五）用两个栈实现队列","id":57,"section":"posts","tags":["剑指office"],"title":"剑指office（五）用两个栈实现队列","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/5%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"},{"content":"题目描述 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。\n示例1 输入 [1,2,3,4,5,6,7],[3,2,4,1,6,5,7] 返回值 {1,2,5,3,4,6,7} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  /** * Definition for binary tree * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* reConstructBinaryTree(vector\u0026lt;int\u0026gt; pre,vector\u0026lt;int\u0026gt; vin) { if(pre.size() == 0) {//如果为空，返回NULL  return NULL; } TreeNode* tempNode = new TreeNode(pre[0]); int root = pre[0]; vector\u0026lt;int\u0026gt;leftPre; vector\u0026lt;int\u0026gt;leftVin; vector\u0026lt;int\u0026gt;rightPre; vector\u0026lt;int\u0026gt;rightVin; bool leftFlag = true; int j = 1; for(int i = 0;i\u0026lt;vin.size();i++) { if(root == vin[i]) { leftFlag = false; continue; } if(leftFlag) { leftPre.push_back(pre[j]); leftVin.push_back(vin[i]); j++; } else { rightPre.push_back(pre[j]); rightVin.push_back(vin[i]); j++; } } tempNode-\u0026gt;left = reConstructBinaryTree(leftPre,leftVin); tempNode-\u0026gt;right = reConstructBinaryTree(rightPre,rightVin); return tempNode; } };   ","description":"剑指office（四）重建二叉树","id":58,"section":"posts","tags":["剑指office"],"title":"剑指office（四）重建二叉树","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/4%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"content":"题目描述 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。\n示例1 输入 {67,0,24,58} 返回值 [58,24,0,67] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  /** * struct ListNode { * int val; * struct ListNode *next; * ListNode(int x) : * val(x), next(NULL) { * } * }; */ class Solution { public: vector\u0026lt;int\u0026gt; printListFromTailToHead(ListNode* head) { stack\u0026lt;int\u0026gt; temp; while(head!=NULL) { temp.push(head-\u0026gt;val); head = head-\u0026gt;next; } vector\u0026lt;int\u0026gt; result; int tempS = temp.size(); for(int i = 0;i\u0026lt;tempS;i++) { result.push_back(temp.top()); temp.pop(); } return result; } };   ","description":"剑指office（三）从尾到头打印链表","id":59,"section":"posts","tags":["剑指office"],"title":"剑指office（三）从尾到头打印链表","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/3%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"},{"content":"OneDriveUploader - Written in GoLang  支持 国际版, 个人版(家庭版), 中国版(世纪互联). 支持上传文件和文件夹到指定目录,并保持上传前的目录结构. 支持命令参数使用, 方便外部程序调用. 支持自定义上传分块大小. 支持多线程上传(多文件同时上传). 支持根据文件大小动态调整重试次数 支持跳过网盘中已存在的同名文件.  授权 通过下面URL登录 (右键新标签打开) 国际版, 个人版(家庭版) https://login.microsoftonline.com/common/oauth2/v2.0/authorize?client_id=78d4dc35-7e46-42c6-9023-2d39314433a5\u0026amp;response_type=code\u0026amp;redirect_uri=http://localhost/onedrive-login\u0026amp;response_mode=query\u0026amp;scope=offline_access%20User.Read%20Files.ReadWrite.All\n中国版(世纪互联) https://login.chinacloudapi.cn/common/oauth2/v2.0/authorize?client_id=dfe36e60-6133-48cf-869f-4d15b8354769\u0026amp;response_type=code\u0026amp;redirect_uri=http://localhost/onedrive-login\u0026amp;response_mode=query\u0026amp;scope=offline_access%20User.Read%20Files.ReadWrite.All\n初始化配置文件 # 国际版 OneDriveUploader -a \u0026quot;url\u0026quot; # 个人版(家庭版) OneDriveUploader -ms -a \u0026quot;url\u0026quot; # 中国版(世纪互联) OneDriveUploader -cn -a \u0026quot;url\u0026quot; # 在浏览器地址栏中获取以 http://loaclhost 开头的整个url内容 # 将获取的完整url内容替换命令中的 url 三个字母 # 每次产生的 url 只能用一次, 重试请重新获取 url # 此操作将会自动初始化的配置文件 # 提示 Init config file: '/path/to/auth.json' 则成功 使用 Usage of OneDriveUploader: -a string // 初始化授权 Setup and Init auth.json. -b string // 自定义上传分块大小, 可以提高网络吞吐量, 受限于磁盘性能和网络速度. Set block size. [Unit: M; 5\u0026lt;=b\u0026lt;=60;] (default \u0026quot;10\u0026quot;) -c string // 配置文件路径 Config file. (default \u0026quot;auth.json\u0026quot;) -n string // 上传单个文件时,在网盘中重命名 Rename file on upload to remote. -r string // 上传到网盘中的某个目录, 默认: 根目录 Upload to reomte path. -s string // *必要参数, 要上传的文件或文件夹 Upload item. -t string // 线程数, 同时上传文件的个数. 默认: 2 Set thread num. (default \u0026quot;2\u0026quot;) -f // 开关(推荐) // 加上 -f 参数，强制读取 auth.json 中的块大小配置和多线程配置. // 不加 -f 参数, 每次覆盖保存当前使用参数到 auth.json 配置文件中. Force Read config form config file. [BlockSize, ThreadNum] -skip // 开关 // 跳过上传网盘中已存在的同名文件. (默认不跳过) Skip exist file on remote. -cn // 开关 // 授权中国版(世纪互联), 需要此参数. OneDrive by 21Vianet. -ms // 开关 // 授权个人版(家庭版), 需要此参数. OneDrive by Microsoft. 配置 { // 授权令牌 \u0026quot;RefreshToken\u0026quot;: \u0026quot;1234564567890ABCDEF\u0026quot;, // 最大线程数.(同时上传文件的数量) \u0026quot;ThreadNum\u0026quot;: \u0026quot;2\u0026quot;, // 最大上传分块大小.(每次上传文件的最大分块大小,网络不好建议调低. 单位:MB) \u0026quot;BlockSize\u0026quot;: \u0026quot;10\u0026quot;, // 最大单文件大小.(目前: 个人版(家庭版)单文件限制为100GB; 其他版本单文件限制为15GB,微软将逐步更新为100GB. 单位:GB) \u0026quot;SigleFile\u0026quot;: \u0026quot;100\u0026quot;, // 缓存刷新间隔. \u0026quot;RefreshInterval\u0026quot;: 1500, // 如果是中国版(世纪互联), 此项应为 true. \u0026quot;MainLand\u0026quot;: false, // 如果是家庭版或者个人免费版, 此项应为 true. \u0026quot;MSAccount\u0026quot;: true } 示例 # 一些示例: # 将同目录下的 mm00.jpg 文件上传到 OneDrive 网盘根目录 OneDriveUploader -s \u0026quot;mm00.jpg\u0026quot; # 将同目录下的 mm00.jpg 文件上传到 OneDrive 网盘根目录,并改名为 mm01.jpg OneDriveUploader -s \u0026quot;mm00.jpg\u0026quot; -n \u0026quot;mm01.jpg\u0026quot; # 将同目录下的 Download 文件夹上传到 OneDrive 网盘根目录 OneDriveUploader -s \u0026quot;Download\u0026quot; # 将同目录下的 Download 文件夹上传到 OneDrive 网盘Test目录中 OneDriveUploader -s \u0026quot;Download\u0026quot; -r \u0026quot;Test\u0026quot; # 将同目录下的 Download 文件夹上传到 OneDrive 网盘Test目录中, 使用 10 线程 OneDriveUploader -t 10 -s \u0026quot;Download\u0026quot; -r \u0026quot;Test\u0026quot; # 将同目录下的 Download 文件夹上传到 OneDrive 网盘Test目录中, 使用 15 线程, 并设置分块大小为 20M OneDriveUploader -t 15 -b 20 -s \u0026quot;Download\u0026quot; -r \u0026quot;Test\u0026quot; # 将同目录下的 Download 文件夹上传到 OneDrive 网盘Test目录中, 使用配置文件中的线程参数和分块大小参数 OneDriveUploader -f -c \u0026quot;/urs/local/auth.json\u0026quot; -s \u0026quot;Download\u0026quot; -r \u0026quot;Test\u0026quot; # 将同目录下的 Download 文件夹上传到 OneDrive 网盘Test目录中, 使用配置文件中的线程参数和分块大小参数，并跳过上传网盘中已存在的同名文件 OneDriveUploader -f -c \u0026quot;/urs/local/auth.json\u0026quot; -skip -s \u0026quot;Download\u0026quot; -r \u0026quot;Test\u0026quot; 注意  多次尝试后, 无失败的上传文件. 退出码为 0 . 最终还有失败的上传文件会详细列出上传失败项. 退出码为 1.  Client/Secret (~ 2299/12/31) # 国际版: 78d4dc35-7e46-42c6-9023-2d39314433a5| ZudGl-p.m=LMmr3VrKgAyOf-WevB3p50 # 中国版: dfe36e60-6133-48cf-869f-4d15b8354769| H0-1:6.Sb8:WCW/J-c]K@fddCt[i0EZ2 ","description":"","id":60,"section":"posts","tags":["onedrive"],"title":"OneDriveUploader使用","uri":"https://yslinwe.github.io/posts/onedriveuploader%E4%BD%BF%E7%94%A8/"},{"content":"题目描述 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。\n示例1 输入 \u0026quot;We Are Happy\u0026quot; 返回值 \u0026quot;We%20Are%20Happy\u0026quot; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param s string字符串 * @return string字符串 */ string replaceSpace(string s) { for(int i = 0;i\u0026lt;s.size();i++) { if(s[i]==\u0026#39; \u0026#39;) { s = s.replace(i,1,\u0026#34;%20\u0026#34;); } } return s; } };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param s string字符串 * @return string字符串 */ string replaceSpace(string s) { string newS; for(int i = 0;i\u0026lt;s.size();i++) { if(s[i]==\u0026#39; \u0026#39;) { newS +=\u0026#34;%20\u0026#34;; }else { newS +=s[i]; } } return newS; } };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param s string字符串 * @return string字符串 */ string replaceSpace(string s) { int sSize = s.size(); int spaceNum = 0; for(int i = 0;i\u0026lt;sSize;i++) { if(s[i]==\u0026#39; \u0026#39;) { spaceNum++; } } int newLen = spaceNum*2 + sSize; int newI = 0; string newS(newLen,\u0026#39; \u0026#39;); for(int i = sSize - 1,newI = newLen-1;i\u0026gt;=0;i--,newI--) { if(s[i]==\u0026#39; \u0026#39;) { newS[newI] = \u0026#39;0\u0026#39;; newI = newI-1; newS[newI] = \u0026#39;2\u0026#39;; newI = newI -1; newS[newI] = \u0026#39;%\u0026#39;; } else { newS[newI] = s[i]; } } return newS; } };   ","description":"剑指office（二）替换空格","id":61,"section":"posts","tags":["剑指office"],"title":"剑指office（二）替换空格","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/2%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"},{"content":"1 2 3 4 5 6 7 8 9 10  in:name example 名字中有“example” in:readme example readme中有“example” in:description example 描述中有“example” stars:\u0026gt;1000 star\u0026gt;1000 forks:\u0026gt;1000 fork\u0026gt;1000 pushed:\u0026gt;2019-09-01 2019年9月1日后有更新的 language:java 用Java编写的项目 更多打开：https://help.github.com/en/github/searching-for-information-on-github/searching-for-repositories   ","description":"","id":62,"section":"posts","tags":["github高级搜索"],"title":"Github高级搜索","uri":"https://yslinwe.github.io/posts/github/github%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2/"},{"content":"题目描述 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n[\n[1,2,8,9],\n[2,4,9,12],\n[4,7,10,13],\n[6,8,11,15]\n]\n给定 target = 7，返回 true。\n给定 target = 3，返回 false。\n示例1 输入 7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]] 返回值 true 说明 存在7，返回true 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution { public: bool Find(int target, vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; array) { int cowS = array.size(); int rowS = array[0].size(); int cow = 0; //行  int row = rowS - 1; while(cow\u0026lt;cowS\u0026amp;\u0026amp;row\u0026gt;=0) { int val = array[cow][row]; if(val == target) return true; else if(target\u0026lt;val) row--; else cow++; } return false; } };   ","description":"剑指office（一）二维数组查找","id":63,"section":"posts","tags":["剑指office"],"title":"剑指office（一）二维数组查找","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/1%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE/"},{"content":"上传文件 1 2 3 4 5 6 7 8  pscp -r newlivedowload root@139.9.116.41:live_download nethogs eth0 ls -lh df -l ps -aux|grep get.py| grep -v grep nohup 运行文件\u0026gt;\u0026gt; output.log 2\u0026gt;\u0026amp;1 \u0026amp; nohup python3 -u main.py \u0026gt; test.out 2\u0026gt;\u0026amp;1 \u0026amp;   限制网速  git clone https://github.com/magnific0/wondershaper.git 在确定网卡名称以后，就可以按照以下的命令限制网络带宽：\n sudo wondershaper -a \u0026lt;adapter\u0026gt; -d \u0026lt;rate\u0026gt; -u \u0026lt;rate\u0026gt; 例如，如果网卡名称是 enp0s8，并且需要把上行、下行速率分别限制为 1024 Kbps 和 512 Kbps，就可以执行以下命令：\n sudo wondershaper -a eth0 -d 1024 -u 512 其中参数的含义是：\n-a：网卡名称\n-d：下行带宽\n-u：上行带宽\n如果要对网卡解除网络带宽的限制，只需要执行：\n ./wondershaper -a eth0 -c 后台运行 可以先执行：screen -S zgy ，screen就会创建一个名字为zgy的会话\n运行代码 当需要临时离开时（会话中的程序不会关闭，仍在运行）可以用快捷键Ctrl+a d(即按住Ctrl，依次再按a,d)\n当回来时可以再执行执行：screen -r zgy 即可恢复到离开前创建的zgy会话的工作界面。\n screen -ls screen会列出当前存在的会话列表  恢复会话：  screen -r zgy或screen -r pid  退出会话 执行：exit ，会提示：[screen is terminating]，表示已经成功退出screen会话。\n常用快捷键 kill 掉一个窗口\n  screen -X -S 4588 quit\n  Ctrl+a c ：在当前screen会话中创建窗口\n  Ctrl+a w ：窗口列表\n  Ctrl+a n ：下一个窗口\n  Ctrl+a p ：上一个窗口\n  Ctrl+a 0-9 ：在第0个窗口和第9个窗口之间切换\n  ","description":"","id":64,"section":"posts","tags":["服务器"],"title":"服务器命令行","uri":"https://yslinwe.github.io/posts/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":65,"section":"gallery","tags":null,"title":"卡通","uri":"https://yslinwe.github.io/gallery/cartoon/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":66,"section":"gallery","tags":null,"title":"图片","uri":"https://yslinwe.github.io/gallery/photo/"},{"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\n https://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n","description":"Hugo, the world’s fastest framework for building websites","id":71,"section":"","tags":null,"title":"关于","uri":"https://yslinwe.github.io/about/"}]