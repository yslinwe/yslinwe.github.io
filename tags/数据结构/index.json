[{"content":"数据结构笔记 顺序栈和顺序队列使用动态数组实现\n以下不是C++中stack的实现\n顺序栈 特点：后进先出，先进后出\n栈可以用数组或者链表写\n开始时，栈顶Top=-1\n顺序栈操作 Push（栈顶添加元素）\nTop（返回当前栈顶数据）\nPop （删除栈顶数据）\nIsEmpty（检查栈是否为空）\n数组实现 实现自动扩大数组大小 模板类实现和声明要写在一起 1 2 3 4 5 6 7 8 9 10  template\u0026lt;class T\u0026gt; void ChangeSize1D(T* \u0026amp;a,const int oldSize, const int newSize) { if(newSize\u0026lt;0) throw \u0026#34;newSize must be \u0026gt;=0\u0026#34;; T* temp =new T[newSize]; int number = min(oldSize,newSize); std::copy(a,a+number,temp); delete[] a; a=temp; }   顺序队列（Queue） 特点：先进先出，后进后出\n队列操作  Push（队尾添加元素） Pop （队首删除元素） Front（返回当前队首数据） Rear（返回当前队尾数据） IsEmpty（检查队列是否为空）  实现回绕（利用数组删除后留下的空间）  rear=front front++ 如果front=rear表示队列满了，要自动扩大数组大小  链表  链表：1.数据域 2.链接域 数组缺点：插入数据时慢，需要向后移动，删除数据时，需要向前移动。 链表可以弥补这些缺点。  树  数组缺点：插入数据，数据要移动。 数组优点：二分查找 链表缺点：无法二分查找 链表优点: 插入删除数据快 树 = 数组的优点 + 链表的优点  ","description":"","id":2,"section":"posts","tags":["数据结构"],"title":"数据结构学习","uri":"https://yslinwe.github.io/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"},{"content":"test\n","description":"剑指office","id":3,"section":"posts","tags":["剑指office"],"title":"剑指office","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer%E7%9B%AE%E5%BD%95/"},{"content":"Git Flow 的正确使用姿势 Git Flow 的概念 在使用Git的过程中如果没有清晰流程和规划，否则,每个人都提交一堆杂乱无章的commit,项目很快就会变得难以协调和维护。\nGit版本管理同样需要一个清晰的流程和规范。\nVincent Driessen 为了解决这个问题提出了 A Successful Git Branching Model\n以下是基于Vincent Driessen提出的Git Flow 流程图\nGit Flow 的常用分支   Production 分支 也就是我们经常使用的Master分支，这个分支最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支直接修改\n  Develop 分支 这个分支是我们是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支\n  Feature 分支 这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release\n  Release分支 当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支\n  Hotfix分支 当我们在Production发现新的Bug时候，我们需要创建一个Hotfix, 完成Hotfix后，我们合并回Master和Develop分支，所以Hotfix的改动会进入下一个Release。\n  Git Flow 如何使用   Master/Devlop 分支 所有在Master分支上的Commit应该打上Tag，一般情况下Master不存在Commit，Devlop分支基于Master分支创建。\n  Feature 分支 Feature分支做完后，必须合并回Develop分支, 合并完分支后一般会删点这个Feature分支，毕竟保留下来意义也不大。  Release 分支 Release分支基于Develop分支创建，打完Release分支之后，我们可以在这个Release分支上测试，修改Bug等。同时，其它开发人员可以基于Develop分支新建Feature (记住：一旦打了Release分支之后不要从Develop分支上合并新的改动到Release分支)发布Release分支时，合并Release到Master和Develop， 同时在Master分支上打个Tag记住Release版本号，然后可以删除Release分支了。\n  Hotfix 分支 hotfix分支基于Master分支创建，开发完后需要合并回Master和Develop分支，同时在Master上打一个tag。\n  Git Flow 命令示例 创建 Devlop 1 2  git branch develop git push -u origin develop   开始 Feature 1 2 3 4 5 6 7 8 9  # 通过develop新建feaeure分支 git checkout -b feature develop # 或者, 推送至远程服务器: git push -u origin feature # 修改md文件  git status git add . git commit   完成 Feature 1 2 3 4 5 6 7 8 9 10 11 12 13  git pull origin develop git checkout develop #--no-ff：不使用fast-forward方式合并，保留分支的commit历史 #--squash：使用squash方式合并，把多次分支commit历史压缩为一次 git merge --no-ff feature git push origin develop git branch -d some-feature # 如果需要删除远程feature分支: git push origin --delete feature   开始 Release 1  git checkout -b release-0.1.0 develop   完成 Release 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  git checkout master git merge --no-ff release-0.1.0 git push git checkout develop git merge --no-ff release-0.1.0 git push git branch -d release-0.1.0 git push origin --delete release-0.1.0 # 合并master/devlop分支之后，打上tag  git tag -a v0.1.0 master git push --tags   开始 Hotfix 1  git checkout -b hotfix-0.1.1 master   完成 Hotfix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  git checkout master git merge --no-ff hotfix-0.1.1 git push git checkout develop git merge --no-ff hotfix-0.1.1 git push git branch -d hotfix-0.1.1 git push origin --delete hotfix-0.1.1 git tag -a v0.1.1 master git push --tags   使用建议 如果你的代码没有清晰流程和规划，那么强烈推荐使用Vincent Driessen 提出的GIt flow让你的代码管理骚起来。\n结尾 本站文章图片等等来源于网络,仅作为学习之用,版权归原作者所有.如果侵犯了您的权益,请来信告知,我会尽快删除.\n","description":"","id":4,"section":"posts","tags":["git"],"title":"Git Flow 的正确使用姿势","uri":"https://yslinwe.github.io/posts/github/git-flow-%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/"},{"content":"删除 .DS_Store 如果你的项目中还没有自动生成的 .DS_Store 文件，那么直接将 .DS_Store 加入到 .gitignore 文件就可以了。如果你的项目中已经存在 .DS_Store 文件，那就需要先从项目中将其删除，再将它加入到 .gitignore。如下：\n删除项目中的所有.DS_Store。这会跳过不在项目中的 .DS_Store   find . -name .DS_Store -print0 | xargs -0 git rm -f \u0026ndash;ignore-unmatch\n将 .DS_Store 加入到 .gitignore\n  echo .DS_Store \u0026raquo; ~/.gitignore\n  更新项目  git add \u0026ndash;all\n  git commit -m \u0026lsquo;.DS_Store banished!\u0026rsquo;\n  如果你只需要删除磁盘上的 .DS_Store，可以使用下面的命令来删除当前目录及其子目录下的所有.DS_Store 文件:\n1  find . -name \u0026#39;*.DS_Store\u0026#39; -type f -delete   禁用或启用自动生成\n禁止.DS_store生成：\n1  defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE   恢复.DS_store生成：恢复.DS_store生成：\n1  defaults delete com.apple.desktopservices DSDontWriteNetworkStores   ","description":"","id":5,"section":"posts","tags":["Mac"],"title":"Mac中删除.DS_Store","uri":"https://yslinwe.github.io/posts/mac/mac%E4%B8%AD%E5%88%A0%E9%99%A4.ds_store/"},{"content":"入参    参数 描述 是否必传 默认值     gitee-username Gitee用户名 是 -   gitee-password Gitee密码 是 -   gitee-repo Gitee仓库（严格区分大小写） 是 -   branch 要部署的分支 否 master   directory 要部署的分支上的目录 否 ''   https 是否强制使用https 否 true    示例 在GitHub的仓库创建 .github/workflows/ 文件夹并且创建一个**sync.yml** 文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  name:Syncon:push:branches:[giteePage ]jobs:build:runs-on:ubuntu-lateststeps:- name:Sync to Giteeuses:wearerequired/git-mirror-action@masterenv:# 注意在 Settings-\u0026gt;Secrets 配置 PRIVATE SSH_PRIVATE_KEY:${{ secrets.PRIVATE }}with:# 注意替换为你的 GitHub 源仓库地址source-repo:\u0026#34;git@github.com:username/username.github.io.git\u0026#34;# 注意替换为你的 Gitee 目标仓库地址destination-repo:\u0026#34;git@gitee.com:username/username.git\u0026#34;- name:Build Gitee Pagesuses:yanglbme/gitee-pages-action@masterwith:# 注意替换为你的 Gitee 用户名gitee-username:username# 注意在 Settings-\u0026gt;Secrets 配置 PASSWORDgitee-password:${{ secrets.PASSWORD }}# 注意替换为你的 Gitee 仓库gitee-repo:username/username# 提交到gitee的github仓库的分支branch:giteePage  先使用 wearerequired/git-mirror-action 将 GitHub 仓库同步到 Gitee 仓库，再使用 yanglbme/gitee-pages-action 实现 Gitee Pages 的自动部署。\n运行需要在 GitHub 项目的 Settings -\u0026gt; Secrets 路径下配置好 **PRIVATE **以及 PASSWORD 两个密钥。其中：\n **PRIVATE **: 存放你的 id_rsa 私钥。PASSWORD: 存放你的 Gitee 账户密码。\n 1. 配置PRIVATE   生成SSH密钥\n1  ssh-keygen -t rsa -C \u0026#34;name\u0026#34;   \u0026ldquo;name\u0026quot;是任意指定的标识\n 获取公钥  1  cat ~/.ssh/id_rsa.pub    绑定Gitee    复制公钥，通过仓库主页个人图像下拉设置-\u0026gt;SSH公钥添加公钥\n  测试\n打开终端输入：\n1  ssh -T git@gitee.com   显示如下图则成功\n    绑定Github\n复制公钥，通过仓库主页个人图像下拉Setting-\u0026gt;SSH and GPG keys添加公钥\n  测试\n打开终端输入：\n1  ssh -T git@github.com   显示如下图则成功\n    配置\n  获取私钥\n1  cat ~/.ssh/id_rsa    复制私钥，在仓库的Setting-\u0026gt;Secrets路径下命名PRIVATE，Value添加私钥（记得复制全部内容）\n     2. 配置PASSWORD  在仓库的Setting-\u0026gt;Secrets路径下命名PASSWORD，Value添加**Gitee**账户密码。\n 如果一切配置正常，并成功触发 Gitee Pages Action ，我们可能会收到一封来自 Gitee 的告警邮件/站内信。放心，这是 GitHub Action 程序帮我们登录到 Gitee 官网，并为我们点击了项目的部署按钮。\nFAQ 问题 1：遇到短信验证码导致无法自动部署，怎么解决？ 因为 Gitee Pages Action 使用的是 GitHub 自家的服务器（美国），在这种情况下，当 Action 自动\t帮我们登录 Gitee 的时候，会触发 Gitee 帐号异常登录告警，提示用户在非正常的 IP 地址登陆\tGitee，需要输入验证码。\n解决方案是：关注「码云 Gitee」 微信公众号，绑定个人微信到码云帐号。这样 Action 在登录的过程中，Gitee 就不会下发短信验证码，而是通过「码云 Gitee」公众号给我们发送一个登录通知，Action 就能成功登录了。\n问题 2：报 deploy error occurred, message: \u0026lsquo;NoneType\u0026rsquo; object has no attribute \u0026lsquo;group\u0026rsquo; 错误，怎么办？ 报了这个错误，说明 Action 已经成功帮我们登录 Gitee 帐号了，但在访问 Gitee Repo 的过程中出现问题。\n这种情况，一般是 Gitee Pages Action 的参数配置错误导致，请仔细检查你的配置信息。\n 注意：gitee-repo 参数严格区分大小写，请准确填写，比如 doocs/advanced-java，当你写成 doocs/Advanced-java 的时候，是访问不到的，不信你可以试试访问：https://gitee.com/Doocs/Advanced-java\n ","description":"","id":6,"section":"posts","tags":["Github Action","github"],"title":"Github Action 同步gitee和github单个仓库","uri":"https://yslinwe.github.io/posts/github/github-action-%E5%90%8C%E6%AD%A5gitee%E5%92%8Cgithub%E5%8D%95%E4%B8%AA%E4%BB%93%E5%BA%93/"},{"content":"插入图片 使用 Markdown 编写文档或博客时，经常需要对图片的位置与尺寸进行调整。\n插入图片后，Markdown 表示图片的语法格式如下：\n![图片描述](图片链接) 调整图片位置 居左 （1）方法一：添加位置标识。\n1  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200822014538211.png#pic_left)   （2）方法二：嵌入 HTML 代码。\n1 2 3  \u0026lt;div align=\u0026#34;left\u0026#34;\u0026gt; \u0026lt;img src=https://img-blog.csdnimg.cn/20200822014538211.png /\u0026gt; \u0026lt;/div\u0026gt;   居中 （1）方法一：添加位置标识。\n1  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200822014538211.png#pic_center)   （2）方法二：嵌入 HTML 代码。\n1 2 3  \u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;img src=https://img-blog.csdnimg.cn/20200822014538211.png /\u0026gt; \u0026lt;/div\u0026gt;   居右 （1）方法一：添加位置标识。\n1  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200822014538211.png#pic_right)   （2）方法二：嵌入 HTML 代码。\n1 2 3  \u0026lt;div align=\u0026#34;right\u0026#34;\u0026gt; \u0026lt;img src=https://img-blog.csdnimg.cn/20200822014538211.png /\u0026gt; \u0026lt;/div\u0026gt;   调整图片大小 等比缩放 相对于父级窗口 使用百分比只定义宽即可等比例缩放。注意：宽度相对于图片所在父级窗口。\n1  \u0026lt;img src=https://img-blog.csdnimg.cn/20200822014538211.png width=60% /\u0026gt;   相对于自身 非等比缩放 将图片的宽高缩小或放大为原来的指定百分比。\n固定宽高 1  \u0026lt;img src=https://img-blog.csdnimg.cn/20200822014538211.png width=200 height=100 /\u0026gt;   ","description":"","id":7,"section":"posts","tags":["Markdown"],"title":"Markdown 调整图片位置与大小","uri":"https://yslinwe.github.io/posts/markdown/markdown-%E8%B0%83%E6%95%B4%E5%9B%BE%E7%89%87%E4%BD%8D%E7%BD%AE%E4%B8%8E%E5%A4%A7%E5%B0%8F/"},{"content":"安装软件   安装 node.js 下载地址\n  安装PicGO客户端 下载地址\n  在Picgo里面安装Gitee扩展插件\n  安装完成后重启应用在图床设置会显示gitee\n注册Gitee账号并创建图床仓库，获取Token   自行注册账号，创建仓库，仓库记得初始化。 Gitee官网\n  1  个人图片下拉栏 -\u0026gt; 设置 -\u0026gt; 私人令牌   在设置中创建私人令牌（Token）自行保存好，它只会在创建的时候显示一次，之后就不再显示，只能重新生成或者创建\n    配置Picgo上的Gitee 至此Picgo搭配Gitee的图床就搭建完了\n刚快尝试上传图片吧。\n使用Typora的Picgo插件   下载 Typora 下载地址\n  配置Picgo\n  进入Typora设置\n    该设置完成之后，直接将图片复制进Typora 的编辑区即可完成图片的上传，并且文章使用的图片Url就是图床相应的Url。\n  ","description":"","id":8,"section":"posts","tags":["PicGo","个人图床"],"title":"PicGo配合gtiee实现个人图床","uri":"https://yslinwe.github.io/posts/picgo%E9%85%8D%E5%90%88gtiee%E5%AE%9E%E7%8E%B0%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/"},{"content":"git回退到上个版本 1  git reset --hard HEAD^   回退到前3次提交之前，以此类推，回退到n次提交之前 1  git reset --hard HEAD~3   查看commit的sha码 1  git log   1  git show dde8c25694f34acf8971f0782b1a676f39bf0a46   退到/进到 指定commit的sha码 1  git reset --hard dde8c25694f34acf8971f0782b1a676f39bf0a46   强推到远程 git push origin HEAD --force 把git add添加进去的文件撤销添加 git reset HEAD 相对路径名\n1  git reset HEAD public/uploads/   git练习地址: https://learngitbranching.js.org/?locale=en_US\n","description":"","id":9,"section":"posts","tags":["git"],"title":"git回退上一个版本","uri":"https://yslinwe.github.io/posts/github/git%E5%9B%9E%E9%80%80%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"content":"创建repo repo名称为\u0026lt;username\u0026gt;.github.io  设置github actions自动部署 将博客源码放到一个private repo 或者 public repo 中，\n创建一个blogSite分支。\nblogSite分支，用于存放博客源码\nmaster分支，用于存放博客网页代码\n需要获取一个personal_token或者deploy_key来获取repo的权限，这里选择personal_token的方式，这种方式更简单，后者可以自行了解。\n生成一个personal_token 点击GitHub头像在下拉栏里进入Setting-Developer -\u0026gt; Setting-Personal access\n选择 Generate new token\n在上方填入名字ACTION_ACCESS_TOKEN，并勾选repo里的所有选项，还有admin:repo_hook\n点击 Generate token 生成 token，\n并先复制保存该token（记得保存后面要用到）\n然后执行以下几步：\n1.在源码repo里新建一个blogSite分支：git checkout -b blogSite 2.在repo根目录新建嵌套的两个文件夹.github/workflows 3.在workflows里新建一个后缀为.yml的配置文件，名字自取。 4.写进去以下配置（从hugo官方文档修改而来）：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  name:github pages# 名字自取on:push:branches:- blogSite # 这个是博客源码分支jobs:deploy:# 任务名自取runs-on:ubuntu-18.04\t# 在什么环境运行任务steps:- uses:actions/checkout@v2\t# 引用actions/checkout这个action，与所在的github仓库同名with:submodules:true# Fetch Hugo themes (true OR recursive) 获取submodule主题fetch-depth:0# Fetch all history for .GitInfo and .Lastmod- name:Setup Hugo\t# 步骤名自取uses:peaceiris/actions-hugo@v2\t# hugo官方提供的action，用于在任务环境中获取hugowith:hugo-version:\u0026#39;latest\u0026#39;# 获取最新版本的hugo# extended: true- name:Buildrun:hugo --minify\t# 使用hugo构建静态网页- name:Deployuses:peaceiris/actions-gh-pages@v3\t# 一个自动发布github pages的actionwith:# github_token: ${{ secrets.GITHUB_TOKEN }} 该项适用于发布到源码相同repo的情况，不能用于发布到其他repoexternal_repository:username/username.github.io\t# username 是你的仓库repo的名称，也是你的用户名personal_token:${{ secrets.ACTION_ACCESS_TOKEN }}\t# 发布到其他repo需要提供上面生成的personal access tokenpublish_dir:./public\t# 注意这里指的是要发布哪个文件夹的内容，而不是指发布到目的仓库的什么位置，因为hugo默认生成静态网页到public文件夹，所以这里发布public文件夹里的内容publish_branch:master\t# 发布到哪个branch   记得修改 external_repository中的username  接下来在源码repo中添加上面的personal access token： 进入repo的Settings-Secrets一栏，选择New repository secret\n在下面填入刚才生成的token，名字注意需要与上面yml文件里XXX相同\npersonal_token: ${{ secrets.XXX }}\n这里的名称是ACTION_ACCESS_TOKEN\n添加token之后，进入github actions里点击刚才失败的任务，点击右上角Re-run jobs\n这时应该能够成功运行该任务，这说明自动部署已经开始在工作了，以后往blogSite分支push新文章时github actions会自动生成静态博客并发布到master中。\n","description":"","id":10,"section":"posts","tags":["Github Action","Hugo"],"title":"Hugo使用Github Action自动部署博客到Github Pages","uri":"https://yslinwe.github.io/posts/github/hugo%E4%BD%BF%E7%94%A8github-action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0github-pages/"},{"content":"配置后的效果如下: 1. 安装Unity 2.下载安装.Net Core SDK https://dotnet.microsoft.com/download/dotnet\n运行命令检查安装是否成功\n1  dotnet --version   3.下载安装Mono SDK https://www.mono-project.com/download/stable/\n运行命令检查安装是否成功\n1  mono --version   4. 安装VsCode 4.1 安装VsCode插件 1 2 3 4 5 6 7  C# C# Extensions C# FixFormat Fixed Debugger for Unity Unity Tools Unity Code Snippets Unity Snippets   4.2 VsCode 配置omnisharp路径 设置路径\nCode -\u0026gt; Preferences -\u0026gt; Settings, 检索mono, 点击settings.json 配置omnisharp(很重要) 1 2  \u0026#34;omnisharp.monoPath\u0026#34;: \u0026#34;/Library/Frameworks/Mono.framework/Versions/Current/Commands/mono\u0026#34;, \u0026#34;omnisharp.useGlobalMono\u0026#34;: \u0026#34;always\u0026#34;   设置.zshrc/.bash_profile环境变量(很重要) 1  export FrameworkPathOverride=/Library/Frameworks/Mono.framework/Versions/Current   5.设置Unity代码编辑器 ","description":"","id":11,"section":"posts","tags":["VSCode Unity环境搭建"],"title":"Mac VSCode开发Unity环境搭建","uri":"https://yslinwe.github.io/posts/mac/mac-vscode%E5%BC%80%E5%8F%91unity%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"content":"获取宝塔面板的登陆链接和用户名、密码 /etc/init.d/bt default ","description":"","id":12,"section":"posts","tags":["宝塔面板","服务器"],"title":"宝塔面板命令行","uri":"https://yslinwe.github.io/posts/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/"},{"content":"Part1 安装oh-my-zsh  第一步 clone oh-my-zsh项目  1  git clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh    第二步 复制 .zshrc  1  cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc    第三步 更改你的默认 Shell  1  chsh -s /bin/zsh   修改后终端变为这样\nps:这里选择了steeef主题，不是默认的robbyrussell主题\n终端的命令提示符 Part2 主题配置  修改.zshrc  cd ~ vim ~/.zshrc  更改主题\n  将 ZSH_THEME=\u0026ldquo;robbyrussell\u0026rdquo; 改成 ZSH_THEME=\u0026ldquo;steeef\u0026rdquo;\n 应用到.zshrc  source ~/.zshrc P.S. 这些主题都保存在 \u0026ldquo;~/.oh-my-zsh/themes\u0026rdquo; 目录中\n插件\noh-my-zsh 的自带插件都储存在 \u0026ldquo;~/.oh-my-zsh/plugins\u0026rdquo; 目录中,\n在 ~/.zshrc 中的 plugins 加入插件名称，这样设置就完成了。\n   安装 zsh-syntax-highlighting   对于oh-my-zsh\n git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 在 ~/.zshrc 中加入插件的名字\nplugins=(zsh-syntax-highlighting)\n，最后source生效\nsource ~/.zshrc  对于osx\n可以直接\n brew install zsh-syntax-highlighting 并且source生效\nsource /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh ","description":"","id":13,"section":"posts","tags":["Mac"],"title":"Mac终端美化","uri":"https://yslinwe.github.io/posts/mac/mac%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96/"},{"content":"一级标题 二级标题 一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 Markdown 段落 Runoob.com\nGoogle.com\n字体 斜体字体\n粗体\n斜粗体\n分割线 删除线 baidu.com 双波浪线是英文字符\n下划线 带下划线\n脚注 格式 [^要注明的文本]\n创建脚注格式类似这样1\nMarkdown 列表 无序  第一 第二 第三   第一 第二 第三   第一 第二 第三  有序  第一 第二 第三  列表嵌套  第一项  第一项嵌套的第一个元素 第一项嵌套的第二个元素   第二项  第二项嵌套的第一个元素 第二项嵌套的第二个元素    Markdown 区块  区块引用\n菜鸟教程\n学的不仅是技术更是梦想\n 区块嵌套  最外层\n 第一层嵌套\n 第二层嵌套\n   区块中列表   第一项 第二项   第一项 第二项 第三项   列表中使用区块  第一项  菜鸟教程\n学的不仅是技术更是梦想\n  第二项  Markdown 代码 printf() 函数\n\u0026lt;?php echo 'RUNOOB'; function test(){ echo 'test' }  可以指定一种语言或者不指定\n1 2 3  $(document).ready(function()){ alert(\u0026#39;RUNOOB\u0026#39;); });   1  print(\u0026#34;hello world\u0026#34;)   Markdown 链接 格式 链接名称\n这个是一个链接 菜鸟教程\n直接使用链接\nhttps://runoob.com\n高级链接 这个链接用 1 作为网址变量 Google\n这个链接用 runoob 作为网址变量 Runoob\n注意至少空一行\nMarkdown 图片 格式 使用实例：\n图片地址引用：\n这个链接用 1 作为网址变量RUNOOB\n指定图片的高度 宽度\nMarkdown 表格 Markdown 制作表格使用 | 来分隔不同的单元格 使用 - 来分隔表头和其它行\n   表头 表头     单元格 单元格   单元格 单元格    对齐方式：\n -: 设置右对齐 :- 设置左对齐 :-: 设置居中对齐     左对齐 右对齐 居中对齐     单元格 单元格 单元格   单元格 单元格 单元格    Markdown 高级技巧 支持的HTML元素\n目前支持的HTML元素有： \u0026lt;kbd\u0026gt; \u0026lt;b\u0026gt; \u0026lt;i\u0026gt; \u0026lt;em\u0026gt; \u0026lt;sup\u0026gt; \u0026lt;sub\u0026gt; \u0026lt;br\u0026gt; 等\n使用Ctrl+Alt+Del 重启电脑\n  斜体\n斜体\n图片上移动\n图片下移动\n\u0026lt;br\u0026gt;我换行了\n \n我换行了\n加反斜杆转义特殊字符  ** 正常显示星号 **\n Markdown 支持以下符号加上反斜杠变成普通字符\n \\反斜线\n` 反引号\n* 星号\n_ 下划线\n{} 花括号\n[] 方括号\n() 小括号\n# 井字号\n+ 加号\n- 减号\n. 英文句号\n! 感叹号\n 1. 横向流程图源码格式：\ngraph LR A[方形] --\u0026gt;B(圆角) B --\u0026gt; C{条件a} C --\u0026gt;|a=1| D[结果1] C --\u0026gt;|a=2| E[结果2] F[横向流程图] 2. 竖向流程图源码格式：\ngraph TD A[方形] --\u0026gt; B(圆角) B --\u0026gt; C{条件a} C --\u0026gt; |a=1| D[结果1] C --\u0026gt; |a=2| E[结果2] F[竖向流程图] 3. 标准流程图源码格式：\nst=\u0026gt;start: 开始框 op=\u0026gt;operation: 处理框 cond=\u0026gt;condition: 判断框(是或否?) sub1=\u0026gt;subroutine: 子流程 io=\u0026gt;inputoutput: 输入输出框 e=\u0026gt;end: 结束框 st-\u0026gt;op-\u0026gt;cond cond(yes)-\u0026gt;io-\u0026gt;e cond(no)-\u0026gt;sub1(right)-\u0026gt;op 4. 标准流程图源码格式（横向）：\nst=\u0026gt;start: 开始框 op=\u0026gt;operation: 处理框 cond=\u0026gt;condition: 判断框(是或否?) sub1=\u0026gt;subroutine: 子流程 io=\u0026gt;inputoutput: 输入输出框 e=\u0026gt;end: 结束框 st(right)-\u0026gt;op(right)-\u0026gt;cond cond(yes)-\u0026gt;io(bottom)-\u0026gt;e cond(no)-\u0026gt;sub1(right)-\u0026gt;op 5. UML时序图源码样例：\n对象A-\u0026gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--\u0026gt;对象A: 我很好(响应) 对象A-\u0026gt;对象B: 你真的好吗？ 6. UML时序图源码复杂样例：\nTitle: 标题：复杂使用 对象A-\u0026gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--\u0026gt;对象A: 我很好(响应) 对象B-\u0026gt;小三: 你好吗 小三--\u0026gt;\u0026gt;对象A: 对象B找我了 对象A-\u0026gt;对象B: 你真的好吗？ Note over 小三,对象B: 我们是朋友 participant C Note right of C: 没人陪我玩 7. UML标准时序图样例：\n%% 时序图例子,-\u0026gt; 直线，--\u0026gt;虚线，-\u0026gt;\u0026gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-\u0026gt;王五: 王五你好吗？ loop 健康检查 王五-\u0026gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 \u0026lt;br/\u0026gt;看医生... 李四--\u0026gt;\u0026gt;张三: 很好! 王五-\u0026gt;李四: 你怎么样? 李四--\u0026gt;王五: 很好!  菜鸟教程 \u0026ndash; 早点歇息\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","description":"","id":14,"section":"posts","tags":["markdown"],"title":"Markdown显示","uri":"https://yslinwe.github.io/posts/markdown/markdown%E6%98%BE%E7%A4%BA/"},{"content":"一级标题 ======= 二级标题 ------- # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 ## Markdown 段落 Runoob.com Google.com ### 字体 *斜体字体* **粗体** ***斜粗体*** ### 分割线 *** ******* ### 删除线 ~~baidu.com~~ `双波浪线是英文字符` ### 下划线 \u0026lt;u\u0026gt;带下划线\u0026lt;/u\u0026gt; ### 脚注 格式 [^要注明的文本] 创建脚注格式类似这样[^RunooB] [^RunooB]: 菜鸟教程 -- 早点歇息 ## Markdown 列表 ##### 无序 * 第一 * 第二 * 第三 + 第一 + 第二 + 第三 - 第一 - 第二 - 第三 ##### 有序 1. 第一 2. 第二 3. 第三 ##### 列表嵌套 1. 第一项 * 第一项嵌套的第一个元素 * 第一项嵌套的第二个元素 2. 第二项 * 第二项嵌套的第一个元素 * 第二项嵌套的第二个元素 ## Markdown 区块 \u0026gt; 区块引用 \u0026gt; 菜鸟教程 \u0026gt; 学的不仅是技术更是梦想 ##### 区块嵌套 \u0026gt; 最外层 \u0026gt; \u0026gt; 第一层嵌套 \u0026gt; \u0026gt; \u0026gt; 第二层嵌套 ##### 区块中列表 \u0026gt; 1. 第一项 \u0026gt; 2. 第二项 \u0026gt; * 第一项 \u0026gt; * 第二项 \u0026gt; * 第三项 ##### 列表中使用区块 * 第一项 \u0026gt; 菜鸟教程 \u0026gt; 学的不仅是技术更是梦想 * 第二项 ## Markdown 代码 `printf()` 函数 \u0026lt;?php echo 'RUNOOB'; function test(){ echo 'test' } 可以指定一种语言或者不指定 ```javascript $(document).ready(function()){ alert('RUNOOB'); }); ```python print(\u0026quot;hello world\u0026quot;) ## Markdown 链接 ##### 格式 [链接名称](链接地址) 这个是一个链接 [菜鸟教程](https://runoob.com) 直接使用链接 \u0026lt;https://runoob.com\u0026gt; ##### 高级链接 这个链接用 1 作为网址变量 [Google][1] 这个链接用 runoob 作为网址变量 [Runoob][runoob] 注意至少空一行 [runoob]:http://www.runoob.com [1]:http://www.google.com/ ## Markdown 图片 ##### 格式 ![alt 属性文本](图片地址) ![alt 属性文本](图片地址 \u0026quot;可选标题\u0026quot;) 使用实例： ![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png) ![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png \u0026quot;RUNOOB\u0026quot;) ![](./image/1.jpeg) \u0026lt;img src=\u0026quot;./image/1.jpeg\u0026quot; width=\u0026quot;20%\u0026quot;\u0026gt; \u0026lt;img src=\u0026quot;./image/1.jpeg\u0026quot; height=\u0026quot;10%\u0026quot;\u0026gt; 图片地址引用： 这个链接用 1 作为网址变量[RUNOOB][2] [2]:http://static.runoob.com/images/runoob-logo.png **指定图片的高度 宽度** \u0026lt;img src=\u0026quot;http://static.runoob.com/images/runoob-logo.png\u0026quot; width=\u0026quot;20%\u0026quot;\u0026gt; \u0026lt;img src=\u0026quot;http://static.runoob.com/images/runoob-logo.png\u0026quot; height=\u0026quot;20%\u0026quot;\u0026gt; ## Markdown 表格 Markdown 制作表格使用 | 来分隔不同的单元格 使用 - 来分隔表头和其它行 |表头|表头| |-|-| |单元格|单元格| |单元格|单元格| 对齐方式： * -: 设置右对齐 * :- 设置左对齐 * :-: 设置居中对齐 |左对齐|右对齐|居中对齐| |:-|-:|:-:| |单元格|单元格|单元格| |单元格|单元格|单元格| ## Markdown 高级技巧 支持的**HTML**元素 目前支持的HTML元素有： `\u0026lt;kbd\u0026gt; \u0026lt;b\u0026gt; \u0026lt;i\u0026gt; \u0026lt;em\u0026gt; \u0026lt;sup\u0026gt; \u0026lt;sub\u0026gt; \u0026lt;br\u0026gt;` 等 使用\u0026lt;kbd\u0026gt;Ctrl\u0026lt;/kbd\u0026gt;+\u0026lt;kbd\u0026gt;Alt\u0026lt;/kbd\u0026gt;+\u0026lt;kbd\u0026gt;Del\u0026lt;/kbd\u0026gt; 重启电脑 \u0026gt;\u0026lt;i\u0026gt; 斜体\u0026lt;/i\u0026gt; \u0026lt;em\u0026gt;斜体\u0026lt;/em\u0026gt; 图片\u0026lt;sup\u0026gt;上移动\u0026lt;/sup\u0026gt; 图片\u0026lt;sub\u0026gt;下移动\u0026lt;/sub\u0026gt; `\u0026lt;br\u0026gt;我换行了` \u0026lt;br\u0026gt;我换行了 ##### **加反斜杆转义特殊字符** \u0026gt;\\*\\* 正常显示星号 \\*\\* **Markdown 支持以下符号加上反斜杠变成普通字符** \u0026gt;\\\\反斜线 \\` 反引号 \u0026gt;\\* 星号 \u0026gt;\\_ 下划线 \u0026gt;\\{} 花括号 \u0026gt;\\[] 方括号 \u0026gt;\\() 小括号 \u0026gt;\\# 井字号 \u0026gt;\\+ 加号 \u0026gt;\\- 减号 \u0026gt;\\. 英文句号 \u0026gt;\\! 感叹号 **1. 横向流程图源码格式：** ```mermaid graph LR A[方形] --\u0026gt;B(圆角) B --\u0026gt; C{条件a} C --\u0026gt;|a=1| D[结果1] C --\u0026gt;|a=2| E[结果2] F[横向流程图] **2. 竖向流程图源码格式：** ```mermaid graph TD A[方形] --\u0026gt; B(圆角) B --\u0026gt; C{条件a} C --\u0026gt; |a=1| D[结果1] C --\u0026gt; |a=2| E[结果2] F[竖向流程图] **3. 标准流程图源码格式：** ```flow st=\u0026gt;start: 开始框 op=\u0026gt;operation: 处理框 cond=\u0026gt;condition: 判断框(是或否?) sub1=\u0026gt;subroutine: 子流程 io=\u0026gt;inputoutput: 输入输出框 e=\u0026gt;end: 结束框 st-\u0026gt;op-\u0026gt;cond cond(yes)-\u0026gt;io-\u0026gt;e cond(no)-\u0026gt;sub1(right)-\u0026gt;op **4. 标准流程图源码格式（横向）：** ```flow st=\u0026gt;start: 开始框 op=\u0026gt;operation: 处理框 cond=\u0026gt;condition: 判断框(是或否?) sub1=\u0026gt;subroutine: 子流程 io=\u0026gt;inputoutput: 输入输出框 e=\u0026gt;end: 结束框 st(right)-\u0026gt;op(right)-\u0026gt;cond cond(yes)-\u0026gt;io(bottom)-\u0026gt;e cond(no)-\u0026gt;sub1(right)-\u0026gt;op **5. UML时序图源码样例：** ```sequence 对象A-\u0026gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--\u0026gt;对象A: 我很好(响应) 对象A-\u0026gt;对象B: 你真的好吗？ **6. UML时序图源码复杂样例：** ```sequence Title: 标题：复杂使用 对象A-\u0026gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--\u0026gt;对象A: 我很好(响应) 对象B-\u0026gt;小三: 你好吗 小三--\u0026gt;\u0026gt;对象A: 对象B找我了 对象A-\u0026gt;对象B: 你真的好吗？ Note over 小三,对象B: 我们是朋友 participant C Note right of C: 没人陪我玩 **7. UML标准时序图样例：** ```mermaid %% 时序图例子,-\u0026gt; 直线，--\u0026gt;虚线，-\u0026gt;\u0026gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-\u0026gt;王五: 王五你好吗？ loop 健康检查 王五-\u0026gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 \u0026lt;br/\u0026gt;看医生... 李四--\u0026gt;\u0026gt;张三: 很好! 王五-\u0026gt;李四: 你怎么样? 李四--\u0026gt;王五: 很好! ","description":"","id":15,"section":"posts","tags":["markdown"],"title":"MarkdownLearn","uri":"https://yslinwe.github.io/posts/markdown/markdownlearn/"},{"content":"牛客网IO练习 https://ac.nowcoder.com/acm/contest/5657#question\n计算a+b (1) 题目描述 打开以下链接可以查看正确的代码\n https://ac.nowcoder.com/acm/contest/5657#question\n 输入描述:  输入包括两个正整数a,b(1 \u0026lt;= a, b \u0026lt;= 10^9),输入数据包括多组。\n 输出描述:  输出a+b的结果\n 示例1 输入  1 5\n10 20\n 输出  6\n30\n 1 2 3 4 5 6 7 8 9  #include\u0026lt;iostream\u0026gt;using namespace std; int main(){ int a, b; while(cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b) cout\u0026lt;\u0026lt;a+b\u0026lt;\u0026lt;endl; return 0; }   计算a+b (2) 题目描述 计算a+b\n打开以下链接可以查看正确的代码\n https://ac.nowcoder.com/acm/contest/5657#question\n 输入描述:  输入第一行包括一个数据组数t(1 \u0026lt;= t \u0026lt;= 100)\n接下来每行包括两个正整数a,b(1 \u0026lt;= a, b \u0026lt;= 10^9)\n 输出描述:  输出a+b的结果\n 示例1 输入  2\n1 5\n10 20\n 输出  6\n30\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include\u0026lt;iostream\u0026gt;using namespace std; int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--){ int a, b; while(cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b) cout\u0026lt;\u0026lt;a+b\u0026lt;\u0026lt;endl; } return 0; }   计算a+b (3) 题目描述 计算a+b\n打开以下链接可以查看正确的代码\n https://ac.nowcoder.com/acm/contest/5657#question\n 输入描述:  输入包括两个正整数a,b(1 \u0026lt;= a, b \u0026lt;= 10^9),输入数据有多组, 如果输入为0 0则结束输入\n 输出描述:  输出a+b的结果\n 示例1 输入  1 5\n10 20\n0 0\n 输出  6\n30\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include\u0026lt;iostream\u0026gt;using namespace std; int main(){ int a, b; while(cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b){ if(a==0\u0026amp;\u0026amp;b==0) break; cout\u0026lt;\u0026lt;a+b\u0026lt;\u0026lt;endl; } return 0; }   计算a+b (4) 题目描述 计算一系列数的和\n打开以下链接可以查看正确的代码\n https://ac.nowcoder.com/acm/contest/5657#question\n 输入描述:  输入数据包括多组。\n每组数据一行,每行的第一个整数为整数的个数n(1 \u0026lt;= n \u0026lt;= 100), n为0的时候结束输入。\n接下来n个正整数,即需要求和的每个正整数。\n 输出描述:  每组数据输出求和的结果\n 示例1 输入  4 1 2 3 4\n5 1 2 3 4 5\n0\n 输出  10\n15\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include\u0026lt;iostream\u0026gt;using namespace std; int main(){ int n; while(cin\u0026gt;\u0026gt;n){ if(n==0) break; int sum = 0,temp; while(n--){ cin\u0026gt;\u0026gt;temp; sum += temp; } cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } return 0; }   计算a+b (5) 题目描述 计算一系列数的和\n打开以下链接可以查看正确的代码\n https://ac.nowcoder.com/acm/contest/5657#question\n 输入描述:  输入的第一行包括一个正整数t(1 \u0026lt;= t \u0026lt;= 100), 表示数据组数。\n接下来t行, 每行一组数据。\n每行的第一个整数为整数的个数n(1 \u0026lt;= n \u0026lt;= 100)。\n接下来n个正整数, 即需要求和的每个正整数。\n 输出描述: 每组数据输出求和的结果\n示例1 输入  2\n4 1 2 3 4\n5 1 2 3 4 5\n 输出  10\n15\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include\u0026lt;iostream\u0026gt;using namespace std; int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--){ int n; cin\u0026gt;\u0026gt;n; int sum = 0,temp; while(n--){ cin\u0026gt;\u0026gt;temp; sum += temp; } cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } return 0; }   计算a+b (6) 题目描述 计算一系列数的和\n打开以下链接可以查看正确的代码\n https://ac.nowcoder.com/acm/contest/5657#question\n 输入描述:  输入数据有多组, 每行表示一组输入数据。\n每行的第一个整数为整数的个数n(1 \u0026lt;= n \u0026lt;= 100)。\n接下来n个正整数, 即需要求和的每个正整数。\n 输出描述:  每组数据输出求和的结果\n 示例1 输入  4 1 2 3 4\n5 1 2 3 4 5\n 输出  10\n15\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include\u0026lt;iostream\u0026gt;using namespace std; int main(){ int t; while(cin\u0026gt;\u0026gt;t){ int sum = 0; while(t--){ int temp; cin\u0026gt;\u0026gt;temp; sum += temp; } cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } return 0; }   计算a+b (7) 题目描述 计算一系列数的和\n打开以下链接可以查看正确的代码\n https://ac.nowcoder.com/acm/contest/5657#question\n 输入描述:  输入数据有多组, 每行表示一组输入数据。\n每行不定有n个整数，空格隔开。(1 \u0026lt;= n \u0026lt;= 100)。\n 输出描述:  每组数据输出求和的结果\n 示例1 输入  1 2 3\n4 5\n0 0 0 0 0\n 输出  6\n9\n0\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #include\u0026lt;iostream\u0026gt;using namespace std; int main(){ int temp,sum = 0; while(cin\u0026gt;\u0026gt;temp){ sum += temp; if(cin.get()==\u0026#39;\\n\u0026#39;){ cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; sum = 0; } } return 0; }   字符串排序（1） 题目描述 对输入的字符串进行排序后输出\n打开以下链接可以查看正确的代码\n https://ac.nowcoder.com/acm/contest/5657#question\n 输入描述:  输入有两行，第一行n\n第二行是n个空格隔开的字符串\n 输出描述:  输出一行排序后的字符串，空格隔开，无结尾空格\n 示例1 输入  5\nc d a bb e\n 输出  a bb c d e\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; int main() { int n; string *pstr; vector\u0026lt;string\u0026gt; que; cin \u0026gt;\u0026gt; n; pstr = new string[n]; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; pstr[i]; que.push_back(pstr[i]); } sort(que.begin(), que.end()); for (int i = 0; i \u0026lt; n; i++) { cout \u0026lt;\u0026lt; que[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }   字符串排序 （2） 题目描述 对输入的字符串进行排序后输出\n打开以下链接可以查看正确的代码\n https://ac.nowcoder.com/acm/contest/5657#question\n 输入描述:  多个测试用例，每个测试用例一行。\n每行通过空格隔开，有n个字符，n＜100\n 输出描述:  对于每组测试用例，输出一行排序过的字符串，每个字符串通过空格隔开\n 示例1 输入  a c bb\nf dddd\nnowcoder\n 输出  a bb c\ndddd f\nnowcoder\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  #include\u0026lt;iostream\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;algorithm\u0026gt;using namespace std; int main() { string str; vector\u0026lt;string\u0026gt; s; while(cin\u0026gt;\u0026gt;str) { s.push_back(str); if(cin.get()==\u0026#39;\\n\u0026#39;) { sort(s.begin(), s.end()); int n = s.size(); for(int i = 0;i\u0026lt;n;i++) { cout\u0026lt;\u0026lt;s[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } s.clear(); cout\u0026lt;\u0026lt;endl; } } }   字符串排序 （3） 题目描述 对输入的字符串进行排序后输出\n打开以下链接可以查看正确的代码\n https://ac.nowcoder.com/acm/contest/5657#question\n 输入描述:  多个测试用例，每个测试用例一行。\n每行通过,隔开，有n个字符，n＜100\n 输出描述:  对于每组用例输出一行排序后的字符串，用',\u0026lsquo;隔开，无结尾空格\n 示例1 输入  a,c,bb\nf,dddd\nnowcoder\n 输出  a,bb,c\ndddd,f\nnowcoder\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  #include\u0026lt;iostream\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;sstream\u0026gt; using namespace std; int main() { string line; string str; vector\u0026lt;string\u0026gt; s; while(cin\u0026gt;\u0026gt;line) { stringstream ss(line); while(getline(ss, str, \u0026#39;,\u0026#39;)) { s.push_back(str); } sort(s.begin(),s.end()); if(s.size()==1) cout\u0026lt;\u0026lt;s[0]; else for(int i = 0;i\u0026lt;s.size();i++) { if(i!=s.size()-1) cout\u0026lt;\u0026lt;s[i]\u0026lt;\u0026lt;\u0026#39;,\u0026#39;; else cout\u0026lt;\u0026lt;s[i]; } s.clear(); cout\u0026lt;\u0026lt;endl; } }   ","description":"","id":16,"section":"posts","tags":["牛客网"],"title":"C++IO牛客网","uri":"https://yslinwe.github.io/posts/c++io%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0/"},{"content":"Mac启动台App问号 1 2  defaults write com.apple.dock ResetLaunchPad -bool TRUE killall Dock   ","description":"","id":17,"section":"posts","tags":["Mac"],"title":"Mac启动台App问号","uri":"https://yslinwe.github.io/posts/mac/mac%E5%90%AF%E5%8A%A8%E5%8F%B0app%E9%97%AE%E5%8F%B7/"},{"content":"方法一：   第一步：打开「终端」应用程序。\n  第二步：输入如下命令：\n  1  defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder   第三步：按下「Return」键确认。  现在你将会在 Finder 窗口中看到那些隐藏的文件和文件夹了。\n如果你想再次隐藏原本的隐藏文件和文件夹的话，将上述命令替换成\n1  defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder   即可。\n方法二： Finder界面是，最上方，通过“前往”进入“电脑”或文件夹，\n先进入到需要显示隐藏文件的文件夹下\n接着按Command苹果键+F,在窗格上会显示搜索栏\n然后将第一个下列选择项“种类kind”选择为“其它Other”，当选择“其它”时，\n弹出新的搜索窗口，找到下面的“文件不可见File invisible”项，\n勾上后面的对勾，再单击“好OK”即可，返回文件夹，就可以看到，\n隐藏的文件已经显示出来了\n","description":"","id":18,"section":"posts","tags":["Mac"],"title":"Mac上显示和隐藏文件","uri":"https://yslinwe.github.io/posts/mac/mac%E4%B8%8A%E6%98%BE%E7%A4%BA%E5%92%8C%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/"},{"content":"题目描述 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: void ConvertNode(TreeNode* crruentNode,TreeNode* \u0026amp;lastNode) { if(crruentNode==NULL) return; ConvertNode(crruentNode-\u0026gt;left,lastNode); crruentNode-\u0026gt;left = lastNode; if(lastNode!=NULL) lastNode-\u0026gt;right = crruentNode; lastNode = crruentNode; ConvertNode(crruentNode-\u0026gt;right,lastNode); } TreeNode* Convert(TreeNode* pRootOfTree) { TreeNode *lastNode = NULL; if(pRootOfTree==NULL) return pRootOfTree; ConvertNode(pRootOfTree,lastNode); while(pRootOfTree-\u0026gt;left!=NULL) { pRootOfTree = pRootOfTree-\u0026gt;left; } return pRootOfTree; } };   ","description":"剑指office（二十六）二叉树搜索树与双向链表","id":19,"section":"posts","tags":["剑指office"],"title":"剑指office（二十六）二叉树搜索树与双向链表","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/26%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"},{"content":"题目描述 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  /* struct RandomListNode { int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) { } }; */ class Solution { public: void Copy(RandomListNode* pHead) { RandomListNode* temp; while(pHead!=NULL) { temp = pHead-\u0026gt;next; RandomListNode* pNode = new RandomListNode(pHead-\u0026gt;label); pNode-\u0026gt;next = temp; pNode-\u0026gt;random = NULL; pHead-\u0026gt;next = pNode; pHead = temp; } } void AddRandom(RandomListNode* pHead) { while (pHead!=NULL) { if(pHead-\u0026gt;random!=NULL) { pHead-\u0026gt;next-\u0026gt;random = pHead-\u0026gt;random-\u0026gt;next; } if(pHead-\u0026gt;next!=NULL) pHead = pHead-\u0026gt;next-\u0026gt;next; } } RandomListNode* Detch(RandomListNode* pHead) { RandomListNode* pNode = pHead; RandomListNode* pCloneHead = NULL; RandomListNode* pClone = NULL; if(pNode != NULL){ pCloneHead = pNode-\u0026gt;next; pClone = pCloneHead; pNode-\u0026gt;next = pCloneHead-\u0026gt;next; pNode = pNode-\u0026gt;next; } while (pNode!=NULL) { pClone-\u0026gt;next = pNode-\u0026gt;next; pClone = pClone-\u0026gt;next; pNode-\u0026gt;next = pClone-\u0026gt;next; pNode = pNode-\u0026gt;next; } return pCloneHead; } RandomListNode* Clone(RandomListNode* pHead) { Copy(pHead); AddRandom(pHead); return Detch(pHead); } };   ","description":"剑指office（二十五）复杂链表的复制","id":20,"section":"posts","tags":["剑指office"],"title":"剑指office（二十五）复杂链表的复制","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/25%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"},{"content":"题目描述 输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。\n示例1 输入 {10,5,12,4,7},22 返回值 [[10,5,7],[10,12]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; FindPath(TreeNode* root,int expectNumber) { if(root==NULL) { return result; } temp.push_back(root-\u0026gt;val); if((expectNumber-root-\u0026gt;val)==0\u0026amp;\u0026amp;root-\u0026gt;left==NULL\u0026amp;\u0026amp;root-\u0026gt;right==NULL)//叶结点  result.push_back(temp); if(expectNumber-root-\u0026gt;val\u0026lt;0) temp.pop_back(); FindPath(root-\u0026gt;left, expectNumber-root-\u0026gt;val); FindPath(root-\u0026gt;right, expectNumber-root-\u0026gt;val); if(temp.size()\u0026gt;1) temp.pop_back();//栈回退  return result; } private: vector\u0026lt;int\u0026gt; temp; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; };   ","description":"剑指office（二十四）二叉树中和为某一值的路径","id":21,"section":"posts","tags":["剑指office"],"title":"剑指office（二十四）二叉树中和为某一值的路径","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/24%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"},{"content":"题目描述 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。（ps：我们约定空树不是二叉搜素树）\n示例1 输入 [4,8,6,12,16,14,10] 返回值 true 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  class Solution { public: bool VerifySquenceOfBST(vector\u0026lt;int\u0026gt; sequence) { if(sequence.empty()) return false; int end = *(sequence.end()-1); bool result = true; vector\u0026lt;int\u0026gt; left; vector\u0026lt;int\u0026gt; right; vector\u0026lt;int\u0026gt;::iterator iter = sequence.begin(); for(;iter!=sequence.end()-1;iter++) if(end\u0026lt;*iter) break; vector\u0026lt;int\u0026gt;::iterator splitP = iter; for(;iter!=sequence.end()-1;iter++) if(end\u0026gt;*iter) return false; vector\u0026lt;int\u0026gt;::iterator bei = sequence.begin(); left.insert(left.end(),sequence.begin(),splitP); right.insert(right.end(),splitP,sequence.end()-1); bool leftFlag = (left.size()\u0026gt;1)?VerifySquenceOfBST(left):result; bool rightFlag = (right.size()\u0026gt;1)?VerifySquenceOfBST(right):result; return leftFlag\u0026amp;\u0026amp;rightFlag; } };   ","description":"剑指office（二十三）二叉树搜索树的后序遍历序列","id":22,"section":"posts","tags":["剑指office"],"title":"剑指office（二十三）二叉树搜索树的后序遍历序列","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/23%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"},{"content":"题目描述 从上往下打印出二叉树的每个节点，同层节点从左至右打印。\n示例1 输入 {5,4,#,3,#,2,#,1} 返回值 [5,4,3,2,1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: vector\u0026lt;int\u0026gt; PrintFromTopToBottom(TreeNode* root) { vector\u0026lt;int\u0026gt; result; if(root==NULL) return result; result.push_back(root-\u0026gt;val); PrintLeftToRight(result,root); return result; } void PrintLeftToRight(vector\u0026lt;int\u0026gt;\u0026amp;result,TreeNode* root) { if(root==NULL||root-\u0026gt;left==NULL\u0026amp;\u0026amp;root-\u0026gt;right==NULL) return; if(root-\u0026gt;left) result.push_back(root-\u0026gt;left-\u0026gt;val); if(root-\u0026gt;right) result.push_back(root-\u0026gt;right-\u0026gt;val); PrintLeftToRight(result,root-\u0026gt;left); PrintLeftToRight(result,root-\u0026gt;right); } };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: vector\u0026lt;int\u0026gt; PrintFromTopToBottom(TreeNode* root) { vector\u0026lt;int\u0026gt; result; if(root==NULL) return result; queue\u0026lt;TreeNode*\u0026gt; nodeQ; nodeQ.push(root); while(!nodeQ.empty()) { TreeNode* cur = nodeQ.front(); nodeQ.pop(); result.push_back(cur-\u0026gt;val); if(cur-\u0026gt;left)nodeQ.push(cur-\u0026gt;left); if(cur-\u0026gt;right)nodeQ.push(cur-\u0026gt;right); } return result; } };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: vector\u0026lt;int\u0026gt; PrintFromTopToBottom(TreeNode* root) { vector\u0026lt;int\u0026gt; result; if(root==NULL) return result; queue\u0026lt;TreeNode*\u0026gt; nodeQ; nodeQ.push(root); int level = 0; while(!nodeQ.empty()) { int qS = nodeQ.size(); while(qS--) { TreeNode* cur = nodeQ.front(); nodeQ.pop(); result.push_back(cur-\u0026gt;val); if(cur-\u0026gt;left)nodeQ.push(cur-\u0026gt;left); if(cur-\u0026gt;right)nodeQ.push(cur-\u0026gt;right); } level++; } return result; } };   ","description":"剑指office（二十二）从上往下打印二叉树","id":23,"section":"posts","tags":["剑指office"],"title":"剑指office（二十二）从上往下打印二叉树","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/22%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"content":"题目描述 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）\n示例1 输入 [1,2,3,4,5],[4,3,5,1,2] 返回值 false 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  class Solution { public: bool IsPopOrder(vector\u0026lt;int\u0026gt; pushV,vector\u0026lt;int\u0026gt; popV) { bool result = false; stack\u0026lt;int\u0026gt; leftS; stack\u0026lt;int\u0026gt; rightS; int pushVSize = pushV.size(); int popVSize = popV.size(); int j = 0; bool isLeft = true; for(int i = 0;i\u0026lt;pushVSize;i++) { if(pushV[i] == popV[j]) { j++; isLeft = !isLeft; }else { if(isLeft) leftS.push(pushV[i]); else rightS.push(pushV[i]); } } if(j\u0026gt;=popVSize) return true; int left = 0; int right = 0; while(j\u0026lt;popVSize) { left = leftS.empty()?NULL:leftS.top(); right = rightS.empty()?NULL:rightS.top(); if(popV[j]==left) { leftS.pop(); result = true; } else if(popV[j]==right) { rightS.pop(); result = true; } else { result = false; break; } j++; } return result; } };   ","description":"剑指office（二十一）栈的压入、弹出序列","id":24,"section":"posts","tags":["剑指office"],"title":"剑指office（二十一）栈的压入、弹出序列","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/21%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"},{"content":"题目描述 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class Solution { public: stack\u0026lt;int\u0026gt; v; stack\u0026lt;int\u0026gt; minV; void push(int value) { v.push(value); if(minV.empty()) minV.push(value); if(minV.top()\u0026gt;value) { minV.push(value); } } void pop() { if(v.top()==minV.top()) minV.pop(); v.pop(); } int top() { return v.top(); } int min() { return minV.top(); } };   ","description":"剑指office（二十）包含min函数的栈","id":25,"section":"posts","tags":["剑指office"],"title":"剑指office（二十）包含min函数的栈","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/20%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"},{"content":"题目描述 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.\n示例1 输入 [[1,2],[3,4]] 返回值 [1,2,4,3] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  class Solution { public: vector\u0026lt;int\u0026gt; printMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; matrix) { vector\u0026lt;int\u0026gt; result; int cols = matrix[0].size(); int rows = matrix.size()-1; int startCol = 0; int startRow = 0; if(rows \u0026lt; 0 \u0026amp;\u0026amp; cols == 0) return result; if(cols==1) { for(int i= 0;i\u0026lt;=rows;i++) result.push_back(matrix[i][0]); return result; } if(rows==0) { for(int i= 0;i\u0026lt;cols;i++) result.push_back(matrix[0][i]); return result; } while(cols-startCol\u0026gt;0\u0026amp;\u0026amp;rows-startRow\u0026gt;=0) { for(int i = startCol;i\u0026lt;cols;i++) { result.push_back(matrix[startRow][i]); } for(int i = startRow+1;i\u0026lt;rows;i++) { result.push_back(matrix[i][cols-1]); } if(rows-startRow\u0026gt;0) for(int i = cols-1;i\u0026gt;=startCol;i--) { result.push_back(matrix[rows][i]); } if(cols-startCol\u0026gt;1) for(int i = rows-1;i\u0026gt;startRow;i--) { result.push_back(matrix[i][startCol]); } startCol++; startRow++; cols = cols-1; rows = rows-1; } return result; } };   ","description":"剑指office（十九）顺时针打印矩阵","id":26,"section":"posts","tags":["剑指office"],"title":"剑指office（十九）顺时针打印矩阵","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/19%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"},{"content":"题目描述 操作给定的二叉树，将其变换为源二叉树的镜像。\n比如： 源二叉树 8 / \\ 6 10 / \\ / \\ 5 7 9 11 镜像二叉树 8 / \\ 10 6 / \\ / \\ 11 9 7 5 示例1 输入 {8,6,10,5,7,9,11} 返回值 {8,10,6,11,9,7,5} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  /** * struct TreeNode { *\tint val; *\tstruct TreeNode *left; *\tstruct TreeNode *right; *\tTreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * }; */ class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param pRoot TreeNode类 * @return TreeNode类 */ TreeNode* Mirror(TreeNode* pRoot) { // write code here  if(pRoot==NULL||(pRoot-\u0026gt;left==NULL\u0026amp;\u0026amp;pRoot-\u0026gt;right==NULL)) return pRoot; swapNode(pRoot); Mirror(pRoot-\u0026gt;left); Mirror(pRoot-\u0026gt;right); return pRoot; } void swapNode(TreeNode* pRoot) { TreeNode* tempVal = pRoot-\u0026gt;left; pRoot-\u0026gt;left = pRoot-\u0026gt;right; pRoot-\u0026gt;right = tempVal; } };   ","description":"剑指office（十八）二叉树的镜像","id":27,"section":"posts","tags":["剑指office"],"title":"剑指office（十八）二叉树的镜像","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/18%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"},{"content":"题目描述 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）\n示例1 输入 {8,8,#,9,#,2,#,5},{8,9,#,2} 返回值 true 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) { bool result = false; if(pRoot1!=NULL\u0026amp;\u0026amp;pRoot2!=NULL) { if(pRoot1-\u0026gt;val==pRoot2-\u0026gt;val) result = isSame(pRoot1,pRoot2); if(!result) result = HasSubtree(pRoot1-\u0026gt;left, pRoot2); if(!result) result = HasSubtree(pRoot1-\u0026gt;right, pRoot2); } return result; } bool isSame(TreeNode* pRoot1,TreeNode* pRoot2) { if(pRoot2==NULL) return true; if(pRoot1==NULL) return false; if(pRoot1-\u0026gt;val!=pRoot2-\u0026gt;val) return false; else return isSame(pRoot1-\u0026gt;left, pRoot2-\u0026gt;left)\u0026amp;\u0026amp;isSame(pRoot1-\u0026gt;right, pRoot2-\u0026gt;right); } };   ","description":"剑指office（十七）树的子结构","id":28,"section":"posts","tags":["剑指office"],"title":"剑指office（十七）树的子结构","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/17%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"},{"content":"题目描述 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。\n示例1 输入 {1,3,5},{2,4,6} 返回值 {1,2,3,4,5,6} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) { ListNode* result = NULL; ListNode* cur = NULL; if(!pHead1) return pHead2; if(!pHead2) return pHead1; while(pHead1||pHead2) { if(pHead1\u0026amp;\u0026amp;pHead2) { if(pHead1-\u0026gt;val\u0026gt;=pHead2-\u0026gt;val) { ListNode* temp = pHead2-\u0026gt;next; if(!result) { result = pHead2; cur = result; } else { result-\u0026gt;next = pHead2; result = result-\u0026gt;next; } pHead2 = temp; } else { ListNode* temp = pHead1-\u0026gt;next; if(!result) { result = pHead1; cur = result; } else { result-\u0026gt;next = pHead1; result = result-\u0026gt;next; } pHead1 = temp; } } else { if(pHead1) { result-\u0026gt;next = pHead1; } else { result-\u0026gt;next = pHead2; } break; } } return cur; } };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) { ListNode* result = new ListNode(-1); ListNode* cur = result; if(!pHead1) return pHead2; if(!pHead2) return pHead1; while(pHead1||pHead2) { if(pHead1\u0026amp;\u0026amp;pHead2) { if(pHead1-\u0026gt;val\u0026gt;=pHead2-\u0026gt;val) { result-\u0026gt;next = pHead2; pHead2 = pHead2-\u0026gt;next; } else { result-\u0026gt;next = pHead1; pHead1 = pHead1-\u0026gt;next; } result = result-\u0026gt;next; } else { result-\u0026gt;next = pHead1?pHead1:pHead2; break; } } return cur-\u0026gt;next; } };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) { if(!pHead1) return pHead2; if(!pHead2) return pHead1; if(pHead1-\u0026gt;val\u0026gt;=pHead2-\u0026gt;val) { pHead2-\u0026gt;next = Merge(pHead1,pHead2-\u0026gt;next); return pHead2; }else { pHead1-\u0026gt;next = Merge(pHead1-\u0026gt;next, pHead2); return pHead1; } } };   ","description":"剑指office（十六）合并两个排序的链表","id":29,"section":"posts","tags":["剑指office"],"title":"剑指office（十六）合并两个排序的链表","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/16%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"},{"content":"题目描述 输入一个链表，反转链表后，输出新链表的表头。\n示例1 输入 {1,2,3} 返回值 {3,2,1} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* ReverseList(ListNode* pHead) { if (!pHead) return NULL; stack\u0026lt;ListNode*\u0026gt; stackNode; while(pHead) { stackNode.push(pHead); pHead = pHead-\u0026gt;next; } ListNode* result = stackNode.top(); stackNode.pop(); ListNode* cur = result; int S = stackNode.size(); for(int i = 0;i\u0026lt;S;i++) { cur-\u0026gt;next = stackNode.top(); stackNode.pop(); cur = cur-\u0026gt;next; } cur-\u0026gt;next = NULL; return result; } };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* ReverseList(ListNode* pHead) { ListNode* nextNode = NULL; ListNode* currentNode = pHead; ListNode* reverseNode = NULL; while(currentNode) { nextNode = currentNode-\u0026gt;next; currentNode-\u0026gt;next = reverseNode; reverseNode = currentNode; currentNode = nextNode; } return reverseNode; } };   ","description":"剑指office（十五）反转链表","id":30,"section":"posts","tags":["剑指office"],"title":"剑指office（十五）反转链表","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/15%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"content":"题目描述 输入一个链表，输出该链表中倒数第k个结点。\n如果该链表长度小于k，请返回空。\n示例1 输入 {1,2,3,4,5},1 返回值 {5} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  /** * struct ListNode { *\tint val; *\tstruct ListNode *next; *\tListNode(int x) : val(x), next(nullptr) {} * }; */ class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param pHead ListNode类 * @param k int整型 * @return ListNode类 */ ListNode* FindKthToTail(ListNode* pHead, int k) { // write code here  ListNode *result = pHead; while(pHead\u0026amp;\u0026amp;k--) { pHead = pHead-\u0026gt;next; } if(k\u0026gt;0) return NULL; while(pHead) { pHead = pHead-\u0026gt;next; result = result-\u0026gt;next; } return result; } };   ","description":"剑指office（十四）链表中倒数第k个结点","id":31,"section":"posts","tags":["剑指office"],"title":"剑指office（十四）链表中倒数第k个结点","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/14%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/"},{"content":"题目描述 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。\n示例1 输入 [1,2,3,4] 返回值 [1,3,2,4] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param array int整型vector * @return int整型vector */ vector\u0026lt;int\u0026gt; reOrderArray(vector\u0026lt;int\u0026gt;\u0026amp; array) { // write code here  for(int i=0;i\u0026lt;array.size();i++) { if(array[i]\u0026amp;1) { int j = i; if(j\u0026gt;0) while(!(array[j-1]\u0026amp;1)) { swap(array[j],array[j-1]); j--; if(j==0) break; } } } return array; } };   ","description":"剑指office（十三）调整数组顺序使奇数位于偶数前面","id":32,"section":"posts","tags":["剑指office"],"title":"剑指office（十三）调整数组顺序使奇数位于偶数前面","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/13%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"},{"content":"题目描述 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。\n保证base和exponent不同时为0。不得使用库函数，同时不需要考虑大数问题，也不用考虑小数点后面0的位数。\n示例1 输入 2.00000,3 返回值 8.00000 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public: double Power(double base, int exponent) { if(exponent == 0) return 1.0; else { double result = 1; for(int i= 0;i\u0026lt;abs(exponent);i++) result *= base; if(exponent \u0026gt; 0) return result; else return 1/result; } } };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Solution { public: double Power(double base,int exponent) { if(exponent\u0026lt;0) { exponent = -exponent; base = 1/base; } return q_power(base,exponent); } double q_power(double base, int exponent) { if(exponent == 0) return 1.0; else { double result = q_power(base, exponent/2); if(exponent\u0026amp;1) { return result*result*base; } else { return result * result; } } } };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class Solution { public: double Power(double base,int exponent) { if(exponent\u0026lt;0) { exponent = -exponent; base = 1/base; } return q_power(base,exponent); } double q_power(double base,int exponent) { double result = 1; while(exponent) { if(exponent\u0026amp;1) { result *= base; } base *= base; exponent\u0026gt;\u0026gt;=1; } return result; } };   ","description":"剑指office（十二）数值的整数次方","id":33,"section":"posts","tags":["剑指office"],"title":"剑指office（十二）数值的整数次方","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/12%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"},{"content":"题目描述 输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。\n示例1 输入 10 返回值 2 1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution { public: int NumberOf1(int n) { int cout = 0; int mark = 0x01; while(mark) { if(mark\u0026amp;n)cout++; mark\u0026lt;\u0026lt;=1; } return cout; } };   1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public: int NumberOf1(int n) { int count = 0; while(n) { count++; n = (n-1)\u0026amp;n; } return count; } };   ","description":"剑指office（十一）二进制中1的个数","id":34,"section":"posts","tags":["剑指office"],"title":"剑指office（十一）二进制中1的个数","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/11%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"content":"题目描述 我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？\n比如n=3时，2*3的矩形块有3种覆盖方法：\n示例1 输入 4 返回值 5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public: int rectCover(int number) { if(number\u0026lt;=2) return number; int first = 1; int second = 2; int result = 0; for(int i = 3;i\u0026lt;=number;i++) { result = first + second; first = second; second = result; } return result; } };   ","description":"剑指office（十）矩形覆盖","id":35,"section":"posts","tags":["剑指office"],"title":"剑指office（十）矩形覆盖","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/10%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/"},{"content":"题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。\n示例1 输入 3 返回值 4 1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution { public: int jumpFloorII(int number) { if(number\u0026lt;2) return 1; int result = 1; for(int i = 1;i\u0026lt;number;i++) { result *= 2; } return result; } };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public: int jumpFloorII(int number) { if(number\u0026lt;2) return 1; vector\u0026lt;int\u0026gt; dp(number+1,0); dp[0]=dp[1]=1; for(int i = 2;i\u0026lt;=number;i++) { for(int j=0;j\u0026lt;i;j++) { dp[i] += dp[j]; } } return dp[number]; } };   1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution { public: int jumpFloorII(int number) { if(number\u0026lt;2) return 1; int result = 1; for(int i=2;i\u0026lt;=number;i++) { result = result\u0026lt;\u0026lt;1;//左移乘 右移除  } return result; } };   ","description":"剑指office（九）跳台阶扩展问题","id":36,"section":"posts","tags":["剑指office"],"title":"剑指office（九）跳台阶扩展问题","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/9%E8%B7%B3%E5%8F%B0%E9%98%B6%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98/"},{"content":"题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public: int jumpFloor(int number) { if(number\u0026lt;=2) return number; int first = 1; int second = 2; int result = 0; for(int i = 2;i\u0026lt;number;i++) { result = first + second; first = second; second = result; } return result; } };   ","description":"剑指office（八）跳台阶","id":37,"section":"posts","tags":["剑指office"],"title":"剑指office（八）跳台阶","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/8%E8%B7%B3%E5%8F%B0%E9%98%B6/"},{"content":"题目描述 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。\nn≤39n≤39\n示例1 输入 4 返回值 3 1 2 3 4 5 6 7 8  class Solution { public: int Fibonacci(int n) { if(n\u0026lt;2) return n; return Fibonacci(n-1)+Fibonacci(n-2); } };   ","description":"剑指office（七）用两个栈实现队列","id":38,"section":"posts","tags":["剑指office"],"title":"剑指office（七）用两个栈实现队列","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/7%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"},{"content":"题目描述 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。\n输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。\nNOTE：给出的所有元素都大于0，若数组大小为0，请返回0。\n示例1 输入 [3,4,5,1,2] 返回值 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution { public: int minNumberInRotateArray(vector\u0026lt;int\u0026gt; rotateArray) { if(rotateArray.size()==0) return 0; int first = 0; int last = rotateArray.size()-1; int mid = 0; while(last!=first) { mid = floor((first + last)/2); if(rotateArray[last]\u0026gt;rotateArray[mid]) last = mid; else if(rotateArray[first]\u0026lt;rotateArray[mid]) first = mid+1; else first++; } return rotateArray[last]; } };   ","description":"剑指office（六）用两个栈实现队列","id":39,"section":"posts","tags":["剑指office"],"title":"剑指office（六）用两个栈实现队列","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/6%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"},{"content":"题目描述 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Solution { public: void push(int node) { stack1.push(node); } int pop() { if(stack2.empty()\u0026amp;\u0026amp;!stack1.empty()) { int stackS = stack1.size(); for(int i =0;i\u0026lt;stackS;i++) { int temp = stack1.top(); stack1.pop(); stack2.push(temp); } } int val = stack2.top(); stack2.pop(); return val; } private: stack\u0026lt;int\u0026gt; stack1; stack\u0026lt;int\u0026gt; stack2; };   ","description":"剑指office（五）用两个栈实现队列","id":40,"section":"posts","tags":["剑指office"],"title":"剑指office（五）用两个栈实现队列","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/5%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"},{"content":"题目描述 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。\n示例1 输入 [1,2,3,4,5,6,7],[3,2,4,1,6,5,7] 返回值 {1,2,5,3,4,6,7} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  /** * Definition for binary tree * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* reConstructBinaryTree(vector\u0026lt;int\u0026gt; pre,vector\u0026lt;int\u0026gt; vin) { if(pre.size() == 0) {//如果为空，返回NULL  return NULL; } TreeNode* tempNode = new TreeNode(pre[0]); int root = pre[0]; vector\u0026lt;int\u0026gt;leftPre; vector\u0026lt;int\u0026gt;leftVin; vector\u0026lt;int\u0026gt;rightPre; vector\u0026lt;int\u0026gt;rightVin; bool leftFlag = true; int j = 1; for(int i = 0;i\u0026lt;vin.size();i++) { if(root == vin[i]) { leftFlag = false; continue; } if(leftFlag) { leftPre.push_back(pre[j]); leftVin.push_back(vin[i]); j++; } else { rightPre.push_back(pre[j]); rightVin.push_back(vin[i]); j++; } } tempNode-\u0026gt;left = reConstructBinaryTree(leftPre,leftVin); tempNode-\u0026gt;right = reConstructBinaryTree(rightPre,rightVin); return tempNode; } };   ","description":"剑指office（四）重建二叉树","id":41,"section":"posts","tags":["剑指office"],"title":"剑指office（四）重建二叉树","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/4%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"content":"题目描述 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。\n示例1 输入 {67,0,24,58} 返回值 [58,24,0,67] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  /** * struct ListNode { * int val; * struct ListNode *next; * ListNode(int x) : * val(x), next(NULL) { * } * }; */ class Solution { public: vector\u0026lt;int\u0026gt; printListFromTailToHead(ListNode* head) { stack\u0026lt;int\u0026gt; temp; while(head!=NULL) { temp.push(head-\u0026gt;val); head = head-\u0026gt;next; } vector\u0026lt;int\u0026gt; result; int tempS = temp.size(); for(int i = 0;i\u0026lt;tempS;i++) { result.push_back(temp.top()); temp.pop(); } return result; } };   ","description":"剑指office（三）从尾到头打印链表","id":42,"section":"posts","tags":["剑指office"],"title":"剑指office（三）从尾到头打印链表","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/3%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"},{"content":"OneDriveUploader - Written in GoLang  支持 国际版, 个人版(家庭版), 中国版(世纪互联). 支持上传文件和文件夹到指定目录,并保持上传前的目录结构. 支持命令参数使用, 方便外部程序调用. 支持自定义上传分块大小. 支持多线程上传(多文件同时上传). 支持根据文件大小动态调整重试次数 支持跳过网盘中已存在的同名文件.  授权 通过下面URL登录 (右键新标签打开) 国际版, 个人版(家庭版) https://login.microsoftonline.com/common/oauth2/v2.0/authorize?client_id=78d4dc35-7e46-42c6-9023-2d39314433a5\u0026amp;response_type=code\u0026amp;redirect_uri=http://localhost/onedrive-login\u0026amp;response_mode=query\u0026amp;scope=offline_access%20User.Read%20Files.ReadWrite.All\n中国版(世纪互联) https://login.chinacloudapi.cn/common/oauth2/v2.0/authorize?client_id=dfe36e60-6133-48cf-869f-4d15b8354769\u0026amp;response_type=code\u0026amp;redirect_uri=http://localhost/onedrive-login\u0026amp;response_mode=query\u0026amp;scope=offline_access%20User.Read%20Files.ReadWrite.All\n初始化配置文件 # 国际版 OneDriveUploader -a \u0026quot;url\u0026quot; # 个人版(家庭版) OneDriveUploader -ms -a \u0026quot;url\u0026quot; # 中国版(世纪互联) OneDriveUploader -cn -a \u0026quot;url\u0026quot; # 在浏览器地址栏中获取以 http://loaclhost 开头的整个url内容 # 将获取的完整url内容替换命令中的 url 三个字母 # 每次产生的 url 只能用一次, 重试请重新获取 url # 此操作将会自动初始化的配置文件 # 提示 Init config file: '/path/to/auth.json' 则成功 使用 Usage of OneDriveUploader: -a string // 初始化授权 Setup and Init auth.json. -b string // 自定义上传分块大小, 可以提高网络吞吐量, 受限于磁盘性能和网络速度. Set block size. [Unit: M; 5\u0026lt;=b\u0026lt;=60;] (default \u0026quot;10\u0026quot;) -c string // 配置文件路径 Config file. (default \u0026quot;auth.json\u0026quot;) -n string // 上传单个文件时,在网盘中重命名 Rename file on upload to remote. -r string // 上传到网盘中的某个目录, 默认: 根目录 Upload to reomte path. -s string // *必要参数, 要上传的文件或文件夹 Upload item. -t string // 线程数, 同时上传文件的个数. 默认: 2 Set thread num. (default \u0026quot;2\u0026quot;) -f // 开关(推荐) // 加上 -f 参数，强制读取 auth.json 中的块大小配置和多线程配置. // 不加 -f 参数, 每次覆盖保存当前使用参数到 auth.json 配置文件中. Force Read config form config file. [BlockSize, ThreadNum] -skip // 开关 // 跳过上传网盘中已存在的同名文件. (默认不跳过) Skip exist file on remote. -cn // 开关 // 授权中国版(世纪互联), 需要此参数. OneDrive by 21Vianet. -ms // 开关 // 授权个人版(家庭版), 需要此参数. OneDrive by Microsoft. 配置 { // 授权令牌 \u0026quot;RefreshToken\u0026quot;: \u0026quot;1234564567890ABCDEF\u0026quot;, // 最大线程数.(同时上传文件的数量) \u0026quot;ThreadNum\u0026quot;: \u0026quot;2\u0026quot;, // 最大上传分块大小.(每次上传文件的最大分块大小,网络不好建议调低. 单位:MB) \u0026quot;BlockSize\u0026quot;: \u0026quot;10\u0026quot;, // 最大单文件大小.(目前: 个人版(家庭版)单文件限制为100GB; 其他版本单文件限制为15GB,微软将逐步更新为100GB. 单位:GB) \u0026quot;SigleFile\u0026quot;: \u0026quot;100\u0026quot;, // 缓存刷新间隔. \u0026quot;RefreshInterval\u0026quot;: 1500, // 如果是中国版(世纪互联), 此项应为 true. \u0026quot;MainLand\u0026quot;: false, // 如果是家庭版或者个人免费版, 此项应为 true. \u0026quot;MSAccount\u0026quot;: true } 示例 # 一些示例: # 将同目录下的 mm00.jpg 文件上传到 OneDrive 网盘根目录 OneDriveUploader -s \u0026quot;mm00.jpg\u0026quot; # 将同目录下的 mm00.jpg 文件上传到 OneDrive 网盘根目录,并改名为 mm01.jpg OneDriveUploader -s \u0026quot;mm00.jpg\u0026quot; -n \u0026quot;mm01.jpg\u0026quot; # 将同目录下的 Download 文件夹上传到 OneDrive 网盘根目录 OneDriveUploader -s \u0026quot;Download\u0026quot; # 将同目录下的 Download 文件夹上传到 OneDrive 网盘Test目录中 OneDriveUploader -s \u0026quot;Download\u0026quot; -r \u0026quot;Test\u0026quot; # 将同目录下的 Download 文件夹上传到 OneDrive 网盘Test目录中, 使用 10 线程 OneDriveUploader -t 10 -s \u0026quot;Download\u0026quot; -r \u0026quot;Test\u0026quot; # 将同目录下的 Download 文件夹上传到 OneDrive 网盘Test目录中, 使用 15 线程, 并设置分块大小为 20M OneDriveUploader -t 15 -b 20 -s \u0026quot;Download\u0026quot; -r \u0026quot;Test\u0026quot; # 将同目录下的 Download 文件夹上传到 OneDrive 网盘Test目录中, 使用配置文件中的线程参数和分块大小参数 OneDriveUploader -f -c \u0026quot;/urs/local/auth.json\u0026quot; -s \u0026quot;Download\u0026quot; -r \u0026quot;Test\u0026quot; # 将同目录下的 Download 文件夹上传到 OneDrive 网盘Test目录中, 使用配置文件中的线程参数和分块大小参数，并跳过上传网盘中已存在的同名文件 OneDriveUploader -f -c \u0026quot;/urs/local/auth.json\u0026quot; -skip -s \u0026quot;Download\u0026quot; -r \u0026quot;Test\u0026quot; 注意  多次尝试后, 无失败的上传文件. 退出码为 0 . 最终还有失败的上传文件会详细列出上传失败项. 退出码为 1.  Client/Secret (~ 2299/12/31) # 国际版: 78d4dc35-7e46-42c6-9023-2d39314433a5| ZudGl-p.m=LMmr3VrKgAyOf-WevB3p50 # 中国版: dfe36e60-6133-48cf-869f-4d15b8354769| H0-1:6.Sb8:WCW/J-c]K@fddCt[i0EZ2 ","description":"","id":43,"section":"posts","tags":["onedrive"],"title":"OneDriveUploader使用","uri":"https://yslinwe.github.io/posts/onedriveuploader%E4%BD%BF%E7%94%A8/"},{"content":"题目描述 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。\n示例1 输入 \u0026quot;We Are Happy\u0026quot; 返回值 \u0026quot;We%20Are%20Happy\u0026quot; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param s string字符串 * @return string字符串 */ string replaceSpace(string s) { for(int i = 0;i\u0026lt;s.size();i++) { if(s[i]==\u0026#39; \u0026#39;) { s = s.replace(i,1,\u0026#34;%20\u0026#34;); } } return s; } };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param s string字符串 * @return string字符串 */ string replaceSpace(string s) { string newS; for(int i = 0;i\u0026lt;s.size();i++) { if(s[i]==\u0026#39; \u0026#39;) { newS +=\u0026#34;%20\u0026#34;; }else { newS +=s[i]; } } return newS; } };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param s string字符串 * @return string字符串 */ string replaceSpace(string s) { int sSize = s.size(); int spaceNum = 0; for(int i = 0;i\u0026lt;sSize;i++) { if(s[i]==\u0026#39; \u0026#39;) { spaceNum++; } } int newLen = spaceNum*2 + sSize; int newI = 0; string newS(newLen,\u0026#39; \u0026#39;); for(int i = sSize - 1,newI = newLen-1;i\u0026gt;=0;i--,newI--) { if(s[i]==\u0026#39; \u0026#39;) { newS[newI] = \u0026#39;0\u0026#39;; newI = newI-1; newS[newI] = \u0026#39;2\u0026#39;; newI = newI -1; newS[newI] = \u0026#39;%\u0026#39;; } else { newS[newI] = s[i]; } } return newS; } };   ","description":"剑指office（二）替换空格","id":44,"section":"posts","tags":["剑指office"],"title":"剑指office（二）替换空格","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/2%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"},{"content":"1 2 3 4 5 6 7 8 9 10  in:name example 名字中有“example” in:readme example readme中有“example” in:description example 描述中有“example” stars:\u0026gt;1000 star\u0026gt;1000 forks:\u0026gt;1000 fork\u0026gt;1000 pushed:\u0026gt;2019-09-01 2019年9月1日后有更新的 language:java 用Java编写的项目 更多打开：https://help.github.com/en/github/searching-for-information-on-github/searching-for-repositories   ","description":"","id":45,"section":"posts","tags":["github高级搜索"],"title":"Github高级搜索","uri":"https://yslinwe.github.io/posts/github/github%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2/"},{"content":"题目描述 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n[\n[1,2,8,9],\n[2,4,9,12],\n[4,7,10,13],\n[6,8,11,15]\n]\n给定 target = 7，返回 true。\n给定 target = 3，返回 false。\n示例1 输入 7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]] 返回值 true 说明 存在7，返回true 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution { public: bool Find(int target, vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; array) { int cowS = array.size(); int rowS = array[0].size(); int cow = 0; //行  int row = rowS - 1; while(cow\u0026lt;cowS\u0026amp;\u0026amp;row\u0026gt;=0) { int val = array[cow][row]; if(val == target) return true; else if(target\u0026lt;val) row--; else cow++; } return false; } };   ","description":"剑指office（一）二维数组查找","id":46,"section":"posts","tags":["剑指office"],"title":"剑指office（一）二维数组查找","uri":"https://yslinwe.github.io/posts/%E5%89%91%E6%8C%87offer/1%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE/"},{"content":"上传文件 1 2 3 4 5 6 7 8  pscp -r newlivedowload root@139.9.116.41:live_download nethogs eth0 ls -lh df -l ps -aux|grep get.py| grep -v grep nohup 运行文件\u0026gt;\u0026gt; output.log 2\u0026gt;\u0026amp;1 \u0026amp; nohup python3 -u main.py \u0026gt; test.out 2\u0026gt;\u0026amp;1 \u0026amp;   限制网速  git clone https://github.com/magnific0/wondershaper.git 在确定网卡名称以后，就可以按照以下的命令限制网络带宽：\n sudo wondershaper -a \u0026lt;adapter\u0026gt; -d \u0026lt;rate\u0026gt; -u \u0026lt;rate\u0026gt; 例如，如果网卡名称是 enp0s8，并且需要把上行、下行速率分别限制为 1024 Kbps 和 512 Kbps，就可以执行以下命令：\n sudo wondershaper -a eth0 -d 1024 -u 512 其中参数的含义是：\n-a：网卡名称\n-d：下行带宽\n-u：上行带宽\n如果要对网卡解除网络带宽的限制，只需要执行：\n ./wondershaper -a eth0 -c 后台运行 可以先执行：screen -S zgy ，screen就会创建一个名字为zgy的会话\n运行代码 当需要临时离开时（会话中的程序不会关闭，仍在运行）可以用快捷键Ctrl+a d(即按住Ctrl，依次再按a,d)\n当回来时可以再执行执行：screen -r zgy 即可恢复到离开前创建的zgy会话的工作界面。\n screen -ls screen会列出当前存在的会话列表  恢复会话：  screen -r zgy或screen -r pid  退出会话 执行：exit ，会提示：[screen is terminating]，表示已经成功退出screen会话。\n常用快捷键 kill 掉一个窗口\n  screen -X -S 4588 quit\n  Ctrl+a c ：在当前screen会话中创建窗口\n  Ctrl+a w ：窗口列表\n  Ctrl+a n ：下一个窗口\n  Ctrl+a p ：上一个窗口\n  Ctrl+a 0-9 ：在第0个窗口和第9个窗口之间切换\n  ","description":"","id":47,"section":"posts","tags":["服务器"],"title":"服务器命令行","uri":"https://yslinwe.github.io/posts/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":48,"section":"gallery","tags":null,"title":"卡通","uri":"https://yslinwe.github.io/gallery/cartoon/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":49,"section":"gallery","tags":null,"title":"图片","uri":"https://yslinwe.github.io/gallery/photo/"},{"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\n https://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n","description":"Hugo, the world’s fastest framework for building websites","id":54,"section":"","tags":null,"title":"关于","uri":"https://yslinwe.github.io/about/"}]