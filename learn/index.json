[{"content":"[Unity面试] 2022年Unity面试题分享 发布于 2022-11-09 15:25:22\n4430\n举报\n大家好，又见面了，我是你们的朋友全栈君。\n【重点面试题】代表面试的时候问到的题目 光背答案是没有用的，一定要动手操作一下，才能知道答案为什么是这个。\n本文章力求从简单的形式到深入理解原理，再到扩展，丰富知识的层次感，知其所以然。\n2021年Unity面试题分享 一、C#语言和面向对象OOP（已更新2021.3.8） 二、Unity脚本基础（已更新2021.3.8） 三、Unity性能优化（必问）（已更新2021.3.8） 四、设计模式 五、Unity编辑器基础 六、数据结构和算法（已更新2021.2.27） 六、Lua语言和Xlua热更（已更新2021.3.8） 七、实际面试中遇到的问题 （已更新2021.3.8） 一、C#语言和面向对象OOP（已更新2021.3.8） 1、【重点面试题】面向对象的三大特性 封装 ：隐藏对象的属性，并实现细节（方法），对外提供接口， public全局，protected子类，internal同集，隐藏private 同类，public属性器，private字段，对赋值进行限定。 sealed修饰符的子类是不能被继承的。\n1 2 3 设计上：分而治之，封装变化、高内聚低耦合 数据上：把一些基本数据复合成一个自定义类型的数据 方法上：隐藏实现细节，向外提供接口 复制\n继承：重用现有代码 多态：静态多态重载，动态多态重写。 父类行为由子类具体实现，包含virtual虚方法，abstract抽象方法，interface接口 可以涉及题目虚方法、抽象方法、接口的区别\n重载和重写区别 静态重载：返回值无关，与参数个数，类型相关。编译阶段。便于扩展和维护 动态重写override（运行时，改写了方法表的新地址）。 抽象方法的父类必须是抽象类，子类是抽象类可以不重写，抽象类不可以被实例化。\n举例子非常重要 基类抽象人物工厂（接口）,子类具体玩家工厂，子类怪物工厂，子类npc工厂，抽象产品（接口）具体魔法师，弓箭手产品~ 资源管理工厂，UI资源管理工厂，音频资源管理工厂，资源管理，UI资源管理，音频资源\n2、【重点面试题】值类型和引用类型区别 值类型：包含了所有简单类型（整数、浮点、bool、char）、struct、enum。 继承自System.ValueTyoe 引用类型包含了string，object，class，interface，delegate，array 继承自System.Object\n内存区域上的区别 值类型：数据存储在栈上，超出作用域就自动清理 引用类型：数据存储在托管堆上，引用地址在线程栈上，地址指向数据存放的堆上 托管堆会由GC来自动释放 ，线程栈数据在作用域结束后会被清理。\n拷贝策略：值类型是拷贝数据，引用类型是拷贝引用地址 如果值类型为传值参数，传值参数会在栈上新开辟一个副本，原先的值类型数据不会改变 如果引用类型是传值参数，传值参数会创建一个新的引用地址，两个引用地址会指向同一个对象实例的数据，实例数据会随着改变进行改变。（这种行为被称为副作用，一般实际项目不会这么操作，要么return返回参数，要么使用ref或者out修饰符） 【扩展Ref引用参数，Out输出参数可以利用这一副作用机制】\n通常来讲 变量的值分配 与其声明该变量的位置有关。 局部变量的值 总是在 栈上的。 实例变量的值则和实例本身一起储存在实例储存的地方。 引用类型实例和静态总是储存在 堆上的。 数组的元素、引用类型中的值类型字段等，引用类型的确总是分配在托管堆上， 但是值类型并非总是分配在线程栈上有可能分配在堆上。\n值类型和引用类型互相转换：拆箱和装箱 装箱：值类型====》引用类型object 1.分配内存堆 2.值类型数据拷贝到新的内存堆中 3.栈中分配一个新的引用地址指向内存堆 拆箱：引用类型object====》值类型 1.检查确保对象是给定值类型的一个装箱值 2.将该值数据复制到栈中的值类型\nstring是特殊的引用类型，如果传入参数是string，在方法里修改，原string数值不变。 原因是string的不变性，系统内部做了特殊处理。 链接: B站刘铁猛C#入门精要.\n【重点面试题】3、装箱和拆箱的区别 值类型和引用类型的最终基类是Object 装箱：值类型转换成引用类型的过程，生成新的引用 拆箱；引用类型转换成值类型的过程\n装箱操作：托管堆分配内存，值类型拷贝数据，object地址指向托管堆对象 拆箱操作：根据object引用地址找到托管堆上的数据，栈上数据拷贝 避免装箱操作，生成新的应用，解决办法就是第一是重载，第二是泛型 链接: 参考资料.\n4、public、private、protected、internal、sealed的区别 public全局、private类内部、protected派生类、internal本程序集 sealed声明类就不能继承，声明方法就是不能被重写\n【重点面试题】6、什么是接口，描述一下接口的成员具体实现（手撸代码和注意修饰符） 接口interface，不能定义字段，可以定义【非静态的】属性、索引器、事件、方法 默认public，但不能写任何访问修饰符 接口是引用类型，可以通过as运算符强转，获取某对象的接口的引用 接口可以继承N个接口，继承类要实现所有接口的方法\n声明接口IA \u0026gt; 继承接口的类B \u0026gt; 类B实现接口所有方法 接口要小而精，定义一组方法，继承接口的派生类要实现接口的所有方法。 接口和抽象类是不能被实例化的对象（引用类型）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public delegate void DelegateTest(); public interface ITest //只能包含非静态成员函数，隐式public，但不允许访问修饰符 { void Method(string a); //方法 string Property //属性 { get; set; } event DelegateTest EventTest; //事件，需要先定义一个委托 int this[int index] //索引器 { get; set; } } 复制\n举个例子：游戏门：抽象类，不能实例，很多行为，定义接口，破坏可以击碎 系统接口鼠标行为，停留进入离开 很多设计模式，是对接口的应用，面向接口编程，实现层面更加有层次。 【参考C#图解第十五章接口】\n【重点面试题】7、foreach迭代器遍历和for循环遍历的区别 如果集合需要foreach遍历，是否可行，存在一定问题 foreach中的迭代变量item是的只读，不能对其进行修改，比如list.Remove（item）操作 foreach只读的时候记录下来，在对记录做操作，或者直接用for循环遍历 foreach对int[]数组循环已经不产生GC，避免对ArrayList进行遍历\nfor语句中初始化变量i的作用域，循环体内部可见。 通过索引进行遍历，可以根据索引对所遍历集合进行修改 unity中for循环使用lambda表达式注意闭包问题\nForeach遍历原理 任何集合类（Array）对象都有一个GetEnumerator()方法，该方法可以返回一个实现了 IEnumerator接口的对象。 这个返回的IEnumerator对象既不是集合类对象，也不是集合的元素类对象，它是一个独立的类对象。 通过这个实现了 IEnumerator接口对象A，可以遍历访问集合类对象中的每一个元素对象 对象A访问MoveNext方法，方法为真，就可以访问Current方法，读取到集合的元素。\n1 2 3 4 5 6 7 8 List\u0026lt;string\u0026gt; list = new List\u0026lt;string\u0026gt;() { \u0026#34;25\u0026#34;, \u0026#34;哈3\u0026#34;, \u0026#34;26\u0026#34;, \u0026#34;花朵\u0026#34; }; IEnumerator listEnumerator = list.GetEnumerator(); while (listEnumerator.MoveNext()) { Console.WriteLine(listEnumerator.Current); } 复制\n枚举器的实现（枚举器可用于读取集合中的数据，但不能用于修改集合）\n链接: 参考资料.\n【重点面试题】8、string和stringbuilder和stringBuffer区别 String不变性，字符序列不可变，对原管理中实例对象赋值，会重新开一个新的实例对象赋值，新开的实例对象会等待被GC。 string拼接要重新开辟空间，因为string原值不会改变，导致GC频繁，性能消耗大\nStringBuffer是字符串可变对象，可通过自带的StringBuffer.方法来改变并生成想要的字符串。对原实例对象做拼接的实例，不会生成新的实例对象。 拼接使用StringBuilder和StringBuffer，只开辟一个内存空间，这是性能优化的点。\nStringBuilder是字符串可变对象，基本和StringBuilder相同。 唯一的区别是StringBuffer是线程安全，相关方法前带synchronized关键字，一般用于多线程 StringBuilder是非线程安全，所以性能略好，一般用于单线程 三者性能比较 StringBuilder\u0026gt;StringBuffer\u0026gt;String\n相关方法 StringBuilder.Append 将信息追加到当前 StringBuilder 的结尾。 StringBuilder.AppendFormat 用带格式文本替换字符串中传递的格式说明符。 StringBuilder.Insert 将字符串或对象插入到当前 StringBuilder 对象的指定索引处。 StringBuilder.Remove 从当前 StringBuilder 对象中移除指定数量的字符。 StringBuilder.Replace 替换指定索引处的指定字符。\n9、使用List的区别 list=new list（）会导致每增加一个内容就增加新内存，导致原内存浪费，GC频繁 需要添加一个固定参数，只开辟一个内存，list = new list（50） 性能优化的点\n10、字符串比较 先用string 变量存储 obj.name ,这用只有一个内存空间保存 如果不存储 obj.name每一次比较都会产生新的内存空间、 比较obj.tag==”Tag“不使用，而是使用避免GC的obj.CompareTag(“tag”) 射线检测SphereColliderNoAlloc可以避免GC，比直接使用SphereCollider性能要好\n【重点面试题】11、请简述GC垃圾管理器，和GC产生的原因，并描述如何避免 GC垃圾回收机制，避免堆内存溢出，定期回收那些没有有效引用的对象内存 GC优化，就是优化堆内存，减少堆内存，即时回收堆内存 GC归属于CLR\n如何避免 1.减少new的次数 2.字符串拼接使用stringbuilder，字符串比较先定义一个变量存储，防止产生无效内存 3.list，new时候，规定内存大小 4.如果要射线检测，应该使用避免GC的方法XXXXNoAlloc函数 5.foreach迭代器容易导致GC（目前Unity5.5已修复），使用For循环 6.使用静态变量，GC不会回收存在的对象，但静态变量的引用对象可能被回收 7.使用枚举替代字符串变量 8.调用gameobject.tag==”XXX”就会产生内存垃圾；那么采用GameObject.CompareTag()可以避免内存垃圾的产生： 9.不要在频繁调用的函数中反复进行堆内存分配，比如OnTriggerXXX，Update等函数 10.在Update函数中，运行有规律的但不需要每一帧执行的代码，可以使用计时器，比如1秒执行一次某些代码！！！ 链接: 参考文章.\n12、请描述interface和抽象类之间的不同 接口是一种行为，抽象类是一种不能实例化的对象。 接口interface可以定义方法、属性、索引器、事件 抽象类abstract可以定义字段、静态字段和方法、抽象方法、属性、构造函数 接口可以继承多个接口，抽象类只能继承一个类 接口直接实现所有成员，抽象类重写override抽象方法 接口和抽象都不能被实例化，派生类必须实现基类或接口的方法 抽象类可以派生自另一个抽象类，接口可以多重实现，抽象类只能单一继承 举个例子：抽象类门，多接口继承【可破坏、金属】的行为方法，派生类实例化这个门，接口的实现类实现具体行为，派生类创建这样具体的可破坏的铁门 链接: 参考资料.\n【重点面试题】13、反射的实现原理？ 定义：运行时，动态获取类型信息,动态创建对象,动态访问成员的过程。 另一种定义：审查元数据并收集元数据的信息。 元数据：编译后的最基本数据单元，就是一堆表，反射就是解析这些元数据。 反射是在运行期间获取到类、对象、方法、数据的一种手段 主要使用类库System.Reflection 反射要点：如何获取类型，根据类型来动态创建对象，反射获取方法以及动态调用方法，动态创建委托 一、动态获取类型信息 1.System.Reflection.Assembly.Load(“XXXX.dll”) 动态加载程序集 2.System.Type.GetType(“XXXX类名”); //动态获取某程序集中某类信息 3.obj.GetType(); //已知对象获取类信息 ——或者——typeof(类型) //已知类类型 二、动态创建对象实例（上一步操作后获得类对象） System.Activator.CreateInstance(Type type); 三、动态访问成员调用方法（上一步操作后已获取实例对象） System.Reflection.MethodInfo method = type.GetMethod(“方法名”);//获得方法 System.Reflection.MethodInfo.Invoke(object , new object[]{参数}) //调用的类实例和实例参数\n核心类 System.Reflection.Assembly 描述程序集 System.Type 描述类 System.Reflection.FieldInfo 描述了类的字段 System.Reflection.ConstructorInfo 描述构造函数 System.Reflection.MethodInfo 描述类的方法 System.Reflection.PropertyInfo 描述类的属性\n反射耗性能，lua是动态语言，一种小巧的脚本语言，会使用反射机制。\n知识扩展 手机端不支持编译，需要热更方案，通过lua的反射机制将旧的DLL文件替换成新的DLL文件。 Xlua是lua框架，由TX鹅肠进行维护，方便了C#与lua相互调用，C#端实现lua虚拟机 链接：参考资料太多，主要搜索，C#反射机制，lua，xlua性能等等。\n14、.Net 与 Mono 的关系？ .Net是一个语言平台 Mono为.Net提供集成开发环境，集成并实现了 .NET的编译器、CLR 和基础类库， 使得.Net既可以运行在windows也可以运行于 linux，Unix，Mac OS 等。\n15、在类的构造函数前加上 static 会报什么错?为什么? 静态构造函数不允许添加访问修饰符，且必须无参数 原因：无论创建多少类型的对象，静态构造函数只执行一次 类实例化或者首静态成员调用之前，运行库会先调用静态构造函数 静态构造函数优先级高于任何其它构造函数 也无法使用this和base来调用静态构造函数 一个类只能有一个静态函数，如果有静态变量，系统也会自动生成静态函数\n16、C# String 类型比 stringBuilder 类型的优势是什么? string功能性更强，通用性更好，用途更广泛 string不可变性，线程栈同步 编译器已将把string，并通过操作优化成stringbuilder，在性能上不差，一般可以用string代替stringbuilder\n17、C# 函数 Func(string a, string b)用 Lambda 表达式怎么写? Lambda表达式（任意参数）=\u0026gt; { 表达式} ； =\u0026gt; 读作goesto （a,b）=\u0026gt; { } ;\n【重点面试题】18、C#中有哪些常用的容器类，各有什么特点，性能区别？ Stack栈：先进后出，入栈和出栈，底层泛型数组实现，入栈动态扩容2倍 Queue队列：先进先出，入队和出队，底层泛型数组实现，表头表尾指针，判空还是满通过size比较 Queue和Stack主要是用来存储临时信息的\nArray数组：需要声明长度，不安全 ArrayList数组列表：动态增加数组，不安全，实现了IList接口（表示可按照索引进行访问的非泛型集合对象），Object数组实现 List列表:底层实现是泛型数组，特性，动态扩容，泛型安全 将泛型数据（对值类型来说就是数据本身，对引用类型来说就是引用）存储在一个泛型数组中，添加元素时若超过当前泛型数组容量，则以2倍扩容，进而实现List大小动态可变。（注：大小指容量，不是Count） LinkList链表 1、数组和List、ArrayList集合都有一个重大的缺陷，就是从数组的中间位置删除或插入一个元素需要付出很大的代价，其原因是数组中处于被删除元素之后的所有元素都要向数组的前端移动。 2、LinkedList（底层是由链表实现的）基于链表的数据结构，很好的解决了数组删除插入效率低的问题，且不用动态的扩充数组的长度。 3、LinkedList的优点：插入、删除元素效率比较高；缺点：访问效率比较低。 C#则List和LinkedList的区别 List是数组列表，LinkedList是双向链表，List读取速度快，时间复杂度是O（1），增删比较麻烦，时间复杂度是O(n). LinkedList读取时间复杂度是O(n),增删时间复杂度是O（1）\nHashTable哈希表（散列表） 概念：不定长的二进制数据通过哈希函数映射到一个较短的二进制数据集，即Key通过HashFunction函数获得HashCode 装填因子：α=n/m=0.72 ,存储的数据N和空间大小M 然后通过哈希桶算法，HashCode分段，每一段都是一个桶结构，一般是HashCode直接取余。 桶结构会加剧冲突，解决冲突使用拉链法，将产生冲突的元素建立一个单链表，并将头指针地址存储至Hash表对应桶的位置。这样定位到Hash表桶的位置后可通过遍历单链表的形式来查找元素。 1、Key—Value形式存取，无序，类型Object，需要类型转换。 2、Hashtable查询速度快，而添加速度相对慢 3、Hashtable中的数据实际存储在内部的一个数据桶里（bucket结构体数组），容量固定，根据数组索引获取值。 Directionary\u0026lt;TKey,TVaule\u0026gt;字典，有序，泛型存储不需要进行类型装换（不需要装箱拆箱），碰撞阈值扩容~ HashSet：一组不包含重复的元素集合【LeetCode算法217存在重复元素】\n性能排序： 插入性能： LinkedList \u0026gt; Dictionary \u0026gt; HashTable \u0026gt; List 遍历性能：List \u0026gt; LinkedList \u0026gt; Dictionary \u0026gt; HashTable 删除性能： Dictionary \u0026gt; LinkedList \u0026gt; HashTable \u0026gt; List 小结： 在修改较频繁，且查找和删除也较多时，首选LinkedList, 在主要以删除为主，插入为辅，且查找较少时，首选Dictionary， 在查找频繁，而又无需修改的情况下，则首选List。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //哈希表结构体 private struct bucket { public Object key;//键 public Object val;//值 public int hash_col;//哈希码 } //字典结构体 private struct Entry { public int hashCode; // 除符号位以外的31位hashCode值, 如果该Entry没有被使用，那么为-1 public int next; // 下一个元素的下标索引，如果没有下一个就为-1 public TKey key; // 存放元素的键 public TValue value; // 存放元素的值 } private int[] buckets; // Hash桶 private Entry[] entries; // Entry数组，存放元素 private int count; // 当前entries的index位置 private int version; // 当前版本，防止迭代过程中集合被更改 private int freeList; // 被删除Entry在entries中的下标index，这个位置是空闲的 private int freeCount; // 有多少个被删除的Entry，有多少个空闲的位置 private IEqualityComparer\u0026lt;TKey\u0026gt; comparer; // 比较器 private KeyCollection keys; // 存放Key的集合 private ValueCollection values; // 存放Value的集合 复制\n链接: Stack参考链接. 链接: Queue参考链接. 链接: [ArrayList参考链接](https://blog.csdn.net/exiaojiu/article/details/51190926?ops_request_misc=\u0026amp;request_id=\u0026amp;biz_id=102\u0026amp;utm_term=C# ArrayList 底层\u0026amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-51190926.first_rank_v2_pc_rank_v29_10). 链接: [List参考链接](https://blog.csdn.net/enternalstar/article/details/107890981?ops_request_misc=\u0026amp;request_id=\u0026amp;biz_id=102\u0026amp;utm_term=C# List 底层\u0026amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-107890981.first_rank_v2_pc_rank_v29_10). 链接: HashTable参考链接. 链接: Dictionary参考链接.\n19、C#中常规容器和泛型容器有什么区别，哪种效率高？ 常规容器有拆箱和装箱操作，速度慢，消耗性能 泛型容器效率更高\n20、有哪些常见的数值类？ 简单数值类型：整数型、字符型、布尔型、实数型 复合类型：结构类型、枚举类型\n21、C#中委托和接口有什么区别？各用在什么场合？ 委托delegate：unity事件与委托密切相关，回调机制，减少对象之间数据交互 接口interface：多人协作，完全抽象，类单继承 委托是约束方法的集合 接口是约束类具备的功能集合，解决类单继承问题\n22、C#中unsafe关键字是用来做什么的？什么场合下使用？ unsafe 非托管代码，配合fixed一起使用 ，用在需要指针操作的场合 项目背包系统的任务装备栏使用到\n【重点面试题】23、C#中ref和out关键字有什么区别？知道Ref的深层原理是什么？ ref修饰引用参数。参数必须赋值，带回返回值，又进又出 out修饰输出参数。参数可以不赋值，带回返回值之前必须明确赋值， 引用参数和输出参数不会创建新的存储位置\n如果ref参数是值类型，原先的值类型数据，会随着方法里的数据改变而改变， 如果ref参数值引用类型，方法里重新赋值后，原对象堆中数据会改变，如果对引用类型再次创建新对象并赋值给ref参数，引用地址会重新指向新对象堆数据。方法结束后形参和新对象都会消失。实参还是指向原始对象，值不够数据改变了 【参考C#图解教程：引用类型作为值参数和引用参数】\n24、For，foreach，Enumerator.MoveNext的使用，与内存消耗情况 for通过索引或下标一次进行遍历 foreach和Enumerator.MoveNext通过迭代进行遍历 内存消耗本质没有多少区别 迭代器有一个状态机 before running：yield return 或 yield break 或迭代结束 after\n25、函数中多次使用string的+=处理，会产生大量内存垃圾（垃圾碎片），有什么好的方法可以解决。 使用stringbuilder的append\n26、当需要频繁创建使用某个对象时，有什么好的程序设计方案来节省内存？ Unity对象池 设计单例模式全局实例化一次\n27、Foreach循环迭代时，若把其中的某个元素删除，程序报错，怎么找到那个元素？以及具体怎么处理这种情况？(注：Try…Catch捕捉异常，发送信息不可行) foreach迭代器不能进行操作 在循环中记录索引值或者key值，在迭代结束后，查找到这个元素，在进行删除操作\n28、GameObject a=new GameObject() GameObject b=a 实例化出来了A，将A赋给B，现在将B删除，问A还存在吗？ 存在 a引用地址在线程栈中，数据内容在托管堆中 b引用地址在线程栈中，数据内容指向A的托管堆中的内容 B删除，只是删除b的引用地址\n【重点面试题】29、C#引用和C++指针的区别 C#不支持指针，但可以使用Unsafe，不安全模式，CLR不检测 C#可以定义指针的类型、整数型、实数型、struct结构体 C#指针操作符、C#指针定义 使用fixed，可以操作类中的值类型 相同点：都是地址 指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。 不同点： 指针是个实体，引用是个别名。 sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小； 引用是类型安全的，而指针在不安全模式下\n【重点面试题】30、using的作用 资源：实现了IDisposable接口的类或结构。 using语句确保这些资源能够被适当的释放（Resource.Dispose） using原理 using（分配资源）{ 使用资源 } ——\u0026gt; 释放资源 （隐式） 使用资源（可能会导致异常）会被放进Try块里，释放资源（有无异常）都会放进在finally块\n1 2 3 4 5 6 7 8 using（分配资源） { try{ 使用资源 } finally{ Resource.Dispose} } 复制\nusing指令,using+命名空间（或命名空间一个类型） 在源文件的顶端声明 也可以不使用using，直接命名空间.类.成员方法\n【重点面试题】31、字典Dictionary的内部实现原理 泛型集合命名空间using System.Collections.Generic; 任何键都必须是唯一\n该类最大的优点就是它查找元素的时间复杂度接近O(1)，实际项目中常被用来做一些数据的本地缓存，提升整体效率。 实现原理 1.哈希算法：将不定长度的二进制数据集给映射到一个较短的二进制长度数据集一个Key通过HashFunc得到HashCode 2.Hash桶算法：对HashCode进行分段显示，常用方法是对HashCode直接取余 3.解决碰撞冲突算法（拉链法）：分段会导致key对应的桶会相同，拉链法的思想就像对冲突的元素，建立一个单链表，头指针存储到对应的哈希桶位置。反之就是通过确定hash桶位置后，遍历单链表，获取对应的value\nKey值 HashFunc Buckets桶 Entries入口（最小数据结构）\nDictionary字典中最小的数据结构体Entry，调用Add(Key,Value)方法添加的元素都会被封装在这样的一个结构体中。\n1 2 3 4 5 6 7 private struct Entry { public int hashCode; // 除符号位以外的31位hashCode值, 如果该Entry没有被使用，那么为-1 public int next; // 下一个元素的下标索引，如果没有下一个就为-1 public TKey key; // 存放元素的键 public TValue value; // 存放元素的值 } 复制\nCollection版本控制，字典重要变量version，这个变量，在每一次新增、修改和删除操作时，都会使version++ 之后每一次迭代过程都会检查版本号是否一致，如果不一致将抛出异常。 这样就避免了在迭代过程中修改了集合，造成很多诡异的问题。\n链接: Dictionary实现原理资料.\n【重点面试题】32、泛型是什么 多个代码对 【不同数据类型】 执行 【相同指令】的情况 泛型：多个类型共享一组代码 泛型允许类型参数化，泛型类型是类型的模板 5种泛型：类、结构、接口、委托、方法 类型占位符 T 来表示泛型\n泛型类不是实际的类，而是类的模板 从泛型类型创建实例 声明泛型类型》通过提供【真实类型】创建构造函数类型》从构造类型创建实例 类\u0026lt;T1,T2\u0026gt; 泛型类型参数\n性能：泛型不会强行对值类型进行装箱和拆箱，或对引用类型进行向下强制类型转换，所以性能得到提高 安全：通过知道使用泛型定义的变量的类型限制，编译器可以在一定程度上验证类型假设，所以泛型提高了程序的类型安全。\n【重点面试题】33、结构体和类有什么区别\n二、Unity脚本基础（已更新2021.3.8） 【重点面试题】1、Unity3D中的协程（coroutine），C#线程和进程之间的区别是什么？\n简记：协程和线程区别 协程(协同程序Coroutine): 同一时间只能执行某个协程。开辟多个协程开销不大。协程适合对某任务进行分时处理。 Unity提供了StartCoroutine来开启协程，当你在 StartCoroutine 的函数体里处理一段代码时，利用 yield语句等待执行结果，这期间不影响主程序的继续执行，可以协同工作。\n举个例子：LoadLevelAsync（异步加载关卡）后台加载场景的方法。允许你在后台加载新资源和场景，再利用协同，你就可以在前台用 loading 条或动画提示玩家游戏处于加载中，同时后台协同处理加载的事宜。\n进程progress：进程是线程的容器。 线程thread: 同一时间可以同时执行多个线程。开辟多条线程开销很大。线程适合多任务同时处理，并发并行。 协程：具体多返回点的方法，时间分片（帧），Unity只能是单线程，只能在主线程调用Api，对象\n2、Unity3D 是否支持写成多线程程序？如果支持的话需要注意什么？ 支持，如果掌握的Unity多线程的方法，就可以从容的使用多个硬件处理器或处理很难划分管理数据块。 【注意】 1、只能从主线程中访问 Unity3D 的组件，对象和 Unity3D 系统调用 2、如果同时你要处理很多事情或者与 Unity 的对象互动，可以用 thread，可以通过排序来解决一个线程改变一个数据的问题,否则使用协程coroutine。 3、C#中有 lock 这个关键字,以确保只有一个线程可以在特定时间内访问特定的对象\n【重点面试题】3、OnEnable、Awake、Start 运行时的发生顺序？哪些可能在同一个对象周期中反复的发生？ Awake \u0026gt; OnEnable\u0026gt;Start 推荐看脚本生命周期顺序 OnEnable可以在同一周期反复的发生 SetActive（true）就会反复触发OnEnable事件 SetActive（false）就会反复触发OnDisable事件\n其中Awake函数一般用于实现单例模式；当脚本被实例化时，调用awake，完成成员变量的初始化，在单例模式中会有一个虚方法OnStart在awake中调用，在实际脚本中重写OnStart方法 OnEnable函数是在游戏对象可以调用时调用； OnDisable是在游戏对象不可用时调用； Start函数则是在场景中显示该游戏对象前调用一次，用于开始设置物体属性和渲染； FixedUpdate函数具有固定更新频率，一般进行游戏对象的物理引擎的更新； Update函数则是渲染帧更新，每秒更新一定频率； LateUpdate函数是延迟更新，只有在每一帧的所有Update函数都执行完了过后才会执行； 而OnGUI函数则是在每一帧更新时调用。\n4、Unity3D 如何获知场景中需要加载的数据？如何动态资源加载？ instantiate：最简单的一种方式，以实例化的方式动态生成一个物体。\nAssetsbundle：即将资源打成 asset bundle 放在服务器或本地磁盘，然后使用WWW模块get 下来，然后从这个bundle中load某个object，unity官方推荐也是绝大多数商业化项目使用的一种方式。\nResource.Load:可以直接load并返回某个类型的Object，前提是要把这个资源放在Resource命名的文件夹下，Unity不管有没有场景引用，都会将其全部打入到安装包中\nAssetDatabase.loadasset ：这种方式只在editor范围内有效，游戏运行时没有这个函数，它通常是在开发中调试用的。\n5、Unity中碰撞器(Collider)和触发器(Trigger)的区别? 碰撞器（Collider）有碰撞效果，IsTrigger=false，可以调OnCollisionEnter/Stay/Exit函数\n触发器(Trigger)没有碰撞效果，isTrigger=true，可以调用OnTriggerEnter/Stay/Exit函数\n6、U3D中，几种施加力的方式，描述出来 首先需要对象要有rigidbody组件 Rigidbody.AddForce /AddForceAtPosition 2D Constant Force Force/Relative Force/Torque\n7、物体自旋转使用的函数叫什么？物体绕某点旋转使用函数叫什么？ transform.Rotate transform.RotateAround\n8、u3d 提供了一个用于保存读取数据的类，（playerPrefs），请列出保存读取整形数据的函数 PlayerPrefs类是一个本地持久化保存与读取数据的类 PlayerPrefs类支持3中数据类型的保存和读取，浮点型，整形，和字符串型。 分别对应的函数为： SetInt();保存整型数据；GetInt();读取整形数据； SetFloat();保存浮点型数据； GetFlost();读取浮点型数据； SetString();保存字符串型数据； GetString();读取字符串型数据；\n9、unity3d 从唤醒到销毁有一段生命周期，请列出系统自己调用的几个重要方法。 (init)Awake\u0026gt;OnEnable\u0026gt;Start \u0026gt; (Physic)FixedUpdate\u0026gt; (GameLogic)Update\u0026gt;Yield \u0026gt;LateUpdate\u0026gt;OnGui\u0026gt;OnDisable\u0026gt;OnDistroy\n10、物理更新一般在哪个系统函数里？ FixedUpdate，每固定帧绘制时执行一次，和 update 不同的是 FixedUpdate 是渲染帧执行，如果你的渲染效率低下的时候 FixedUpdate 调用次数就会跟着下降。\nFixedUpdate 比较适用于物理引擎的计算，因为是跟固定帧渲染有关。 Update 就比较适合做游戏逻辑更新。 LateUpdate比较适合相机更新，update后更新，防止视角移动，游戏对象发生空帧未出现。\n11、反向旋转动画的方法是什么？ 1.将动画速度调成-1 2.改代码animation.speed=-1\n【重点面试题】12、用代码实现第三人称角色控制器？第一人称角色控制器 大致思路： 摄像机与角色的距离范围 摄像机旋转、平移 鼠标控制摄像机 //代码稍后会在博客中贴出，转链接，目前未实现\n13、获取、增加、删除组件的命令分别是什么？ 获取：GetComponent 增加：AddComponent 删除：Destroy\n14、Animation.CrossFade 是什么？ 动画淡入淡出\n15、Application.LoadLevel 命令作用是什么？ 加载关卡，已弃用 现在使用SceneManager.LoadScene\n16、调式记录到控制台的命令是什么？ Debug.Log();\n17、编辑器类存放路径是什么？ Asset/Editor\n18、使用原生 GUI 创建一个可以拖动的窗口命令是什么？ GUI.DragWindow\n19、localPosition 与 Position 的使用区别？ localPosition :自身坐标系，相对于父级的位置 Position ：世界坐标系中的位置\n20、Mathf.Round和Mathf.Clamp和Mathf.Lerp含义？ Mathf.Round：四舍五入 Mathf.Clamp：左右限值 Mathf.Lerp：插值\n【重点面试题】21、写一个计时器工具，从整点开始，格式为00：00：00 分小时、分、秒\n22、写出 Animation 的五个方法 AddClip 将 clip 添加到名称为 newName 的动画中。 Blend 在后续 time 秒中将名称为 animation 的动画向 targetWeight 混合。 CrossFade 在后续 time 秒的时间段内，使名称为 animation 的动画淡入，使其他动画淡出。 CrossFadeQueued 使动画在上一个动画播放完成后交叉淡入淡出。 IsPlaying 名称为 name 的动画是否正在播放？ PlayQueued 在先前的动画播放完毕后再播放动画。 RemoveClip 从动画列表中移除剪辑。 Sample 对当前状态的动画进行采样。 Stop 停止所有使用该动画启动的正在播放的动画。\n23、用鼠标实现在场景中拖动物体，用鼠标滚轮实现缩放(用一个 Cube 即可） 在场景中添加一个Plan，Camera，Directional Light，Cube。添加两个脚本一个挂在Camera上，另一个挂在Cube上。 1.鼠标滚轮实现缩放：将摄像机的镜头拉近或者拉远，调整摄像机的视角就可以实现2.鼠标实现在场景中拖动物体：解决思路就是将世界坐标转换成屏幕坐标，然后计算物体与鼠标之间移动量，循环鼠标被按下操作，得到鼠标的当前位置，加上计算好的移动量，将新的坐标赋值给物理就行了。 具体代码实现：http://www.cnblogs.com/hewencong/p/4299722.html\n24、\u0026lt;愤怒的小鸟\u0026gt;给予初速度以后,怎么让小鸟受到重力和空气阻力的影响而绘制抛物线轨迹,说出具体的计算方法 Vector3 v 代表初速度 v’代表现在的速度， 假设小鸟是沿的 z 轴也就是transform.forward 方向，运动的质量为 m，那么 v‘=v-new Vector3(0,mgt,ft)，transform.Translate(v’)做的就是抛物线运动（g 为重力加速度不要用现实中的需要自己调试，f 为阻力也要自己调试 设置，t 为时间）\n25、当游戏中需要频繁创建一个物体时，我们需要怎样做能够节省内存？ 1.使用预制体对象 2.使用对象池技术\n26、碰撞检测需要物体具备什么属性？ 能检测碰撞发生的方式有两种，一种是利用碰撞器，另一种则是利用触发器\n27、如何使子控件居中,如果使用UGUI怎么实现 锚点设置为中心\n28、去掉敏感字的程序（手写程序） 字符串replace\n29、写出WWW的几个方法 WWW.LoadFromCacheOrDownload：可被用于将Assets Bundles自动缓存到本地磁盘 WWW.Dispose ：释放现有的 WWW 对象。 WWW.isDone：是否完成下载？（只读） WWW.progress：下载进度（只读）。\n【重点面试题】30、启用MipMaps对内存的影响是？MipMap的作用？如何操作？ 增加约33%的内存，1/4 +1/16 Lod相关知识\n31、采用Input.mousePosition来获取鼠标在屏幕上的位置 左下角为原点（0,0），右上角为（Screen.Height,Screen.Width）\n32、Unity中销毁GameObject的方式，简述Destroy和DestroyImmediate的区别 Destroy销毁消息对象，内存中还是存在，只有内存不够才被清除释放内存 DestroyImmediate立即销毁对象，并释放内存\n33、如何检测物体是否被其他对象遮挡 射线检测 EventSystem.IsPointerOverGameObject 是否具有给定 ID 的指针是否位于 EventSystem 对象上\n34、UnityAction和UnityFunc的区别 unity中需要带上修饰event，事件与委托密切相关，两行代码变一行代码 public event Action myEvent;\nUnityAction本质上就是委托，带泛型参数最多4个，且没有返回值的方法 Action\u0026lt;T1,T2,T3\u0026gt; UnityFunc本质上也是委托，带泛型参数最多4个，可以有返回值的方法 Func\u0026lt;T1,T2,T3,Return\u0026gt;\nAction和Func的重要区别： Action只用于没有返回值的方法，Func只用于有返回值的方法 它们泛型里的区别： Action的泛型里要和方法参数的类型相同，且只有一种泛型 Func的泛型里前者和方法参数类型相同，最后一个与返回值类型相同\n一般用于回调方法，注册事件，类直接数据交互松耦合 链接: [参考资料](https://blog.csdn.net/sinat_23383269/article/details/46723103?ops_request_misc=%7B%22request%5Fid%22%3A%22160671212219724847140734%22%2C%22scm%22%3A%2220140713.130102334..%22%7D\u0026amp;request_id=160671212219724847140734\u0026amp;biz_id=0\u0026amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-46723103.first_rank_v2_rank_v28p4\u0026amp;utm_term=Unity action func\u0026amp;spm=1018.2118.3001.4449).\n【重点面试题】35、unity常用资源路径有哪些\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //获取的目录路径最后不包含 / //获得的文件路径开头包含 / Application.dataPath; //Asset文件夹的绝对路径 //只读 Application.streamingAssetsPath; //StreamingAssets文件夹的绝对路径（要先判断是否存在这个文件夹路径） Application.persistentData ; //可读写 //资源数据库 (AssetDatabase) 是允许您访问工程中的资源的 API AssetDatabase.GetAllAssetPaths; //获取所有的资源文件（不包含meta文件） AssetDatabase.GetAssetPath(object) //获取object对象的相对路径 AssetDatabase.Refresh(); //刷新 AssetDatabase.GetDependencies(string); //获取依赖项文件 Directory.Delete(p, true); //删除P路径目录 Directory.Exists(p); //是否存在P路径目录 Directory.CreateDirectory(p); //创建P路径目录 AssetDatabase //类库，对Asset文件夹下的文件进行操作，获取相对路径，获取所有文件，获取相对依赖项 Directory //类库，相关文件夹路径目录进行操作，是否存在，创建目录，删除等操作 复制\n【重点面试题】36、向量的点乘、叉乘以及归一化的意义？、 叉乘cross：可以获得两个向量A和B所构成平面，垂直的向量C，和左手坐标系类似，可以用来判断角色移动方向，判断顺时针还是逆时针旋转\n点乘 dot ：用来求向量之间的夹角，判断向量是否在同一方向、以及B向量在A向量上的投影\na·b\u0026gt;0 方向基本相同，夹角在0°到90°之间 a·b=0 正交 a·b\u0026lt;0 方向基本相反，夹角在90°到180°之间\n归一化normalized：用在只关系方向，不关心大小的情况下\n三、Unity性能优化（必问）（已更新2021.3.8） lod 是什么，优缺点是什么 MipMap 是什么？作用？ 当游戏中需要频繁创建一个物体对象时，我们需要怎么做来节省内存。 如何优化内存？ 动态加载资源的方式？和区别 请简述一下对象池原理,什么情况下使用？ 19.使用mipmap有什么好处？什么情况下使用？ Unity内存优化？GC垃圾回收 你认为unity在开发过程中哪些地方比较容易造成内存泄漏和内存泄漏问题？如何避免？ 如何解决过多创建和删除对象带来的卡顿问题 Unity资源加载的有几种方式，简述asset bundie 背包系统中只有20个格子，现在有总共有100个物体，除了显示在视野中的20个外，对其他的处理方法？（注：将其他隐藏起来不可行，对象池得有具体的说明）\n四、设计模式 1、用过哪些设计模式？ 谈谈自己比较熟悉的设计模式 链接: 学习资料网站. 创建型：工厂方法、抽象工厂、单例、原型、生成器 结构型：代理、外观、组合、适配器、装饰、桥接、享元 行为：迭代器、中介者、观察者、策略、状态、命令、访问者、模板方法、备忘录、责任链\n1）工厂方法模式 面试题 在父类中提供一个创建对象的方法，在其子类中决定实例化对象的类型。 优点：单一职责，开闭，里氏替换LSP，依赖抽象DIP，迪米特法则DP 缺点：每一次增加一个具体产品，都需要增加一个具体类和对应的具体工厂，代码复杂度就成倍增加，增加了系统具体类的依赖。 学习链接: 工厂方法模式.\n2）抽象工厂模式：创建一系列相关的对象，而无需指定具体类。简记超级工厂创建其它工厂。 优点：单一职责、开闭、LSP、DIP、DP 缺点：引入众多接口和类，代码复杂度增加 抽象工厂通常基于一组工厂方法\n3）单例模式 【面试题】 保证一个类只有一个实例，并提供一个访问实例的全局节点。 单例 （Singleton） 类声明了一个名为 get­Instance获取实例的静态方法来返回其所属类的一个相同实例。 单例的构造函数必须对客户端 （Client） 代码隐藏。 调用获取实例方法必须是获取单例对象的唯一方式。 优点：解决了2个问题 缺点：违反单一职责原则，开闭原则。 Unity中的单例模式和不继承MonoBehaviord的普通单例模式。 应用例子：游戏中各种各样的管理器Manager 隐藏游戏体：obj.hideFlags = HideFlags.HideAndDontSave 链接: 我的两种单例模式代码.\n4）状态模式 面试题 是一种行为设计模式，在对象的内部发生状态改变时改变其行为 解决大量if else 或者switch 多状态的情形 代码结构 客户端：新建具体状态，并且调用具体行为 状态控制器：状态属性，转换状态方法，调用状态的具体行为 状态父类或接口：控制器属性，设置控制器方法（保存控制器），抽象行为 具体状态：继承状态，重写为具体行为 链接: 参考资料代码. 优点：单一、开闭、控制器和父类状态封装，只需要注重具体状态类行为修改。易于维护和扩展、减少因新增状态对原因脚本进行大量修改，每个状态只需要维护自己，多项目开发、易于维护 缺点：状态较少的情况下就小题大做 举个例子：场景状态，主场景状态，加载场景状态，战斗场景状态，3个场景的切换\n5）观察者模式 【面试题】 是一种行为设计模式，允许你定义一种订阅通知机制 代码结构 发布者：当新事件发生后，向其他对象发送自己所订阅的事件，发送通知方法。 订阅者接口：声明了通知方法Update更新 具体订阅者：可以执行一些操作来响应发布者的消息。 客户端：分别创建发布者和订阅者对象，然后为订阅者注册发布者更新 优点：开闭，迪米特法则，建立对象之间联系，数据松耦合 缺点：通知顺序是随机的 中介者和观察者相似\n6)中介者模式 是一种行为设计模式，减少对象之间混乱无序的依赖关系，对象之间通过中介者对象进行合作。现实世界：飞机塔台调度 代码结构 N个组件：各种包含业务逻辑的类 中介者接口：接口申明了与组件的交流方式，通知 具体中介者：封装了多种组件间的关系。 组件并不知道其它组件的情况，组件如果发生变化，通知中介者，然后判断并发送给相应的其它组件。接受者和发送者不知道谁来处理请求和谁发出的请求 优点：单一、开闭、减少个组件的依赖关系，复用各个组件 缺点：\n2、请说出 4 种面向对象的设计原则，并分别简述它们的含义 0、单一职责原则 一个类实现一个功能\n1、开闭原则OCP（Open Close Principle） 对扩展开放，对修改关闭。\n2、里氏代换原则LSP（Liskov Substitution Principle） 任何基类可以出现的地方，子类一定可以出现，即子类一定可以替换其基类。\n3、依赖倒转原则DIP（Dependence Inversion Principle） 针对接口编程，依赖于抽象而不依赖于具体。\n4、接口隔离原则ISP（Interface Segregation Principle） 使用多个隔离的接口，比使用单个接口要好。 它还有另外一个意思是：降低类之间的耦合度。\n5、迪米特法则，又称最少知道原则DP（Demeter Principle） 一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。\n6、合成复用原则CRP（Composite Reuse Principle） 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。\n3、设计一个状态机类型，状态值为int类型，要求： 拥有接口，获取当前状态，切换状态 外部可以监听状态切换事件，参数为切换前状态和切换后状态（使用delete和event）\n4、如何处理unity中界面资源，界面逻辑以及功能模块三者之间的耦合关系\n5、什么是MVC模式\n五、Unity编辑器基础 1、请描述游戏动画有几种，以及其原理。 关键帧动画：每一帧动画序列当中包含了顶点的空间位置信息以及改变量，然后通过插值运算，得出动画效果。选中某一游戏对象，创建animation，添加属性Transform，MeshRender、collider。还可以添加关键帧，在关键帧上Add Animation Event事件。 骨骼动画：模型当中有一个骨骼结构层次的对象，存储了各个骨骼在空间内的位置信息。皮肤蒙皮附着在骨骼上，决定了角色的外观，每一个顶点数据都会随着多个骨骼影响而改变，从而实现动画效果。创建animator将各个动画拖入到动画状态机当中，设置参数，连接各个动画状态，在通过脚本控制来实现动画控制 关节动画：了解不多，是骨骼动画的前身，模型分成N个部分网格，分成部分动画，组成一个整体动画\n2、Avator的作用 用户提供的模型骨架和Unity的骨架结构进行适配，是一种骨架映射关系。 方便动画的重定向 AnimationType有三种类型 Humanoid人型：可以动画重定向，游戏对象挂载animator，子类原始模型+重定向模型，设置原始模型和使用模型的AnimationType为Humanoid类型 Generic非人型 Legacy旧版 Avator Mask身体遮罩，身体某一部分是否受到动画影响 反向动力学 IK，通过手或脚来控制身体其他部分\n3、物体发生碰撞的必要条件 物体A有(Collider和Rigidbody)或者CharacterController，物体B有collider rigidbody完全受物理引擎影响 CharacterController物理引擎影响受限制\n4、GUI与UGUI的优点和缺点 UGUI所见即所得，UGUI使用Canvas和事件系统，UGUI还能自适应屏幕 GUI在脚本周期中使用OnGui函数，通过脚本代码控制。OnGui性能消耗大，每一次渲染都是一个DrawCall 在手游端都在寻求原生GUI的替代方案\n5、一个场景放置多个carmera并同时处于活动状态，会发生什么 多个Camera渲染画面，受到Camera组件的属性ClearFlag、CullingMask和Depth的影响，影响最终的合成画面。\n6、使用过哪些插件 shader graph制作shader光影效果 cinemachine+timeline+postprocessingstack制作过场动画 nodecanvas制作怪物ai easytouch手游触摸控制\n7、U3D 中用于记录节点空间几何信息的组件名称，及其父类名称 Transform继承于Component继承于Object 常用脚本继承类关系 链接: 参考资料.\n8、请简述如何在不同分辨率下保持 UI 的一致性 Canvas画布设置组件CanvasScaler的分辨率模式为Scale with screen size，保持画布一定比例下随屏幕改变，画布进行缩放。 UI位置的一致性通过设置锚点，Anchor Presets锚点预设\n9、MeshFilter、MeshRender 和 SkinnedMeshRender 的关系与不同 MeshFilter网格过滤器，通过mesh属性获取模型网格 MeshRender网格渲染器，渲染Material，lighting，probe探针 SkinnedMeshRender蒙皮网格渲染器，渲染人物模型，渲染基本属性，材质，光照，探针，其他设置属性 Unity换装主要是切换Mesh、root bone和材质贴图\n10、简述 SkinnedMesh 的实现原理 SkinnedMesh蒙皮网格动画 分为骨骼和蒙皮两部分 骨骼是一个层次结构，存储了骨骼的Transform数据 蒙皮是mesh顶点附着在骨骼之上，顶点可以被多个骨骼影响，决定了其权重等， 还有将顶点从Mesh空间变换到骨骼空间~\n11、Prefab 的作用？Editor下动态创建Prefab的方式？ prefab是素材，模型，贴图，shader等默认配置的集合体，便于修改 prefab已经被序列化存储在二进制文件当中，方便传输，方便打包导出的操作 prefab是一个模板，方便进行实例化 团队协作的便捷性\n使用脚本publci字段，直接将prefab拖拽到这个字段下 Asset文件夹下，创建Resource文件夹，prefab放入，在代码里使用Resource.load(“prefab名称”)\n12、如何销毁一个 UnityEngine.Object 及其子类 Destroy\n13、为什么 Unity3D 中会发生在组件上出现数据丢失的情况？ 组件被删除了\n14、如何安全的在不同工程间安全地迁移 asset 数据？三种方法 导出包export package 将assets文件夹和libarary文件加一起迁移 unity自带的assets server功能 （不懂这个功能，上面两个方法用的多）\n15、MeshCollider 和其他 Collider 的一个主要不同点？ MeshCollider是基于顶点数据，片面组成，消耗性能 BoxCollider是基于算法的，性能好\n16、当一个细小的高速物体撞向另一个较大的物体时，会出现什么情况？如何避免？ fixedupdate中代码控制，代码中两个位置进行射线检测，射线碰撞信息 增加碰撞体体积，射线穿过，射线长度增加 rigidbody刚体设置两个参数Interpolate急速插值和CollisionDetection碰撞检测\n17、MeshRender 中 material 和 sharedmaterial 的区别？ 两者是MeshRender的属性 sharedMaterial 是共用的 Material，称为共享材质。修改共享材质会改变所用使用该材质的物体，并且编辑器中的材质设置也会改变。 material 是独立的 Material，返回分配给渲染器的第一个材质。修改材质仅会改变该物体的材质。如果该材质被其他的渲染器使用，将克隆该材质并用于当前的渲染器。\n18、用 u3d 实现 2d 游戏，有几种方式？ 摄像机改为正交模式 使用引擎改为2D系统 使用UGUI\n19、u3d 中碰撞器和触发器的区别？ 碰撞器有碰撞效果，触发器会穿过，但能检测到 collider设置属性isTrigger为True OnCollisionEnter/Stay/Exit OnTriggerEnter/Stay/Exit 触发器可以用来检测物体是否经过某片空间\n20、CharacterController 和 Rigidbody 的区别 CharacterController一般用在人型角色，继承于Collider，可以认为是受限的Rigidbody Rigidboy完全受物理引擎影响,质量，阻力等属性，Is Kinematic不受物理引擎影响，通过代码改变Transform。\n21、什么叫做链条关节 Hinge Joint，模拟两个物体之间有一个链条连接 在某个距离内只会发生移动不产生作用力，类似门的效果 超过某个距离会产生拉力，弹簧的效果\n22、unity3d 提供了几种光源，分别是什么 Direction平行光 Point点光源 Spot聚光灯 Area区域光（烘焙用）\n23、动画层(Animation Layers)的作用是什么？ 动画分层 身体部位动画分层，比如我只想动动头，身体其他部分不发生动画 可以方便处理动画区分\n24、Material 和 Physic Material 区别？ 物理材质：处理物理效果，比如滑动摩擦力，静态摩擦力，反弹等属性 Material就是普通的贴图\n25、什么是导航网格（ NavMesh）？ 用于自动寻路的网格 比如A*寻路 链接: 更加详细的参考资料.\n26、Unity 摄像机有几种工作方式，分别是什么？ 正交模式和透视模式\n27、UGUI相关概念 UGUI锚点，相对于父对象，屏幕自适应 UGUI分为世界坐标和屏幕坐标 UGUI的Image可以使用material UGUI不需要绑定collider，UI事件会拦截 UGUI通过Mask来裁剪 UGUI顺序根据Hierarchy顺序，越下面渲染在最上层\n28、Unity3d中static batching和dynamic batching 各有什么用？ 动态批处理和静态批处理，都是在一定条件下，对多次的DrawCall请求进行合并处理，减少CPU的DrawCall数量，达到提高性能的目的\n静态批处理将静态的游戏对象组合成大网格（不移动） 对游戏对象Static属性设置成batching static ， 前提要共享材质且不移动，不缩放，不旋转\n动态批处理是将很小的网格，将类似的顶点组合到一起，一次性绘制 不需要任何操作，可以旋转，缩放，移动 前提是共享材质，且不包含900顶点不超300顶点网格\n29、Unity3d中Awake和Start 谁先执行，update和fixedUpdate 有什么区别？ awake先执行，一般用来初始化成员变量 start设置物体属性和渲染 fixedUpdate固定帧渲染，用于更新渲染物理引擎 update帧渲染，用于更新操作\n30、向量的运算有哪些？Unity有哪些API可以计算 加法减法：物理上计算两个力的合力或者几个速度分量的叠加Vertor3（a1+b1,a2+b2,a3+b3） 数乘：向量与一个标量相乘，变量的正负，表示方向的正反方向变化，对向量的长度进行缩放 点乘：a点乘b得到一个标量，集合意义是a和b长度相乘再乘以两者夹角的余弦 叉乘：a叉乘b得到一个新向量，满足unity的左手坐标系\nVector3类 单位化normalized 向量长度magnitude 叉乘cross 点乘 dot 两向量夹角 angle 距离 distance 投影 project\n31、UI面板层级管理 如果分为三层结构，可以使用Unity自带的Api在Hierarchy Transofrm类 SetAsFirstSiBling 列表开头 SetAsLastSiBling 列表最后 SetSiBlingIndex 同级索引\n六、数据结构和算法（已更新2021.2.27） 1、时间复杂度解释一下 算法的时间复杂度，用来度量算法的运行时间，记作: T(n) = O(f(n))。它表示随着 输入大小n 的增大，算法执行需要的时间的增长速度可以用 f(n) 来描述。\n当 T(n) = c，c 为一个常数的时候，我们说这个算法的时间复杂度为 O(1)；如果 T(n) 不等于一个常数项时，直接将常数项省略。 因为高次项对于函数的增长速度的影响是最大的，所以我们直接忽略低次项。 因为函数的阶数对函数的增长速度的影响是最显著的，所以我们忽略与最高阶相乘的常数。 比如 T(n) = 29 ，此时时间复杂度为 O(1)。 比如 T(n) = n + 29，此时时间复杂度为 O(n)。 比如T(n) = n^3 + n^2 + 29，此时时间复杂度为 O(n^3)。 比如T(n) = 3n^3，此时时间复杂度为 O(n^3)。\n1 2 3 4 5 for (int i = 2; i \u0026lt; n; i++) { i *= 2; printf(\u0026#34;%i\\n\u0026#34;, i); } 复制\n假设循环次数为t，必有2^t \u0026lt; n t = log(2)(n)，即 T(n) = log(2)(n)，可见时间复杂度为 O(log(2)(n))，即 O(log n)。\n加入 T(n) = T(n – 1) + T(n – 2) 是一个斐波那契数列，通过归纳证明法可以证明，当 n \u0026gt;= 1 时 T(n) \u0026lt; (5/3)^n，同时当 n \u0026gt; 4 时 T(n) \u0026gt;= (3/2)^n。 所以该方法的时间复杂度可以表示为 O((5/3)^n)，简化后为 O(2^n)。\n整数反转、以及溢出问题 反转数字是个很简单的问题，只需不断取模累乘即可 int t = x%10; res = res*10 + t; 判断溢出 res \u0026lt; INT_MAX/10，这种情况无论t为多大，都不会溢出； res \u0026gt; INT_MAX/10，这种情况无论t为多小，一定会溢出； res == INT_MAX/10，其中INT_MAX=2147483647，所以当t\u0026gt;7时，会发生溢出；\n链接: [参考](https://blog.csdn.net/qq_40941722/article/details/107942259?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160973661916780271136355%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D\u0026amp;request_id=160973661916780271136355\u0026amp;biz_id=0\u0026amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-107942259.first_rank_v2_pc_rank_v29\u0026amp;utm_term=整数反转 溢出).\nUnity游戏常用洗牌算法\n【面试题】冒泡排序 冒泡排序(BubbleSort) 在排序过程中相邻元素不断比较交换，一些元素慢慢被换到最后 时间复杂度 最好时间复杂度是O（N） :相邻不需要交换 最坏时间复杂度是O（N^2）：反序文件，一直交换\n参考我的另一个博文 链接: 冒泡示意图和代码\n二分查找 二分查找：在有序的集合中搜索特定值的过程 有序集合：Collection 目标：Target 索引：Index 左右指针：Left和Right 中间指针：Middle——根据条件来确定向左查找还是向右查找\n进行二分查找的训练\n链接: leetcode二分查找算法.\n【面试题】二叉树 二叉查找树（英语：Binary Search Tree），也称为 二叉搜索树、有序二叉树（Ordered Binary Tree）或排序二叉树（Sorted Binary Tree）。\n具有下列性质的二叉树（可以是空树）：\n若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点 相比其他数据结构优势在于：查找插入的时间复杂度较低。\n为 O(logn) 最坏是O(N)\n改进版的二叉查找树可以使树高为 O(logn)，从而将最坏效率降至 O(logn)，如 AVL 树、红黑树等。\n进行二叉树的训练\n链接: leetcode二叉搜索树算法.\n== 【面试题】用栈实现队列 、 用队列实现栈 == 算法：2个栈实现队列 链接: 用栈实现队列.\n算法：2个队列实现栈 链接: 用队列实现栈.\n六、Lua语言和Xlua热更（已更新2021.3.8） 1、Lua如何调用C# 三种方式 第一种：官方不推荐 第二种：如果Resource文件下的Lua文件，使用Lua的Require函数即可 第三种：如果Lua文件是下载的，使用自定义Loader可满足\n链接: C#调用Xlua文件.\n2、C#如何调用Lua\n–\n3、资源如何打包？依赖项列表如何生成？ 1.查找指定文件夹ABResource里的资源文件 ——Directory.GetFile(资源路径) ——新建AssetBundleBuild对象 ——获取资源名称，并赋值对应AB名称 ——获取各个资源的依赖项：通过UnityEditor.AssetDataBase类获取各个资源的依赖项 2.使用Unity自带的BuildPipeline进行构建AB包 ——BuildPipeLine.BuildAssetBundles(输出AB包路径) ——File.WriteAllLines(将依赖项写入文件里)\n4.如何解析版本文件？如何加载AB包资源？具体流程是怎么样的？ 1.解析版本文件列表 ——File.ReadAllLines(读取文件列表资源路径URL) ——获取资源名称，获取AB包名称，获取依赖项，字典容器存储 ——获取Lua文件 2.加载资源 ——异步加载资源AB包，AssetBundleRequest请求，AssetBundle.LoadFromFileAsync ——先检查依赖项，再异步加载AB包依赖项 ——加载成功后都有对应的回调方法，将资源作为参数传入\n5、热更新方案有哪些？以及具体热更流程 1、整包：存放在上SteamingAssets里 ——策略：完整更新资源放在包里 ——优点：首次更新少 ——缺点：安装包下载时间长，首次安装久 2、分包 ——策略：少部分资源放在包里，大部分更新资源存放在更新资源器中 ——优点：安装包小，安装时间短，下载快 ——缺点：首次更新下载解压缩包时间旧 3、适用性 ——海外游戏大部分是使用分包策略，平台规定 ——国内游戏大部分是使用整包策略 4、文件可读写路径 ——Application.streamingAssestsPath 只读目录 ——Application.persistentDatapath 可读写目录 ——资源服务器地址URL 5、【从资源服务器】下载单个文件或多个文件 ——NetWorking.UnityWebRequest获取URL , HTTP GET , 连接资源服务器 ——获取到downloadHander的文件数据Data，完成后会回调方法，将文件Data作为参数传出 6、检查是否初次安装\n6、网络客户端C# 和 Lua\n7、Lua的GC原理是什么？如何避免GC内存泄露？\n8、简述Lua实现面向对象的原理??? 总结：对象标识、状态、类体系、继承、私有性 1.表table就是一个对象，对象具有了标识self，状态等相关操作 2. 使用参数self表示方法的该接受者是对象本身，是面向对象的核心点,冒号操作符可以隐藏该self参数 3. 类（Class）：每个对象都有一个原型，原型(lua类体系)可以组织多个对象间共享行为 4. setmetatable(A,{__index=B}) 把B设为A的原型 5. 继承（Inheritance）：Lua中类也是对象，可以从其他类（对象）中获取方法和没有的字段 6. 继承特性：可以重新定义（修改实现）在基类继承的任意方法 7. 多重继承：一个函数function用作__Index元方法，实现多重继承，还需要对父类列表进行查找方法，但多继承复杂性，性能不如单继承，优化，将继承的方法赋值到子类当中 8. 私有性（很少用）基本思想：两个表表示一个对象，第一个表保存对象的状态在方法的闭包中，第二个表用来保存对象的操作（或接口），用来访问对象本身。使第一个表完成内容私有性。\n代码举例~~\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 --类 A={ } B={ } setmetatable(A,{ __index=B}) --单继承 function Account:new(o) -- 传入self为Account o=o or { } self.__index = self --直接把表Account当做元表 setmetatable(o,self) return o end --多重继承 local function serach(k,plist) --在父类列表中查找k方法 for i = 1, #plsit do -- body local v = plist[i][k] --第i个方法K if v then return v end --V存在 end end setmetatable(c,{ __index=function(t,k) local v = search(k,parents) --serach方法（k是第K个，parents是父类列表） t[k]=v --将方法保存进t数组里 return v end}) --私有性 function newAccount(initBalance) local self = { balance = initBalance} --self表示局部表，第一个表用来保存內部状态，私有性 local withdraw = function(v) self.balance = self.balance - v end local deposit = function(v) self.balance = self.balance + v end local getbalance = function() return self.balance end return { withdraw = withdraw, deposit = deposit, getbalance = getbalance } --返回外部對象，方法名進行映射 end acc1=newAccount(100) acc1.deposit(10) print(acc1.getbalance()) --答案是110 复制\n9、简述Lua有哪8个类型?简述用途? nil 空——可以表示无效值，全局变量（默认赋值为nil），赋值nil ，使其被删除 number 整数 table 表 —— string 字符 userdata 自定义 function 函数 bool 布尔 thread线程\n七、实际面试中遇到的问题 （已更新2021.3.8） 以下是面试中，通过各种方式收集到的今年的面试问题，因为各个公司侧重点都不尽相同，只列出题目，不列出答案。 部分答案，上面已包含。\n1 、同步的细节处理 2 、BUFF影响，数值回滚 3、 复杂动画转换过渡，融合底层逻辑 4 、曲线运动碰撞检测不到 5、 帧同步，如何侦测不同步，为啥就不同步了 6、 发射子弹的状态同步 7 、状态同步的缺点优点 8、组件系统，组件设计游戏的方式，以游戏驱动的设计模式，ECS架构 9 、技能系统架构\n1.值类型和引用类型区别，数组是什么类型？字符串？接口？结构体里有引用类型，引用类型内存在什么地方开辟？结构体呢？有一个Class类，里面有IntIE在哪类型字段，分别在哪？值类型的基类？装箱操作实际发生了什么？ 2.在函数里参数传递，值类型和引用类型的区别 3.值类型在函数的传参可以改变，该怎么做 4.装箱和拆箱的区别 5.有无event关键字修饰的delegate有什么区别 6.委托赋值的是实例方法和静态方法的区别，得到的委托有什么区别 7.字符串拼接为什么要用stringbuilder 8.abc将c替换d，abcd会产生哪些字符串 9.List容器的作用和特点 10.dictionary作用和内部实现原理 11.100个元素集合分别用list（key每一个元素的字段）和 dictionary（key），查找元素，两者的时间复杂度 12.泛型是什么 13.ArrayList和List作为泛型，有存储差别吗 14.异常机制 15.using的作用 16.接口和类的继承区别 17.lambda表达式的作用 18lambda什么情况下产生闭包 19.哈希表的实现原理 20.单链表翻转，adcde，转换成 edcba , 怎么做 21、有了解寻路算法？A*算法实现思路？\n1.面向对象OOP的特性有哪些？结合具体案例说一下。 2.协程，进程，线程有什么区别，协程能够举个例子吗？ 3.冒泡排序怎么做？时间复杂度？ 4.二叉树是怎么样的？如果将每一个叶子节点输出？具体算法如何实现？ 5.MMO项目，背包系统是如何实现的？ 6.MMO项目，道具系统的道具是如何实现的？ 7.MMO项目，资源管理是如何实现的？ 8.XLua项目里，lua怎么调用C#的？\n1.string str = “ ” 和 string str = null 有什么区别？ 2.unicode 和 utf-8 有什么区别？ 3.有一头母猪，它每年年初生一头小母猪。每头小母猪从第4个年头开始，每年年初也生一头小母 猪。请编程实现在第n年的时候，共有多少头母猪？ 4.分析以下代码，完成填空。 string strTmp = “abcdefg某某某”; int i= System.Text.Encoding.Default.GetBytes(strTmp).Length; int j= strTmp.Length; 以上代码执行完后，i= 13__ j= *10* 5.什么是DrawCall，如何减少DrawCall？ 6.如何使Camera只观察指定对象？ 7.Leetcode：堆栈实现队列。 8.LeetCode：单链表，输出倒数第2个，奇数个节点输出数据，节点倒序？ 9.Lua的基本数据结构 10.lua如何实现面向对象 11.lua的垃圾回收机制原理是怎么样的 12.lua可以做哪些优化？\n1.如何实现lua面向对象编程 2.lua里表和元表是什么 3.状态同步是如何实现的 4.状态同步网络卡顿如何解决 5.项目的使用什么架构框架体系？ 6.使用Protobuf的优点 – 平台无关，语言无关，可扩展； - 提供了友好的动态库，使用简单； - 解析速度快，比对应的XML快约20-100倍； - 序列化数据非常简洁、紧凑，与XML相比，其序列化之后的数据量约为1/3到1/10。\n1.简述Lua实现面向对象的原理 2.lua中如何避免内存泄露 3.实现一个不规则形状的UI图标（元贴图是方形不透明，请简述可行的方法和原理） 4.在游戏中实现轮廓描边效果的方案及原理 5.简述一种手机UI分辨率适配的方法 6.有数组TArray A ,请写for循坏删除其中值大于0的元素 7.背包系统性能优化方案~\n1.n个六面筛子，扔出来，综合大于S的概率 2.战士暴击率6%，打40次，求暴击几率 3.mipmap的作用 4.判断2个平面是否相交 5.单链表，求倒数第二个元素 6.背包道具装备到身上如何实现\n","description":"","id":1,"section":"posts","tags":["Unity"],"title":"2022年Unity面试题分享","uri":"https://popo-blog.vercel.app/posts/2023-05-13_02-26-34/"},{"content":"1.如何安全的在不同工程间安全地迁移asset数据？三种方法 答：1.将Assets目录和Library 和Projectsetting目录一起迁移\n2.导出包\n3.用版本控制工具Git。 unity自带的assets Server功能\n3. 简述Unity3D支持的作为脚本的语言的名称 答：Unity脚本语言基于Mono的.Net平台运行，可以使用.Net库，为数据库、XML、正则表达式提供了很好的解决方案\n4..Net与Mono关系 答：Mono是.Net的一个开源跨平台工具，就类似java虚拟机，java本身不是跨平台语言，但运行在虚拟机上就能够实现了跨平台。.net只能在windows下运行，mono可以实现跨平台跑，可以运行于linux，Unix，Mac OS等。\n一：什么是协同程序？\n在主线程运行的同时开启另一段逻辑处理，来协助当前程序的执行，协程很像多线程，但是不是多线程，Unity的协程实在每帧结束之后去检测yield的条件是否满足。\n二：Unity3d中的碰撞器和触发器的区别？\n碰撞器是触发器的载体，而触发器只是碰撞器身上的一个属性。当Is Trigger=false时，碰撞器根据物理引擎引发碰撞，产生碰撞的效果，可以调用OnCollisionEnter/Stay/Exit函数；当Is Trigger=true时，碰撞器被物理引擎所忽略，没有碰撞效果，可以调用OnTriggerEnter/Stay/Exit函数。如果既要检测到物体的接触又不想让碰撞检测影响物体移动或要检测一个物件是否经过空间中的某个区域这时就可以用到触发器\n三：物体发生碰撞的必要条件？\n两个物体都必须带有碰撞器（Collider），其中一个物体还必须带有Rigidbody刚体，而且必须是运动的物体带有Rigidbody脚本才能检测到碰撞。\n四：请简述ArrayList和List的主要区别？\nArrayList存在不安全类型（ArrayList会把所有插入其中的数据都当做Object来处理），装箱拆箱的操作（费时），List是泛型类，功能跟ArrayList相似，但不存在ArrayList所说的问题。 五：如何安全的在不同工程间安全地迁移asset数据？三种方法\n1.将Assets目录和Library目录一起迁移\n2.导出包，export Package\n3.用unity自带的assets Server功能\n六：OnEnable、Awake、Start运行时的发生顺序？哪些可能在同一个对象周期中反复的发生\nAwake –\u0026gt;OnEnable-\u0026gt;Start，OnEnable在同一周期中可以反复地发生。\n七：MeshRender中material和sharedmaterial的区别？\n修改sharedMaterial将改变所有物体使用这个材质的外观，并且也改变储存在工程里的材质设置。不推荐修改由sharedMaterial返回的材质。如果你想修改渲染器的材质，使用material替代。\n八：Unity提供了几种光源，分别是什么\n四种。\n平行光：Directional Light\n点光源：Point Light\n聚光灯：Spot Light\n区域光源：Area Light\n九：简述一下对象池，你觉得在FPS里哪些东西适合使用对象池\n对象池就存放需要被反复调用资源的一个空间，当一个对象回大量生成的时候如果每次都销毁创建会很费时间，通过对象池把暂时不用的对象放到一个池中（也就是一个集合），当下次要重新生成这个对象的时候先去池中查找一下是否有可用的对象，如果有的话就直接拿出来使用，不需要再创建，如果池中没有可用的对象，才需要重新创建，利用空间换时间来达到游戏的高速运行效果，在FPS游戏中要常被大量复制的对象包括子弹，敌人，粒子等\n十：CharacterController和Rigidbody的区别\nRigidbody具有完全真实物理的特性，Unity中物理系统最基本的一个组件，包含了常用的物理特性，而CharacterController可以说是受限的的Rigidbody，具有一定的物理效果但不是完全真实的，是Unity为了使开发者能方便的开发第一人称视角的游戏而封装的一个组件\n十一：简述prefab的用处\n在游戏运行时实例化，prefab相当于一个模板，对你已经有的素材、脚本、参数做一个默认的配置，以便于以后的修改，同时prefab打包的内容简化了导出的操作，便于团队的交流。\n十二：请简述sealed关键字用在类声明时与函数声明时的作用\nsealed修饰的类为密封类，类声明时可防止其他类继承此类，在方法中声明则可防止派生类重写此方法。\n十三：请简述private，public，protected，internal的区别\npublic：对任何类和成员都公开，无限制访问\nprivate：仅对该类公开\nprotected：对该类和其派生类公开\ninternal：只能在包含该类的程序集中访问该类\n十四：使用Unity3d实现2d游戏，有几种方式？\n使用本身的GUI，在Unity4.6以后出现的UGUI 2.把摄像机的Projection(投影)值调为Orthographic(正交投影)，不考虑z轴；\n3.使用2d插件，如：2DToolKit，和NGUI\n十五：在物体发生碰撞的整个过程中，有几个阶段，分别列出对应的函数\n三个阶段，1.OnCollisionEnter 2.OnCollisionStay 3.OnCollisionExit\n十六：Unity3d的物理引擎中，有几种施加力的方式，分别描述出来\nrigidbody.AddForce/AddForceAtPosition，都在rigidbody系列函数中。大家可以自己去查看一下rigidbody的API\n十七：什么叫做链条关节？\nHinge Joint，可以模拟两个物体间用一根链条连接在一起的情况，能保持两个物体在一个固定距离内部相互移动而不产生作用力，但是达到固定距离后就会产生拉力。\n十八：物体自身旋转使用的函数？\nTransform.Rotate()\n十九：Unity3d提供了一个用于保存和读取数据的类(PlayerPrefs)，请列出保存和读取整形数据的函数\nPlayerPrefs.SetInt() PlayerPrefs.GetInt()\n二十：Unity3d脚本从唤醒到销毁有着一套比较完整的生命周期，请列出系统自带的几个重要的方法。\nAwake——\u0026gt;OnEnable–\u0026gt;Start——\u0026gt;Update——\u0026gt;FixedUpdate——\u0026gt;LateUpdate——\u0026gt;OnGUI——\u0026gt;OnDisable——\u0026gt;OnDestroy\n二十一：物理更新一般放在哪个系统函数里？\nFixedUpdate，固定时间间隔执行 可以在edit-\u0026gt;project setting-\u0026gt;time设置 update 是在渲染帧执行，和Update不同的是FixedUpdate是渲染帧执行，如果你的渲染效率低下的时候FixedUpdate调用次数就会跟着下降。FixedUpdate比较适用于物理引擎的计算，因为是跟每帧渲染有关。Update就比较适合做控制。\n二十二：在场景中放置多个Camera并同时处于活动状态会发生什么？\n游戏界面可以看到很多摄像机的混合。\n二十三：如何销毁一个UnityEngine.Object及其子类？\n使用Destroy()方法;\n二十四：请描述为什么Unity3d中会发生在组件上出现数据丢失的情况\n一般是组件上绑定的物体对象被删除了\n二十五：LOD是什么，优缺点是什么？\nLOD(Level of detail)多层次细节，是最常用的游戏优化技术。它按照模型的位置和重要程度决定物体渲染的资源分配，降低非重要物体的面数和细节度，从而获得高效率的渲染运算。缺点是增加了内存。\n二十六：MipMap是什么，作用？\nMipMapping：在三维计算机图形的贴图渲染中有常用的技术，为加快渲染进度和减少图像锯齿，贴图被处理成由一系列被预先计算和优化过的图片组成的文件，这样的贴图被称为MipMap。\n二十七：请描述Interface与抽象类之间的不同\n抽象类表示该类中可能已经有一些方法的具体定义，但接口就是公公只能定义各个方法的界面 ，不能具体的实现代码在成员方法中。类是子类用来继承的，当父类已经有实际功能的方法时该方法在子类中可以不必实现，直接引用父类的方法，子类也可以重写该父类的方法。实现接口的时候必须要实现接口中所有的方法，不能遗漏任何一个。\n二十八：.Net与Mono的关系？\nmono是.net的一个开源跨平台工具，就类似java虚拟机，java本身不是跨平台语言，但运行在虚拟机上就能够实现了跨平台。.net只能在windows下运行，mono可以实现跨平台跑，可以运行于linux，Unix，Mac OS等。\n二十九：简述Unity3D支持的作为脚本的语言的名称\nUnity的脚本语言基于Mono的.Net平台上运行，可以使用.NET库，这也为XML、数据库、正则表达式等问题提供了很好的解决方案。Unity里的脚本都会经过编译，他们的运行速度也很快。这三种语言实际上的功能和运行速度是一样的，区别主要体现在语言特性上。JavaScript、 C#、Boo\n三十：U3D中用于记录节点空间几何信息的组件名称，及其父类名称\nTransform 父类是 Component\n三十一：向量的点乘、叉乘以及归一化的意义？\n1.点乘描述了两个向量的相似程度，结果越大两向量越相似，还可表示投影\n2.叉乘得到的向量垂直于原来的两个向量\n3.标准化向量：用在只关系方向，不关心大小的时候\n三十二：为何大家都在移动设备上寻求U3D原生GUI的替代方案\n不美观，OnGUI很耗费时间，效率不高，使用不方便\n三十三：请简述如何在不同分辨率下保持UI的一致性\nNGUI很好的解决了这一点，屏幕分辨率的自适应性，原理就是计算出屏幕的宽高比跟原来的预设的屏幕分辨率求出一个对比值，然后修改摄像机的size。UGUI通过锚点和中心点和分辨率也解决这个问题\n三十四：什么是LightMap？\nLightMap:就是指在三维软件里实现打好光，然后渲染把场景各表面的光照输出到贴图上，最后又通过引擎贴到场景上，这样就使物体有了光照的感觉。\n三十五：Unity和cocos2d的区别\nUnity3D支持C#、javascript等，cocos2d-x 支持c++、Html5、Lua等。\ncocos2d 开源 并且免费\nUnity3D支持iOS、Android、Flash、Windows、Mac、Wii等平台的游戏开发，cocos2d-x支持iOS、Android、WP等。\n三十六：C#和C++的区别？\n简单的说：C# 与C++ 比较的话，最重要的特性就是C# 是一种完全面向对象的语言，而C++ 不是，另外C# 是基于IL 中间语言和.NET Framework CLR 的，在可移植性，可维护性和强壮性都比C++ 有很大的改进。C# 的设计目标是用来开发快速稳定可扩展的应用程序，当然也可以通过Interop 和Pinvoke 完成一些底层操作。更详细的区别大家可以参考这里\n三十七：结构体和类有何区别？\n结构体是一种值类型，而类是引用类型。（值类型、引用类型是根据数据存储的角度来分的）就是值类型用于存储数据的值，引用类型用于存储对实际数据的引用。那么结构体就是当成值来使用的，类则通过引用来对实际数据操作\n三十八：ref参数和out参数是什么？有什么区别？\nref和out参数的效果一样，都是通过关键字找到定义在主函数里面的变量的内存地址，并通过方法体内的语法改变它的大小。不同点就是输出参数必须对参数进行初始化。ref必须初始化，out 参数必须在函数里赋值。ref参数是引用，out参数为输出参数。\n三十九：C#的委托是什么？有何用处？\n委托类似于一种安全的指针引用，在使用它时是当做类来看待而不是一个方法，相当于对一组方法的列表的引用。用处：使用委托使程序员可以将方法引用封装在委托对象内。然后可以将该委托对象传递给可调用所引用方法的代码，而不必在编译时知道将调用哪个方法。与C或C++中的函数指针不同，委托是面向对象，而且是类型安全的。\n四十：C#中的排序方式有哪些？\n选择排序，冒泡排序，快速排序，插入排序，希尔排序，归并排序\n四十一：射线检测碰撞物的原理是？\n射线是3D世界中一个点向一个方向发射的一条无终点的线，在发射轨迹中与其他物体发生碰撞时，它将停止发射 。\n四十二：Unity中，照相机的Clipping Planes的作用是什么？调整Near、Fare两个值时，应该注意什么？\n剪裁平面 。从相机到开始渲染和停止渲染之间的距离。\n四十三：如何让已经存在的GameObject在LoadLevel后不被卸载掉？\nvoid Awake() { DontDestroyOnLoad(transform.gameObject); } 四十四：请简述GC（垃圾回收）产生的原因，并描述如何避免？\nGC回收堆上的内存\n避免：1.减少new产生对象的次数\n2.使用公用的对象（静态成员）\n3.将String换为StringBuilder\n四十五：反射的实现原理？\n审查元数据并收集关于它的类型信息的能力。实现原理：在运行时根据程序集及其中的类型得到元数据。下面是实现步骤：\n导入using System.Reflection;\nAssembly.Load(“程序集”)加载程序集,返回类型是一个Assembly\n得到程序集中所有类的名称\nforeach (Type type in assembly.GetTypes()) { string t = type.Name; } 4. Type type = assembly.GetType(“程序集.类名”);获取当前类的类型\nActivator.CreateInstance(type); 创建此类型实例\nMethodInfo mInfo = type.GetMethod(“方法名”);获取当前方法\nm.Info.Invoke(null,方法参数);\n四十六：简述四元数的作用，四元数对欧拉角的优点？\n四元数用于表示旋转\n相对欧拉角的优点：\n1.能进行增量旋转\n2.避免万向锁\n3.给定方位的表达方式有两种，互为负（欧拉角有无数种表达方式）\n四十七：移动相机动作在哪个函数里，为什么在这个函数里？\nLateUpdate，是在所有的update结束后才调用，比较适合用于命令脚本的执行。官网上例子是摄像机的跟随，都是所有的update操作完才进行摄像机的跟进，不然就有可能出现摄像机已经推进了，但是视角里还未有角色的空帧出现。\n四十八：GPU的工作原理\n简而言之，GPU的图形（处理）流水线完成如下的工作：（并不一定是按照如下顺序） 顶点处理：这阶段GPU读取描述3D图形外观的顶点数据并根据顶点数据确定3D图形的形状及位置关系，建立起3D图形的骨架。在支持DX8和DX9规格的GPU中，这些工作由硬件实现的Vertex Shader（定点着色器）完成。 光栅化计算：显示器实际显示的图像是由像素组成的，我们需要将上面生成的图形上的点和线通过一定的算法转换到相应的像素点。把一个矢量图形转换为一系列像素点的过程就称为光栅化。例如，一条数学表示的斜线段，最终被转化成阶梯状的连续像素点。 纹理帖图：顶点单元生成的多边形只构成了3D物体的轮廓，而纹理映射（texture mapping）工作完成对多变形表面的帖图，通俗的说，就是将多边形的表面贴上相应的图片，从而生成“真实”的图形。TMU（Texture mapping unit）即是用来完成此项工作。 像素处理：这阶段（在对每个像素进行光栅化处理期间）GPU完成对像素的计算和处理，从而确定每个像素的最终属性。在支持DX8和DX9规格的GPU中，这些工作由硬件实现的Pixel Shader（像素着色器）完成。 最终输出：由ROP（光栅化引擎）最终完成像素的输出，1帧渲染完毕后，被送到显存帧缓冲区。\n总结：GPU的工作通俗的来说就是完成3D图形的生成，将图形映射到相应的像素点上，对每个像素进行计算确定最终颜色并完成输出。\n四十九：什么是渲染管道？\n是指在显示器上为了显示出图像而经过的一系列必要操作。 渲染管道中的很多步骤，都要将几何物体从一个坐标系中变换到另一个坐标系中去。主要步骤有：\n本地坐标-\u0026gt;视图坐标-\u0026gt;背面裁剪-\u0026gt;光照-\u0026gt;裁剪-\u0026gt;投影-\u0026gt;视图变换-\u0026gt;光栅化\n五十：如何优化内存？\n有很多种方式，例如\n1.压缩自带类库；\n2.将暂时不用的以后还需要使用的物体隐藏起来而不是直接Destroy掉；\n3.释放AssetBundle占用的资源；\n4.降低模型的片面数，降低模型的骨骼数量，降低贴图的大小；\n5.使用光照贴图，使用多层次细节(LOD)，使用着色器(Shader)，使用预设(Prefab)。\n6.代码中少产生临时变量\n五十一：动态加载资源的方式？他们之间的区别\n1.Resources.Load();\n2.AssetBundle\n区别参考\n五十二：请描述游戏动画有哪几种，以及其原理？\n主要有关节动画、骨骼动画、单一网格模型动画(关键帧动画)。\n关节动画：把角色分成若干独立部分，一个部分对应一个网格模型，部分的动画连接成一个整体的动画，角色比较灵活，Quake2中使用这种动画；\n骨骼动画，广泛应用的动画方式，集成了以上两个方式的优点，骨骼按角色特点组成一定的层次结构，有关节相连，可做相对运动，皮肤作为单一网格蒙在骨骼之外，决定角色的外观；\n单一网格模型动画由一个完整的网格模型构成，在动画序列的关键帧里记录各个顶点的原位置及其改变量，然后插值运算实现动画效果，角色动画较真实。\n五十三：alpha blend工作原理\nAlpha Blend 实现透明效果，不过只能针对某块区域进行alpha操作，透明度可设。\n五十四：写出光照计算中的diffuse的计算公式\ndiffuse = Kd x colorLight x max(N*L,0)；Kd 漫反射系数、colorLight 光的颜色、N 单位法线向量、L 由点指向光源的单位向量、其中N与L点乘，如果结果小于等于0，则漫反射为0。\n五十五：两种阴影判断的方法、工作原理。\n本影和半影：参考本影和半影\n本影：景物表面上那些没有被光源直接照射的区域（全黑的轮廓分明的区域）。\n半影：景物表面上那些被某些特定光源直接照射但并非被所有特定光源直接照射的区域（半明半暗区域）\n工作原理：从光源处向物体的所有可见面投射光线，将这些面投影到场景中得到投影面，再将这些投影面与场景中的其他平面求交得出阴影多边形，保存这些阴影多边形信息，然后再按视点位置对场景进行相应处理得到所要求的视图（利用空间换时间，每次只需依据视点位置进行一次阴影计算即可，省去了一次消隐过程）\n五十六：Vertex Shader是什么，怎么计算？\n顶点着色器是一段执行在GPU上的程序，用来取代fixed pipeline中的transformation和lighting，Vertex Shader主要操作顶点。\nVertex Shader对输入顶点完成了从local space到homogeneous space（齐次空间）的变换过程，homogeneous space即projection space的下一个space。在这其间共有world transformation, view transformation和projection transformation及lighting几个过程。\n五十七：下列代码在运行中会产生几个临时对象？\nstring a = new string(“abc”); a = (a.ToUpper() + “123”).Substring(0, 2); 在C#中第一行是会报错的（Java中倒是可行）。\n应该这样初始化：\nstring b = new string(new char[]{‘a’,’b’,’c’}); 答案为：5个临时对象\n五十八：下列代码在运行中会发生什么问题？如何避免？\nList ls = new List(new int[] { 1, 2, 3, 4, 5 }); foreach (int item in ls) { Console.WriteLine(item * item); ls.Remove(item); } 产生运行时错误，在 ls.Remove(item)这行，因为foreach是只读的。不能一边遍历一边修改。\n五十九：Unity3D是否支持写成多线程程序？如果支持的话需要注意什么？\n仅能从主线程中访问Unity3D的组件，对象和Unity3D系统调用\n支持：如果同时你要处理很多事情或者与Unity的对象互动小可以用thread,否则使用coroutine。\n注意：C#中有lock这个关键字,以确保只有一个线程可以在特定时间内访问特定的对象\n六十：Unity3D的协程和C#线程之间的区别是什么？\n多线程程序同时运行多个线程 ，而在任一指定时刻只有一个协程在运行，并且这个正在运行的协同程序只在必要时才被挂起。除主线程之外的线程无法访问Unity3D的对象、组件、方法。\nUnity3d没有多线程的概念，不过unity也给我们提供了StartCoroutine（协同程序）和LoadLevelAsync（异步加载关卡）后台加载场景的方法。 StartCoroutine为什么叫协同程序呢，所谓协同，就是当你在StartCoroutine的函数体里处理一段代码时，利用yield语句等待执行结果，这期间不影响主程序的继续执行，可以协同工作。\n六十一：矩阵相乘的意义及注意点\n用于表示线性变换：旋转、缩放、投影、平移、仿射\n注意矩阵的蠕变：误差的积累\n六十二：为什么dynamic font在unicode环境下优于static font\nUnicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。\n使用动态字体时，Unity将不会预先生成一个与所有字体的字符纹理。当需要支持亚洲语言或者较大的字体的时候，若使用正常纹理，则字体的纹理将非常大。\n六十三：当一个细小的高速物体撞向另一个较大的物体时，会出现什么情况？如何避免？\n穿透（碰撞检测失败）\n六十四：请简述OnBecameVisible及OnBecameInvisible的发生时机，以及这一对回调函数的意义？\n当物体是否可见切换之时。可以用于只需要在物体可见时才进行的计算。\n六十五：什么叫动态合批？跟静态合批有什么区别？\n如果动态物体共用着相同的材质，那么Unity会自动对这些物体进行批处理。动态批处理操作是自动完成的，并不需要你进行额外的操作。\n区别：动态批处理一切都是自动的，不需要做任何操作，而且物体是可以移动的，但是限制很多。静态批处理：自由度很高，限制很少，缺点可能会占用更多的内存，而且经过静态批处理后的所有物体都不可以再移动了。\n参考\n六十六：简述StringBuilder和String的区别？\nString是字符串常量。\nStringBuffer是字符串变量 ，线程安全。\nStringBuilder是字符串变量，线程不安全。\nString类型是个不可变的对象，当每次对String进行改变时都需要生成一个新的String对象，然后将指针指向一个新的对象，如果在一个循环里面，不断的改变一个对象，就要不断的生成新的对象，所以效率很低，建议在不断更改String对象的地方不要使用String类型。\nStringBuilder对象在做字符串连接操作时是在原来的字符串上进行修改，改善了性能。这一点我们平时使用中也许都知道，连接操作频繁的时候，使用StringBuilder对象。\n六十七：Unity3D Shader分哪几种，有什么区别？\n表面着色器的抽象层次比较高，它可以轻松地以简洁方式实现复杂着色。表面着色器可同时在前向渲染及延迟渲染模式下正常工作。\n顶点片段着色器可以非常灵活地实现需要的效果，但是需要编写更多的代码，并且很难与Unity的渲染管线完美集成。\n固定功能管线着色器可以作为前两种着色器的备用选择，当硬件无法运行那些酷炫Shader的时，还可以通过固定功能管线着色器来绘制出一些基本的内容。\n六十八：已知strcpy函数的原型是：char * strcpy(char * strDest,const char * strSrc); 1.不调用库函数，实现strcpy函数。2.解释为什么要返回char *\nchar * strcpy(char * strDest,const char * strSrc) { if ((strDest==NULL)||(strSrc==NULL)) throw “Invalid argument(s)”; char * strDestCopy=strDest; while ((*strDest++=*strSrc++)!=’\\0’); return strDestCopy; } 六十九：C#中四种访问修饰符是哪些？各有什么区别？\n1.属性修饰符 2.存取修饰符 3.类修饰符 4.成员修饰符。\n属性修饰符：\nSerializable：按值将对象封送到远程服务器。\nSTATread：是单线程套间的意思，是一种线程模型。\nMATAThread：是多线程套间的意思，也是一种线程模型。\n存取修饰符：\npublic：存取不受限制。\nprivate：只有包含该成员的类可以存取。\ninternal：只有当前工程可以存取。\nprotected：只有包含该成员的类以及派生类可以存取。\n类修饰符：\nabstract：抽象类。指示一个类只能作为其它类的基类。\nsealed：密封类。指示一个类不能被继承。理所当然，密封类不能同时又是抽象类，因为抽象总是希望被继承的。\n成员修饰符：\nabstract：指示该方法或属性没有实现。\nsealed：密封方法。可以防止在派生类中对该方法的override（重载）。不是类的每个成员方法都可以作为密封方法密封方法，必须对基类的虚方法进行重载，提供具体的实现方法。所以，在方法的声明中，sealed修饰符总是和override修饰符同时使用。\ndelegate：委托。用来定义一个函数指针。C#中的事件驱动是基于delegate + event的。\nconst：指定该成员的值只读不允许修改。\nevent：声明一个事件。\nextern：指示方法在外部实现。\noverride：重写。对由基类继承成员的新实现。\nreadonly：指示一个域只能在声明时以及相同类的内部被赋值。\nstatic：指示一个成员属于类型本身，而不是属于特定的对象。即在定义后可不经实例化，就可使用。\nvirtual：指示一个方法或存取器的实现可以在继承类中被覆盖。\nnew：在派生类中隐藏指定的基类成员，从而实现重写的功能。 若要隐藏继承类的成员，请使用相同名称在派生类中声明该成员，并用 new 修饰符修饰它。\n七十：Heap与Stack有何区别？\n1.heap是堆，stack是栈。\n2.stack的空间由操作系统自动分配和释放，heap的空间是手动申请和释放的，heap常用new关键字来分配。\n3.stack空间有限，heap的空间是很大的自由区。\n七十一：值类型和引用类型有何区别？\n1.值类型的数据存储在内存的栈中；引用类型的数据存储在内存的堆中，而内存单元中只存放堆中对象的地址。\n2.值类型存取速度快，引用类型存取速度慢。\n3.值类型表示实际数据，引用类型表示指向存储在内存堆中的数据的指针或引用\n4.值类型继承自System.ValueType，引用类型继承自System.Object\n5.栈的内存分配是自动释放；而堆在.NET中会有GC来释放\n6.值类型的变量直接存放实际的数据，而引用类型的变量存放的则是数据的地址，即对象的引用。\n七十二：请写出求斐波那契数列任意一位的值得算法\n递归实现：\nint Fib1(int index) { if(index\u0026lt;1) { return -1; } if(index==1|| index==2) { return 1; } return Fib1(index-1)+Fib1(index-2); } 迭代实现：\nint Fib5(int index) { if(index\u0026lt;1) { return -1; } int a1 - 1, a2 = 1, a3 = 1; for(int i = 0; i \u0026lt; index - 2; i++) { a3=a1+a2; a1=a2; a2=a3; } return a3; } 参看更多实现方法\n七十三：协同程序的执行代码是什么？有何用处，有何缺点？\nfunction Start() { // 协同程序WaitAndPrint在Start函数内执行,可以视同于它与Start函数同步执行. StartCoroutine(WaitAndPrint(2.0)); print (“Before WaitAndPrint Finishes ” + Time.time ); } function WaitAndPrint (waitTime : float) { // 暂停执行waitTime秒 yield WaitForSeconds (waitTime); print (“WaitAndPrint “+ Time.time ); }\n作用：一个协同程序在执行过程中,可以在任意位置使用yield语句。yield的返回值控制何时恢复协同程序向下执行。协同程序在对象自有帧执行过程中堪称优秀。协同程序在性能上没有更多的开销。\n缺点：协同程序并非真线程，可能会发生堵塞。\n七十四：什么是里氏代换元则？\n里氏替换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。通俗点：就是子类对象可以赋值给基类对象，基类对象不能赋值给子类对象\n参考\n七十五：Mock和Stub有何区别？\nMock与Stub的区别：Mock:关注行为验证。细粒度的测试，即代码的逻辑，多数情况下用于单元测试。Stub：关注状态验证。粗粒度的测试，在某个依赖系统不存在或者还没实现或者难以测试的情况下使用，例如访问文件系统，数据库连接，远程协议等。\n七十六：概述序列化：\n序列化简单理解成把对象转换为容易传输的格式的过程。比如，可以序列化一个对象，然后使用HTTP通过Internet在客户端和服务器端之间传输该对象\n七十七：堆和栈的区别？\n栈通常保存着我们代码执行的步骤，如在代码段1中 AddFive()方法，int pValue变量，int result变量等等。而堆上存放的则多是对象，数据等。我们可以把栈想象成一个接着一个叠放在一起的盒子。当我们使用的时候，每次从最顶部取走一个盒子。栈也是如此，当一个方法（或类型）被调用完成的时候，就从栈顶取走，接着下一个。堆则不然，像是一个仓库，储存着我们使用的各种对象等信息，跟栈不同的是他们被调用完毕不会立即被清理掉。\n七十八：概述c#中代理和事件？\n代理就是用来定义指向方法的引用。\nC＃事件本质就是对消息的封装，用作对象之间的通信；发送方叫事件发送器，接收方叫事件接收器\n七十九：客户端与服务器交互方式有几种？\nsocket通常也称作”套接字”,实现服务器和客户端之间的物理连接，并进行数据传输，主要有UDP和TCP两个协议。Socket处于网络协议的传输层。\nhttp协议传输的主要有http协议 和基于http协议的Soap协议（web service）,常见的方式是 http 的post 和get 请求，web 服务。\n八十：Unity和Android与iOS如何交互？\nUnity可以到处Android和iOS的工程，然后通过安卓或者iOS的类去给Unity发消息，调用Unity中的方法\n八十一：如何在Unity3D中查看场景的面试，顶点数和Draw Call数？如何降低Draw Call数？\n在Game视图右上角点击Stats。降低Draw Call 的技术是Draw Call Batching\n这个在5.0以后在window-》Profiler下面，快捷键是cmd + 7（ctl + 7\n八十二：请问alpha test在何时使用？能达到什么效果？\nAlpha Test ,中文就是透明度测试。简而言之就是V\u0026amp;F shader中最后fragment函数输出的该点颜色值（即上一讲frag的输出half4）的alpha值与固定值进行比较。AlphaTest语句通常于Pass{}中的起始位置。Alpha Test产生的效果也很极端，要么完全透明，即看不到，要么完全不透明。\n八十三：UNITY3d在移动设备上的一些优化资源的方法\n1.使用assetbundle，实现资源分离和共享，将内存控制到200m之内，同时也可以实现资源的在线更新\n2.顶点数对渲染无论是cpu还是gpu都是压力最大的贡献者，降低顶点数到8万以下，fps稳定到了30帧左右\n3.只使用一盏动态光，不是用阴影，不使用光照探头\n粒子系统是cpu上的大头\n4.剪裁粒子系统\n5.合并同时出现的粒子系统\n6.自己实现轻量级的粒子系统\nanimator也是一个效率奇差的地方\n7.把不需要跟骨骼动画和动作过渡的地方全部使用animation，控制骨骼数量在30根以下\n8.animator出视野不更新\n9.删除无意义的animator\n10.animator的初始化很耗时（粒子上能不能尽量不用animator）\n11.除主角外都不要跟骨骼运动apply root motion\n12.绝对禁止掉那些不带刚体带包围盒的物体（static collider ）运动\nNUGI的代码效率很差，基本上runtime的时候对cpu的贡献和render不相上下\n13每帧递归的计算finalalpha改为只有初始化和变动时计算\n14去掉法线计算\n15不要每帧计算viewsize 和windowsize\n16filldrawcall时构建顶点缓存使用array.copy\n17.代码剪裁：使用strip level ，使用.net2.0 subset\n18.尽量减少smooth group\n19.给美术定一个严格的经过科学验证的美术标准，并在U3D里面配以相应的检查工具\n八十四：四元数有什么作用？\n对旋转角度进行计算时用到四元数\n八十五：将Camera组件的ClearFlags选项选成Depth only是什么意思？有何用处？\n如果把摄像机的ClearFlags勾选为Deapth Only,那么摄像机就会只渲染看得见的对象，把背景会完全透明，这种情况一般用在两个摄像机以上的场景中\n八十六：在编辑场景时将GameObject设置为Static有何作用？\n设置游戏对象为Static时，这些部分被静态物体挡住而不可见时，将会剔除（或禁用）网格对象。因此，在你的场景中的所有不会动的物体都应该标记为Static。\n八十七：有A和B两组物体，有什么办法能够保证A组物体永远比B组物体先渲染？\n把A组物体的渲染对列大于B物体的渲染队列，通过shader里面的渲染队列来渲染\n八十八：将图片的TextureType选项分别选为““Texture”和“Sprite”有什么区别\nSprite作为UI精灵使用，Texture作用模型贴图使用。Sprite需要2的整次幂，打包图片省资源\n八十九：问一个Terrain，分别贴3张，4张，5张地表贴图，渲染速度有什么区别？为什么？\n没有区别，因为不管几张贴图只渲染一次。\n九十：什么是DrawCall？DrawCall高了又什么影响？如何降低DrawCall？\nUnity中，每次引擎准备数据并通知GPU的过程称为一次Draw Call。DrawCall越高对显卡的消耗就越大。降低DrawCall的方法：\nDynamic Batching\nStatic Batching\n高级特性Shader降级为统一的低级特性的Shader。\n九十一：实时点光源的优缺点是什么？\n可以有cookies – 带有 alpha通道的立方图(Cubemap )纹理。点光源是最耗费资源的。\n九十二：Unity的Shader中，Blend SrcAlpha OneMinusSrcAlpha这句话是什么意思？\n作用就是Alpha混合。公式：最终颜色 = 源颜色 x 源透明值 + 目标颜色 x（1 - 源透明值）\n九十三：简述水面倒影的渲染原理\n原理就是对水面的贴图纹理进行扰动，以产生波光玲玲的效果。用shader可以通过GPU在像素级别作扰动，效果细腻，需要的顶点少，速度快\n九十四：简述NGUI中Grid和Table的作用？\n对Grid和Table下的子物体进行排序和定位\n九十五：请简述NGUI中Panel和Anchor的作用\n只要提供一个half-pixel偏移量，它可以让一个控件的位置在Windows系统上精确的显示出来（只有这个Anchor的子控件会受到影响）\n如果挂载到一个对象上，那么他可以将这个对象依附到屏幕的角落或者边缘\n3.UIPanel用来收集和管理它下面所有widget的组件。通过widget的geometry创建实际的draw call。没有panel所有东西都不能够被渲染出来,你可以把UIPanel当做Renderer\n九十六：能用foreach遍历访问的对象需要实现接口或声明*_*方法的类型\nIEnumerable；GetEnumerator\n\\1. 请简述值类型与引用类型的区别\n我是想简述下为什么第一个问题总是这个，因为所有出题的面试官都不走心的， 实际项目肯定是引用类型+值类型混用，难道你没写过? int currLevel =Game.Instance.LevelCount； 值类型包括：数值类型，结构体，bool型，用户定义的结构体，枚举，可空类型。 引用类型包括：数组，用户定义的类、接口、委托，object，字符串，null类型，类。 2.C#中所有引用类型的基类是什么 C#基类Object 包名System 3.请简述ArrayList和List的主要区别 Unity3d游戏开发过程中很少见ArrayList，都是用的List\u0026lt;\u0026gt;和[]多， ArrayList这是老C#人才会用的变量，也可能是从JAVA借鉴过来，JAVA有Hashset做数组变量， 哥一开始学C#1.0对ArrayList的框架很不能理解，ArrayList继承List觉得很多余的？ 还有问这个问题的百度一查大把，真心没几个能从历史，当前流行项目，未来趋势等各个方面分析出原因，不过分析出来也没什么乱用，面试官出题的能不能别那么懒？ ArrayList 是一个数组，继承实现了List基类，是比较传统使用的程序数组变量 List是调用List，用了C#的泛型特性 4.请简述GC（垃圾回收）产生的原因，并描述如何避免？ 下面是标准答案，其实我倒想问问，你写游戏用String??还用到StringBuilder?? CLR：公共运行时环境，管理托管堆。 CTR：设置引用类型，值类型。 GC：只负责回收托管对象，不负责回收非托管对象。\n避免：1）减少new产生对象的次数 2）使用公用的对象（静态成员） 3）将String换为StringBuilder 5.请描述Interface与抽象类之间的不同 抽象类表示该类已经有一些具体的实现，而接口只是定义各方法，并没有具提实现，子类继承抽象父类，可以只是继承部分方法或直接引用父类的方法。类实现接口必须实现该接口所有方法 6.下列代码在运行中会产生几个临时对象？ 先不论代码书写是否有错，或者命名的，每个new都会产生临时对象，()括号等同于new，那么应该是6 *假如我问面试官，这2年要如何优化，他不看标准答案，能答出来吗？（其实你的思路可能比他还清晰，因为他工作多年，几年来都不会见到这种代码，那他为什么要出这个题？别为难面试官，人家从百度抄题目下来也是不容易的） 7.下列代码在运行中会发生什么问题？如何避免？ 答：会产生运行时错误，因为foreach是只读的。不能一边遍历一边修改。 8.请简述关键字Sealed用在类声明和函数声明时的作用 答：类声明时可防止其他类继承此类，在方法中声明则可防止派生类重写此方法。 关键字Seal既然可以声明类，也可以声明方法 9.请简述private，public，protected，internal的区别 10.反射的实现原理？ （以下英文纯手打，无百度） Assembly – 程序集 Class – 类（type） Method –方法(methodinfo) Property – 属性(proinfo) 但是我好像不知道反射原理是什么， 有一个方法是Invoke(“Function_name”)在Unity3d的部分游戏源码见得比较多，作用和普通Call方法一样，虽然有些炫技，但是却是在用反射实现一些游戏逻辑，而且这个游戏逻辑在Android|IOS等平台也是运行正常，反射的作用主要是跨程序集调用，作为一个基本抽象思维的程序员，应该要理解跨当前运行时的程序集本身当然也一个程序集，C#反射能广泛应用，并且出错几乎是0的原因，应该就是C#程序集的开放，格式不变和不加密（微软本身反而不支持开源） 11，.Net与Mono的关系？ 有人说.net只能在 windows上面跑，Mono能跨平台，是.net的扩展，这说法肯定是不正确的，C#(.Net)自诞生那天起就为了超越JAVA（应该黑丝2003年，.NET一出就硬抄了JAVA所有的特性，还强调所有新特性超越JAVA），C#的GC就是对应JAVA的垃圾回收机制，可惜的是长期以来C# Framework的体积比现在2018年的JVM虚拟机jre8还大 JVM是一次书写代码，所有平台通用 那么C# Framework(.Net)肯定也是支持跨平台 嗯，MONO是？官方一大段英文其实只要看最后2个就知道based on the ECMA standards ECMA是什么鬼？你现在只要知道来自欧洲的标准就可以了 由于微软的不开源，加上.NET的体积比较大，所以开源程序员都希望找到一种可以用C#或者其他书写，却是极度简化版的.NET，结果当年欧洲某小国某程序员秘密组织找到了微软的内核CIL（Common Intermediate Language通用中间语言，也叫做MSIL微软中间语言）的一种代码指令集，CIL可以在任何支持CLI（Common Language Infrastructure，通用语言基础结构）的环境中运行 （微软一开始心比较大，目标是所有语言书写，在所有平台书运行，开发web,app等所有应用，都通过visual studio，结果被Google和乔布斯打的头低低，Google在语言性和跨平台功能一直强调领先，乔布斯主张程序即艺术，iphone1,2狠狠打了Bill Gate2下，国内的c#程序员一直以来是最低下收入的一种程序员） 当时欧洲小国的程序员，优化了CLI并做出了MonoDeveloper这个IDE工具，后来他们成立了一个Xamarim公司，现在已经被微软收购，开源的MONO也没有继续下去 Unity现在应该是基于ECMA这个协议才能得以继续使用旧版本的开源MONO而不需要和微软杠上 最近中兴被美国状告事件，类比一下MONO和微软的关系你就懂了，政治在这里不能多说，我就不提了，但学习程序以外难道你学校就没有政治课？难道你志愿不是考公务员报效国家？你不理政治，政治会来修理你。 我的推论是，mono是一种中间语言，而内核还是.net的一个简化版的虚拟机，能跨平台运行，这个虚拟机类似于jvm虚拟机，提供各种框架，API和程序执行和调用功能，但明显支持的最强语言还是C# 12.简述Unity3D支持的作为脚本的语言的名称 C# JS Boo – 这个我也不清楚 13.Unity3D是否支持写成多线程程序？如果支持的话需要注意什么？ Unity仅提供携程，让你可以安心订机票 14.Unity3D的协程和C#线程之间的区别是什么？ 线程不安全 同一个时刻只有一个coroutinue运行，但线程可以并行执行，所谓多线程。而coroutinue可以让出当前执行权限，让其他coroutinue插队执行 golang里面是goroutinue lua里面也是携程，可以订机票 Python既提供携程，也提供现成 理论上来说： 携程在服务器开发过程中比较合适，golang这种专为服务器开发的语言就提供携程让你可以预定景点门票； 线程真的很不稳定，不安全，不同的系统，例如windows vs Mac , windos vs Linux, Linux vs Unix都是实现不同的，程序员甚至需要按不同系统平台分别处理和调试； 要是你用的好，线程能订机票，而携程能做出线程的花样 15.U3D中用于记录节点空间几何信息的组件名称，及其父类名称 Transform, 父类Component 16.简述四元数的作用，四元数对欧拉角的优点？ 交通大学研究生，乐乐姐的文章必须要去看一下 1）增量旋转 2）避免万向锁 3）给定方位的表达式有2种，互为正负（欧拉角有多种） 17.向量的点乘、叉乘以及归一化的意义？ 1）点乘描述了2个方向的相似程度 2） 叉乘得到垂直于这2个的向量的一个向量 3）标准化向量，在一些方向，角度求解中应用，只关心相互间的方位，不考虑长度 18.矩阵相乘的意义及注意点 意义在于向量的变换，旋转，投影，平移 左乘和右乘，不满足交换律（这个答法比较高校书本式，缺少经验的说法） 19.为何大家都在移动设备上寻求U3D原生GUI的替代方案 这是Unity3.5的问题？现在Unity2018都快出了，你还问，面试官你到底有几年Unity经验？ 20.请简述如何在不同分辨率下保持UI的一致性 UI适配，如果你曾经很长一段时间用过flex，和cocos2dx，甚至需要你自己去写适配框架 一般的方法有，布局适配，等宽，等长，这几种方法 NGUI在UIRoot提供了这3种适配方法 21.为什么dynamic font在unicode环境下优于static font 使用动态字体时，Unity将不会预先生成一个与所有字体的字符纹理， 静态字体体积会很大 22.Render的作用？描述MeshRender和SkinnedMeshRender的关系与不同 Render就是对象在3D世界的绘制 SkinnedMeshRender都提示未来可能被放弃了，面试官这份题真的很旧了，拜托换一下，但SkinnedMeshREnder在换装插件比较流行，SkinnedMeshRenderer需要骨骼、材质、Mesh才能发挥作用，难道Unity要放弃骨骼？？ 23.简述SkinnedMesh的实现原理 根据骨骼，动态整体实现表层Mesh，相对普通mesh由不同面片堆砌，根据骨骼结构，对顶点的变换计算出不同的蒙皮，最终进行模型的渲染 24.在场景中放置多个Camera并同时处于活动状态会发生什么？ 受Camera覆盖各场景物件均同时实时绘制，主Camera视场里有多个Camera的渲染合集 25.Prefab的作用？如何在移动环境的设备下恰当地使用它？ Prefab在实例化的时候用到，主要用于经常会用到的物体做成一个集合方便反复使用，在移动环境中，由于Prefab一般体积比较大，常需要实例化，拆分成合适大小的AssetBundle，离线下载比较恰当 26.如何销毁一个UnityEngine.Object及其子类 Destory 如果是Editor自定义开发需要用DestoryImmediate 27.为什么Unity3D中会发生在组件上出现数据丢失的情况？ 对象在Editor外部被删除或者移动位置 28.如何安全的在不同工程间安全地迁移asset数据？三种方法 将Assets目录和Library目录一起迁移 导出包 用unity自带的assets Server功能 29.MeshCollider和其他Collider的一个主要不同点？ 答：Meshcollider再快也是基于V3顶点~~ 建议还是用boxcollider，boxcollider本身是基于算法，没有面的概念。 30.当一个细小的高速物体撞向另一个较大的物体时，会出现什么情况？如何避免？ 可能出现碰撞检测失败，解决方法无外乎3个 增加高速物体体积 碰撞检测判断时间缩短（Physics.SimulationStep） 控制速度 31.OnEnable、Awake、Start运行时的发生顺序？哪些可能在同一个对象周期中反复的发生？\nOnEnable \\ Awake \\ Start 反复发生的是Start，这个问题实际意义不大，好像只有DontdestoryOnload下面的对象会反复调用，但实情如何笔者表示怀疑\n谢谢评论区指正，\n反复发生的应该是:OnEnable，尽量不要在Update()写代码，所以我现在OnEnable也用的少，毕竟会多次触发的，代码最好还是一次写成，少调试，少踩坑（当然，OnEnable 一般写初始化代码，机会没在这上面踩坑过就是了）\n1 gameObject.SetActive(true);//运行时可反复设置 复制\n而Awake()是在实例化时触发，不可能实例化多次\n1 GameObject.Instatiate() 复制\n而Start()在场景运行时，场景内的每个对象都只会触发一次\n1 SceeneManager.Start() 复制\n32.请简述OnBecameVisible及OnBecameInvisible的发生时机，以及这一对回调函数的意义？ 答：当物体是否可见切换之时。可以用于只需要在物体可见时才进行的计算。 33.Unity3D如何获知场景中需要加载的数据？ Resource.Load AssetBundle 34.MeshRender中material和sharedmaterial的区别？ 修改sharedMaterial将改变所有物体使用这个材质的外观，并且也改变储存在工程里的材质设置。 不推荐修改由sharedMaterial返回的材质。如果你想修改渲染器的材质，使用material替代。\n（在Editor自定开发中，只能用sharedMaterial，sharedMaterial自动等于material）\n最近机缘巧合，居然在看Unity Editor的旧版本的源码\n内核用了c++的智能指针，里面的一个share指针，shared_ptr\u0026lt;\u0026gt;,所以有sharedMaterial一说\n还有sharedMesh,sharedShader\n指针不就是内存，指向同一内存的还不是一同修改，shared_ptr\u0026lt;\u0026gt;又有什么用?又一世纪难题\n对于面试教育，如果你记性比较好还是比较有优势的，可当你记住所有标准，又有什么用呢？\n当然记住总比记不住要好，记住好像是要有那么点优势，人生和职业生涯其实大家都差不了多少，这点笔者就不在这里展开说\n这是电视机电路\n这是手机电路\n或者里面每个晶体管，每个放大器，电容你都能看懂，但你能做个手机吗？就算你能做手机，美国会给你CPU你做手机吗？所以关键是环境，和你努力与否真没什么关系\nC#问题 1.在类的构造函数前加上static会报什么错?为什么? 答：在构造函数如果有public修饰的静态构造函数时会报：“静态构造函数中不允许出现访问修饰符”，如果什么修饰符都不加的话不会报错，静态构造函数一般是起初始化作用。\n2.C# StringBuilder类型比string类型的优势是什么? 答：StringBuilde的优势在于拼接，string的优势在于对字符串做一些处理，在使用过程中看具体的需求。\n3.C# 函数Func(string a, string b)用Lambda表达式怎么写? 答：(a,b)=\u0026gt;{}\n4.数列1,1,2,3,5,8,13\u0026hellip;第n位数是多少?用C#递归算法实现 答：\n5. 请简述值类型与引用类型的区别 答：区别： 1.值类型存储在内存栈中，引用类型数据存储在内存堆中，而内存单元中存放的是堆中\n存放的地址。 2.值类型存取快，引用类型存取慢。 3.值类型表示实际数据，引用类型表示指向存储在内存堆中的数据的指针和引用。 4.栈的内存是自动释放的，堆内存是.NET中会由GC来自动释放。 5.值类型继承自System.ValueType,引用类型继承自System.Object。\n6. 请简述ArrayList和List\u0026lt;\u0026gt;的主要区别 答：ArrayList是非泛型列表，存储数据时把所有的数据都当成object类型存储，存在装箱问题，取出来使用的时候存在拆箱问题，装箱拆箱会使性能变差，而且存在数据安全问题，但是优点在于可以让值类型和引用类型互相转换。\nList是泛型列表，在使用的时候才去定义数据类型，泛型避免了拆箱装箱的问题，存入读取速度较快，类型也更安全。\n7. 请简述GC（垃圾回收）产生的原因，并描述如何避免？ 答：GC回收堆上的内存 避免：1）减少new产生对象的次数 2）使用公用的对象（静态成员） 3）如果字符串拼接多的将String换为StringBuilder\n8. 请描述Interface与抽象类之间的不同 答：语法不同处：1.抽象类中可以有字段，接口没有。\n2.抽象类中可以有实现成员，接口只能包含抽象成员。\n3.抽象类中所有成员修饰符都可以使用，接口中所有的成员都是对外的，所以不需要修饰符修饰。\n用法不同处：1.抽象类是概念的抽象，接口关注于行为。\n1 2 3 2.抽象类的子类与父类的关系是泛化关系，耦合度较高，而实现类和接口之间是实现的关系，耦合度比泛化低。 3.一个类只能继承一个类，但是可以实现多个接口。 复制\n9.下列代码在运行中会产生几个临时对象？ string a = new string(\u0026ldquo;abc\u0026rdquo;); a = (a.ToUpper() + \u0026ldquo;123\u0026rdquo;).Substring(0, 2); 答：第一行是会出错的。应该这样初始化：\nstring b = new string(new char[]{\u0026lsquo;a\u0026rsquo;,\u0026lsquo;b\u0026rsquo;,\u0026lsquo;c\u0026rsquo;});\n3个临时对象\n10.下列代码在运行中会发生什么问题？如何避免？ List ls = new List(new int[] { 1, 2, 3, 4, 5 });\nforeach (int item in ls)\n{\nConsole.WriteLine(item * item);\n1 ls.Remove(item); 复制\n}\n答：会产生运行时错误，因为foreach是只读的。不能一边遍历一边修改。\n使用foreach时候不要对内容进行修改，如果要修改可以使用for\n11.请简述关键字Sealed用在类声明和函数声明时的作用 答：Sealed访问修饰符用于类时，该类是密封类，可防止其他类继承此类。\n在方法中使用时则可防止派生类重写此方法。\n12.请简述private，public，protected，internal的区别 答：public：对任何类和成员都公开，无限制访问 private：仅对该类公开 protected：对该类和其派生类公开 internal：只能在包含该类的程序集中访问该类 protected internal：protected + internal\n13.反射的实现原理？ 答：审查元数据并收集关于它的类型信息的能力。\n14.Net与Mono的关系？ 答：mono是.net的一个开源跨平台工具。.net只能在windows下运行，mono可以实现跨平台，可以运行于linux，Unix，Mac OS等。\n15.请说出4种面向对象的设计原则，并分别简述它们的含义。 答：1） 单一职责原则：一个类，最好只做一件事，只有一个引起它的变化.\n2） 开放－封闭原则：对于扩展是开放的，对于更改是封闭的\n3） 里氏替换原则：子类必须能够替换其基类\n4） 依赖倒置原则：依赖于抽象\n5） 接口隔离原则 ：使用多个小的专门的接口，而不要使用一个大的总接口。\n16. Hashtable是无序的吗？ 答：电脑没有绝对的无序，hashtable是通过哈希码让开发者感觉无序\n17.请简述ArrayList和List的主要区别？ ArrayList存在不安全类型（ArrayList会把所有插入其中的数据都当做Object来处理），装箱拆箱的操作（费时），List是泛型类，功能跟ArrayList相似，但不存在ArrayList所说的问题\n18.简述一下对象池，你觉得在FPS里哪些东西适合使用对象池 对象池就存放需要被反复调用资源的一个空间，当一个对象回大量生成的时候如果每次都销毁创建会很费时间，通过对象池把暂时不用的对象放到一个池中（也就是一个集合），当下次要重新生成这个对象的时候先去池中查找一下是否有可用的对象，如果有的话就直接拿出来使用，不需要再创建，如果池中没有可用的对象，才需要重新创建，利用空间换时间来达到游戏的高速运行效果，在FPS游戏中要常被大量复制的对象包括子弹，敌人，粒子等\n19.结构体和类有何区别？ 结构体是一种值类型，而类是引用类型。（值类型、引用类型是根据数据存储的角度来分的）就是值类型用于存储数据的值，引用类型用于存储对实际数据的引用。那么结构体就是当成值来使用的，类则通过引用来对实际数据操作\n20.C#的委托是什么？有何用处？ 委托类似于一种安全的指针引用，在使用它时是当做类来看待而不是一个方法，相当于对一组方法的列表的引用。用处：使用委托使程序员可以将方法引用封装在委托对象内。然后可以将该委托对象传递给可调用所引用方法的代码，而不必在编译时知道将调用哪个方法。与C或C++中的函数指针不同，委托是面向对象，而且是类型安全的。\n21.请简述sealed关键字用在类声明时与函数声明时的作用 sealed修饰的类为密封类，类声明时可防止其他类继承此类，在方法中声明则可防止派生类重写此方法。\n22.C#中的排序方式有哪些？ 鸡尾酒算法，选择排序，冒泡排序（两层for循环就是冒泡，另外理解鸡尾酒算法也就是定向冒泡排序），快速排序，插入排序，希尔排序，归并排序（可以百度学一下）\n23.请简述GC（垃圾回收）产生的原因，并描述如何避免？ GC回收堆上的内存\n避免：1.减少new产生对象的次数\n2.使用公用的对象（静态成员） 3.将String换为StringBuilder\n24.反射的实现原理？ 审查元数据并收集关于它的类型信息的能力。实现原理：在运行时根据程序集及其中的类型得到元数据。下面是实现步骤：\n导入using System.Reflection;\nAssembly.Load(“程序集”)加载程序集,返回类型是一个Assembly\n得到程序集中所有类的名称\nforeach (Type type in assembly.GetTypes()) { string t = type.Name; }\nType type = assembly.GetType(“程序集.类名”);获取当前类的类型 Activator.CreateInstance(type); 创建此类型实例\nMethodInfo mInfo = type.GetMethod(“方法名”);获取当前方法\nm.Info.Invoke(null,方法参数);\nUnity问题 UI 1.NGUI Button怎样接受用户点击并调用函数,具体方法名称是什么？ 答： 1.直接监听事件：在按钮上绑定一个带有OnClick脚本，但这种方法不太好用，也不灵活。\n2.ButtonScript：在按钮上添加BoxCollider，在添加ButtonScript脚本，把要调用的方法放到场景中一个物体上，一般放在摄像机上，因为摄像机一直存在，然后把这个方法添加到ButtonScript脚本里写好的委托里面，所以可以添加多个方法，一旦点击就触发事件。\n2.请简述NGUI中Panel和Anchor的作用 答：Panel是一个容器，它将包含所有UI小部件，并负责将所包含的部件组合优化，以减少绘制命令的调用。\nAnchor是NGUI中屏幕分辨率的自适应性，来适应不同的分辨率的屏幕显示。\n3.为何大家都在移动设备上寻求U3D原生GUI的替代方案 答：1.不美观\n2.OnGUI很耗费时间\n3.使用不方便\ndrawcall很高 4.使用原生GUI创建一个可以拖动的窗口命令是什么？ 答：GUI.DragWindow()\n4.动态加载资源的方式？他们之间的区别 1.Resources.Load();\n2.AssetBundle\n5.使用Unity3d实现2d游戏，有几种方式？ 答：1.使用本身的GUI\n2.把摄像机的Projection(投影)值调为Orthographic(正交投影)，不考虑z轴\n3.使用2d插件，如：2DToolKit\n碰撞 6.怎么判断两个平面是否相交?不能用碰撞体,说出计算方法 答：在两个平面上分别取一个向量，然后看是否相交\n7.MeshCollider和其他Collider的一个主要不同点？ 答：MeshCollider是网格碰撞器，对于复杂网状模型上的碰撞检测，比其他的碰撞检测精确的多，但是相对其他的碰撞检测计算也增多了，所以一般使用网格碰撞也不会在面数比较高的模型上添加，而会做出两个模型，一个超简模能表示物体的形状用于做碰撞检测，一个用于显示。\n8.Unity3d中的碰撞器和触发器的区别？ 答：1.碰撞器物体不能互相进入到对方内部，触发器可以\n2.触发器角色控制器可以使用，碰撞器中不能使用\n3.触发器没有物理属性了，碰撞器可以有力存在\n4.碰撞器调用OnCollisionEnter/Stay/Exit函数，触发器调用OnTriggerEnter/Stay/Exit函数\n9.物体发生碰撞的必要条件 答：两个物体都必须带有碰撞器(Collider)，其中一个物体还必须带有Rigidbody刚体。\nCharacterController和Rigidbody的区别？\nCharacterController自带胶囊碰撞器，里面包含有刚体的属性；\nRigidbody就是刚体，使物体带有刚体的特征。\n10.当一个细小的高速物体撞向另一个较大的物体时，会出现什么情况？如何避免？ 答：穿透（碰撞检测失败）\n避免的方法：把刚体的实时碰撞检测打开Collision Detection修改为Continuous Dynamic\n在unity3d中物体发生碰撞的整个过程中，有几个阶段，分别列出对应的阶段函数\n主要是三个阶段：1.Collider.OnCollisionEnter 进入碰撞， OnCollisionEnter is called when this collider/rigidbody has begun touching another rigidbody/collider. 当collider/rigidbody开始触动另一个rigidbody/collider时OnCollisionEnter被调用。 2.Collider.OnCollisionStay 逗留碰撞， OnCollisionStay is called once per frame for every collider/rigidbody that is touching rigidbody/collider. 每个collider/rigidbody触动rigidbody/collider，将在每帧调用OnCollisionStay。通俗的说， 一个碰撞器或刚体触动另一个刚体或碰撞器，在每帧都会调用OnCollisionStay，直到它们之间离开不接触。 3.Collider.OnCollisionExit 退出碰撞， OnCollisionExit is called when this collider/rigidbody has stopped touching another rigidbody/collider. 当 collider/rigidbody停止触动另一个 rigidbody/collider时，OnCollisionExit被调用。\n11.CharacterController和Rigidbody的区别 Rigidbody具有完全真实物理的特性，Unity中物理系统最基本的一个组件，包含了常用的物理特性，而CharacterController可以说是受限的的Rigidbody，具有一定的物理效果但不是完全真实的，是Unity为了使开发者能方便的开发第一人称视角的游戏而封装的一个组件\n12.简述prefab的用处 在游戏运行时实例化，prefab相当于一个模板，对你已经有的素材、脚本、参数做一个默认的配置，以便于以后的修改，同时prefab打包的内容简化了导出的操作，便于团队的交流。\n动画 11.一个简单的游戏,怪物会走动\\攻击\\死亡,游戏角色会走动,跳跃\\攻击\\格挡\\死亡,还会接受玩家从输入端输入的指令,NPC会走动,他们彼此之间可以互相通信.请画出以上三种角色的UML图示. 答：\n12.请描述游戏动画有哪几种，以及其原理？ 答：主要有关节动画、单一网格模型动画(关键帧动画)、骨骼动画。\n1.关节动画：把角色分成若干独立部分，一个部分对应一个网格模型，部分的动画连接成一个整体的动画，角色比较灵活，Quake2中使用这种动画。\n2.单一网格模型动画由一个完整的网格模型构成，在动画序列的关键帧里记录各个顶点的原位置及其改变量，然后插值运算实现动画效果，角色动画较真实。\n3.骨骼动画，广泛应用的动画方式，集成了以上两个方式的优点，骨骼按角色特点组成一定的层次结构，有关节相连，可做相对运动，皮肤作为单一网格蒙在骨骼之外，决定角色的外观，皮肤网格每一个顶点都会受到骨骼的影响，从而实现完美的动画。\n13.反向旋转动画的方法是什么？ 答： 反转动画，将动画的速度调到-1。\n14.写出Animation的五个方法 答：AddClip 添加剪辑、Blend 混合、Play 播放、Stop 停止、Sample 采样 、CrossFade淡入淡出切换动画、IsPlaying是否正在播放某个动画\n15.动画层(AnimationState Layers)的作用是什么？ 答：动画层作为一个具有层级动画编辑概念的工具，可以用来制作和处理任何类型的动画\n16.Itween插件的作用是什么，Itween作用于世界坐标还是局部坐标，请列举出3个其常用方法？ 答：ITween是补间动画的一个插件，主要作用就是给出开始、结束的值、时间，此插件实现各种动画，晃动，旋转，移动，褪色，上色，音量控制等等。\n方法：1.MoveTo 物体移动\n2.ColorTo：随着时间改变对象的颜色组\n3.LookTo：随时间旋转物体让其脸部朝向所提供的Vector3或Transform位置\n17.法线贴图 、CG动画 ？ 答：法线贴图：是一种特殊的纹理，可以应用在3D表面，让低模呈现出更明显的凹凸效果。一般应用在CG动画、美术效果要求较高的单机游戏\nCG动画：游戏中的CG动画其实是用3D模拟引擎制作的游戏短片，一般画面效果比较真实。\n线程和协程 18.Unity3D是否支持写成多线程程序？如果支持的话需要注意什么？ 答：Unity支持多线程，如果同时要处理很多事情或者与Unity的对象互动小可以用thread,否则使用coroutine。\n注意：1.虽然支持多线程，但是仅能从主线程中访问Unity3D的组件，对象和Unity3D系统调用，所以如果使用的话需要把组件中的数值传到开启的新线程中。 2.C#中有lock这个关键字,以确保只有一个线程可以在特定时间内访问特定的对象\n19.Unity3D的协程和C#线程之间的区别是什么？ 答：多线程程序同时运行多个线程，除主线程之外的线程无法访问Unity3D的对象、组件、方法，而在任一指定时刻只有一个协程在运行。\n20.什么是协同程序？ 答：在主线程运行时同时开启另一段逻辑处理，来协助当前程序的执行。换句话说，开启协程就是开启一个线程。可以用来控制运动、序列以及对象的行为。\n四元数 21.四元数是什么？主要作用什么？对欧拉角的优点是什么？ 答：所谓四元数，就是把4个实数组合起来的东西。4个元素中，一个是实部，其余3个是虚部\n作用：四元数用于表示旋转 优点： 1）能进行增量旋转 2）避免万向锁 3）给定方位的表达方式有两种，互为负（欧拉角有无数种表达方式）\n四元数不会有欧拉角存在的 gimbal lock 问题[万向节死锁]\n四元数由4个数组成，旋转矩阵需要9个数\n两个四元数之间更容易插值\n四元数、矩阵在多次运算后会积攒误差，需要分别对其做规范化(normalize)和正交化 (orthogonalize)，对四元数规范化更容易\n与旋转矩阵类似，两个四元组相乘可表示两次旋转\n摄像机 22.在场景中放置多个Camera并同时处于活动状态会发生什么？ 答：游戏界面可以看到很多摄像机的混合\n23.Unity摄像机有几种工作方式，分别是什么？ 答：正交和透视\n正交无法看到一个物体距离自己有多远，或者远近的变化，物体也不会随着距离而收缩，所以一般做2D游戏或者是UI时会使用正交摄像机。\n透视一般看物体会随着距离有大小的变化，一般3D游戏里经常使用这种摄像机。\n预制物 24.Prefab的作用？如何在移动环境的设备下恰当地使用它？ 答：Prefab是预制物，一般当游戏中需要频繁创建一个物体时，使用预制物可以节省内存，方便创建，方便对游戏物体进行操作，方便对属性进行修改。\nunity 当需要频繁创建一个物体对象时，怎样减少内存 答:动态加载再实例化，如果自己不主动清理内存的话，再次加载不会增加内存的，会自动去取之前已经加载好的assets，如果这一个assets你都嫌多的话，那你只能减资源了，比如，模型面数，纹理尺寸等\nShader 25.出光照计算中的diffuse的计算公式 答：实际光照强度l=环境光（lambient）+漫反射光（Idiffuse）+镜面高光（lspecular）\n1 2 3 环境光：lambient=环境光强度（Aintensity）*环境光颜色（Acolor） 漫反射光：ldiffuse=镜面光照强度（Dintensity）*镜面光颜色（Scolor）*（光的反射向量（R）.观察者向量（V））^镜面光指数（n） 复制\n26.MeshRender中material和shader的区别？ 答：MeshRender是模型渲染的组件，有此组件物体才能显示出来\nMaterial是材质球，实际就是shader的实例，并进行赋值，贴图、纹理、颜色等。\nShader是着色器，实际上是一段程序，还可以用来实现一些仅靠贴图不容易实现的效果，如玻璃。\nShader大致分为：1.表面着色器\n2.顶点和片元着色器\n3.固定功能着色器\n27.alpha blend工作原理 答：Alpha Blend是 实现透明效果，Color = 原颜色alpha/255+目标色（255-alpha）/255\n28.光照贴图 的优势是什么？ 答：1.使用光照贴图比使用实时光源渲染要快\n2.可以降低游戏内存消耗\n3.多个物体可以使用同一张光照贴图\n29.Vertex Shader是什么，怎么计算？ 答：顶点着色器：顶点着色器是一段执行在GPU上的程序，用来取代fixed pipeline中的\ntransformation和lighting，Vertex Shader主要操作顶点。\nVertex Shader对输入顶点完成了从local space到homogeneous space（齐次空间）的变换过程，homogeneous space即projection space的下一个space。在这其间共有world transformation, view transformation和projection transformation及lighting几个过程。\n.unity3d提供了几种光源，分别是什么\n答：4种，Directionl light ,Point Light ,Spot Light,Area Light\nUnity系统API 物理更新一般在哪个系统函数里？ 答：FixedUpdate，每固定帧绘制时执行一次，和update不同的是FixedUpdate是渲染帧执行，如果你的渲染效率低下的时候FixedUpdate调用次数就会跟着下降。FixedUpdate比较适用于物理引擎的计算，因为是跟每帧渲染有关。Update就比较适合做控制。\n30.OnEnable、Awake、Start运行时的发生顺序？哪些可能在同一个对象周期中反复的发生？ 答：Awake –\u0026gt;OnEnable-\u0026gt;Start OnEnable在同一周期中可以反复地发生\n31.Unity3d脚本从唤醒到销毁有着一套比较完整的生命周期，请列出系统自带的几个重要的方法。 答：Awake——\u0026gt;Start——\u0026gt;Update——\u0026gt;FixedUpdate——\u0026gt;LateUpdate——\u0026gt;OnGUI——\u0026gt;Reset——\u0026gt;OnDisable——\u0026gt;OnDestroy\n32.物理更新一般放在哪个系统函数里？ 答：FixedUpdate因为不受到计算机帧频的影响，所以比较适合于做物理方面的更新。\n33.移动摄像机的动作放在哪个系统函数中，为什么放在这个函数中？ 答：LateUpdate，在每帧执行完毕调用，它是在所有Update结束后才调，比较适合用于命令脚本的执行。官网上例子是摄像机的跟随，都是在所有Update操作完才跟进摄像机，不然就有可能出现摄像机已经推进了，但是视角里还未有角色的空帧出现。\n34.请简述OnBecameVisible及OnBecameInvisible的发生时机，以及这一对回调函数的意义？ 答： 当物体是否可见切换之时。可以用于只需要在物体可见时才进行的计算。 当renderer(渲染器)在任何相机上都不可见时调用：OnBecameInvisible 当renderer(渲染器)在任何相机上可见时调用：OnBecameVisible\n35.Unity3d提供了一个用于保存和读取数据的类(PlayerPrefs)，请列出保存和读取整形数据的函数 答：PlayerPrefs.SetInt()\nPlayerPrefs.GetInt()\n36.动态加载资源的方式？区别是什么？ 答：1.Resources.Load();\n2.AssetBundle\n区别：\nResources是动态内部调用，Resources在编辑环境下是project窗口的一个文件夹，调用里面的资源，可以用Resources类，比如Resources.Load，打包后这个文件夹是不存在的，会统一生成assets资源，AssetBundle 是外部调用，要用AssetBundle 首先要先把资源打包为.assetbundle文件，再动态的去加载这个文件，本地或者网络服务器都可以。 简单说，Resources资源的加载是动态加载内部的，AssetBundle 是动态加载外部的\n37.以下哪个函数在游戏进入新场景后会被马上调用？ 答：MonoBehaviour.OnLevelWasLoaded\n38.如何销毁一个UnityEngine.Object及其子类对象 答：Destory\n39.获取、增加、删除组件的命令分别是什么？ 答：获取：GetComponent\n增加：AddComponent\n没有删除组件只有让组件不生效：enable\n40.Application.loadLevel命令是什么？ 答：加载关卡\n41.调试记录到控制台的命令是什么？ 答： Debug.Log();\n42.LayerMask.NameToLayer()这个方法有什么作用？ 答：层索引\n43.localPosition与Position的使用区别？ 答：localPosition：自身位置，相对于父级的变换的位置，局部坐标其实就是自身的坐标，会随着物体的旋转而变化的。\nPosition：在世界坐标transform的位置，世界坐标是不会变的，一直以世界坐标轴的XYZ为标准。\n44.物体自身旋转使用的函数？ 答：Transform.Rotate()\n45.物体围绕某点旋转使用的函数？ 答：Transform.RotateAround()\n46.U3D中用于记录节点空间几何信息的组件名称，及其父类名称 答：Transform 父类是 Component\n47.写一个计时器工具，从整点开始计时，格式为：00:00:00 答：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 int scend； int minte； int hour； void Start（） { scend=0； minte=0； hour=0； } void Update（） { If（scend\u0026lt;60） { Scend+=time.deltime; } Else { Scend-=60; Minte+=1; } If(minte\u0026gt;=60) { Minte-=60; Hour+=1; } } 复制\n物理引擎 48.\u0026lt;愤怒的小鸟\u0026gt;给予初速度以后,怎么让小鸟受到重力和空气阻力的影响而绘制抛物线轨迹,说出具体的计算方法. 答：添加刚体使小鸟模拟受到重力影响。\n49.实现吊机吊物体的功能 50.上机题：用鼠标实现在场景中拖动物体，用鼠标滚轮实现缩放(用一个Cube即可)。 答：在场景中添加一个Plan，Camera，Directional Light，Cube。添加两个脚本scrollerScirpt（挂在Camera），CubeDragScript（挂在Cube上）。\n1.鼠标滚轮实现缩放：将摄像机的镜头拉近或者拉远，调整摄像机的视角就可以实现，主要实现代码如下：\n2.鼠标实现在场景中拖动物体：\n解决思路就是将世界坐标转换成屏幕坐标，然后计算物体与鼠标之间移动量，循环鼠标被按下操作，得到鼠标的当前位置，加上计算好的移动量，将新的坐标赋值给物理就行了。主要是开启一个协同程序（Corountine）来处理\n51.Material和Physic Material区别？ 答：PhysicMaterial 物理材质：主要是控制物体的摩擦，弹力等物理属性。\nMaterial材质：主要是控制一个物体的颜色，质感等显示。\n52.CharacterController和Rigidbody的区别？ 答：CharacterController自带胶囊碰撞器，里面包含有刚体的属性；\nRigidbody就是刚体，使物体带有刚体的特征。\n53.Unity3d的物理引擎中，有几种施加力的方式，分别描述出来 答：rigidbody.AddForce/AddForceAtPosition，都在rigidbody系列函数中。\n54.什么叫做链条关节？ 答：Hinge Joint，可以模拟两个物体间用一根链条连接在一起的情况，能保持两个物体在一个固定距离内部相互移动而不产生作用力，但是达到固定距离后就会产生拉力。\n55.什么是导航网格（ NavMesh）？ 答： Unity内一种用于实现自动寻路的网格\n56.Unity3d提供了几种光源类型，分别是哪几种？ 答：四种。\n平行光：Directional Light\n点光源：Point Light\n聚光灯：Spot Light\n区域光源：Area Light\nUnity引擎问题 57.简述Unity3D支持的作为脚本的语言的名称 答：Unity的脚本语言基于Mono的.Net平台上运行，可以使用.NET库，这也为XML、数据库、正则表达式等问题提供了很好的解决方案。 Unity里的脚本都会经过编译，他们的运行速度也很快。这三种语言实际上的功能和运行速度是一样的，区别主要体现在语言特性上。 JavaScript C# Boo 目前已经取消了其他两种的语言，只剩下C#\n58.向量的点乘、叉乘以及归一化的意义？ 答：1）点乘计算两个向量之间的夹角，还可表示某一方向的投影 2）叉乘得到的是法向量 3）标准化向量：用在只关系方向，不关心大小的时候\n59.矩阵相乘的意义及注意点？ 答：用于表示线性变换：旋转、缩放、投影、平移、仿射 注意：矩阵的蠕变：误差的积累\n60.为什么dynamic font在unicode环境下优于static font？ 答：Unicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。 使用动态字体时，Unity将不会预先生成一个与所有字体的字符纹理。当需要支持亚洲语言或者较大的字体的时候，若使用正常纹理，则字体的纹理将非常大。\n61.Render的作用？描述MeshRender和SkinnedMeshRender的关系与不同 答：render是渲染器，渲染器可以使物体显示在屏幕上。\nMeshRender是网格渲染，SkinnedMeshRender是蒙皮网格渲染器\n62.简述SkinnedMesh的实现原理(这是模型相关的) 答：骨骼蒙皮动画，模型本身是静态的，是因为通过蒙皮，使模型每个点都有Skin数据，Skin数据包括顶点受到哪些骨骼影响以及这些骨骼影响顶点的权重值，还有动画数据，有了Skin数据的模型就可以根据动画数据进行显示动画了。\n63.为什么Unity3D中会发生在组件上出现数据丢失的情况？ 答：组件上绑定的对象被删除了\n64.如何安全的在不同工程间安全地迁移asset数据？三种方法 答： 1）将Assets目录和Library目录一起迁移\n2）导出资源包\n3）用unity自带的assets Server功能（了解就行）\n65.Lod是什么，优缺点是什么？ 答：LOD是Level of detail简称，意为多层次细节，是最常用的游戏优化技术，LOD技术指根据物体模型的几点在显示环境中所处的位置和重要性，决定物体渲染的资源分配，降低非重要物体的面数和细节度，从而获得高效率的渲染运算。\n优点：可根据距离动态的选择渲染不同细节的模型\n缺点：增加美工工作量，增大了游戏的容量。\n66.两种阴影判断的方法、工作原理。 答：自身阴影：因物体自身的遮挡而使光线照射不到它上面的某些可见面\n工作原理：利用背面剔除的方法求出，即假设视点在点光源的位置。\n投射阴影：因不透明物体遮挡光线使得场景中位于该物体后面的物体或区域收不到光照照射而形成的阴影。\n工作原理：从光源处向物体的所有可见面投射光线，将这些面投影到场景中得到投影面，再将这些投影面与场景中的其他平面求交得出阴影多边形，保存这些阴影多边形信息，然后在按视点位置对场景进行相应处理得到所要求的师徒（利用空间换时间，每次只需依据视点位置进行一次阴影计算即可，省去了一次消隐过程）若是动态光源此方法就无效了。\n67.MipMap是什么，作用？ 答：MipMapping：在三维计算机图形的贴图渲染中有常用的技术，为加快渲染进度和减少图像锯齿，贴图被处理成由一系列被预先计算和优化过的图片组成的文件，这样的贴图被称为MipMap。\n68.用代码实现第三角色控制器 代码自己写出来\n69.Mecanim系统中，Body Mask的作用是？ 答：指定身体的某一部分是否参与渲染 即身体遮罩\n70.Unity连接数据库 答：需要得到Mono.Data.Sqlite.dll 文件与System.Data.dll文件 （可以说这一块不太了解）\n71.如何优化内存？ 答：1.压缩自带类库\n2.将暂时不用的以后还需要使用的物体隐藏起来而不是直接Destroy掉\n3.释放AssetBundle占用的资源\n4.降低模型的片面数，降低模型的骨骼数量，降低贴图的大小\n5.使用光照贴图\n6.使用多层次细节(LOD)\n7.使用着色器(Shader)\n8.使用预设(Prefab)等\n72.你用过哪些插件？ 答：NGUI/DF/ITeen/可以自己去找一些插件使用一下。或则看我博客的几款插件使用\n在哪个模块下可以修改Render Path? a. Camera\nb. Light\nc. Render settings\nd. ProjectSetting=》Player=》OtherSettings\n图形图像 1.什么是渲染管道？ 答：是指在显示器上为了显示出图像而经过的一系列必要操作。\n渲染管道中的很多步骤，都要将几何物体从一个坐标系中变换到另一个坐标系中去。\n主要有三步：应用程序阶段，几何阶段 光栅阶段\n本地坐标-\u0026gt;视图坐标-\u0026gt;背面裁剪-\u0026gt;光照-\u0026gt;裁剪-\u0026gt;投影-\u0026gt;视图变换-\u0026gt;光栅化。\n2.什么是矢量图 ？ 答：计算机中显示的图形一般可以分为两大类——矢量图和位图。矢量图使用直线和曲线来描述图形，这些图形的元素是一些点、线、矩形、多边形、圆和弧线等等，它们都是通过数学公式计算获得的。例如一幅花的矢量图形实际上是由线段形成外框轮廓，由外框的颜色以及外框所封闭的颜色决定花显示出的颜色。由于矢量图形可通过公式计算获得，所以矢量图形文件体积一般较小。矢量图形最大的优点是无论放大、缩小或旋转等不会失真；最大的缺点是难以表现色彩层次丰富的逼真图像效果。\n3.什么是矩阵？矩阵运算？ 答：矩阵：横轴排列的二维数据表格\n矩阵运算：\n加减 限制条件：行和列必须相同，对应相加相减得到结果\n乘法 限制条件：要求左矩阵的行和右矩阵的列必须同，行数和左矩阵相等，列数和右矩阵相等，结果的第i行第j列，是左矩阵的第i行和右矩阵的第j列逐个相乘并把结果相加，得到结果是结果 的 第i行第j列\n4.角度和弧度的转换 答：角度和弧度\n度和弧度之间的换算 1弧度 = 180度 /pi（约57.3）\n1 1度=pi/180弧度（约0.017） 复制\n5.矢量标量 答：矢量有方向如力速度 标量只有大小没有方向如温度\n矢量取模就是只要大小不要方向\n^单位向量 有方向 大小为1的向量\n矢量的加法：是矢量的几何和，服从平行四边形规则\n矢量满足交换律，满足结合律\n在直角坐标系中，矢量等于骑在坐标轴上投影的矢量之和（二维矢量可以看做三维矢量的特例也就是说 三维成立，二维也成立）\n矢量减法：\n大小相等 方向相反 称为逆矢量\n任意多个矢量首尾相连接组成闭合多边形，其结果必为0\n矢量的乘法：点积（内积、标量积）、叉积（外积）结果是矢量\n点积方法 dot\n","description":"","id":2,"section":"posts","tags":["unity"],"title":"unity面试","uri":"https://popo-blog.vercel.app/posts/2023-05-13_02-19-06/"},{"content":"armv7、armv6的python包下载地址\nhttps://www.piwheels.org/simple/包名/ 修改pip镜像源 pip3 config set global.index-url https://www.piwheels.org/simple ","description":"","id":3,"section":"posts","tags":["armv7"],"title":"armv7、armv6的python包下载地址","uri":"https://popo-blog.vercel.app/posts/2023-04-25_13-42-45/"},{"content":"1. 指定域名不使用代理 import os import requests os.environ[\u0026#39;NO_PROXY\u0026#39;] = \u0026#39;stackoverflow.com\u0026#39; response = requests.get(\u0026#39;http://www.stackoverflow.com\u0026#39;) 2. 设置代理为None import requests proxies = { \u0026#34;http\u0026#34;: None, \u0026#34;https\u0026#34;: None, } requests.get(\u0026#34;http://example.org\u0026#34;, proxies=proxies) 3. 设置trust_env = False import requests session = requests.Session() session.trust_env = False response = session.get(\u0026#39;http://www.stackoverflow.com\u0026#39;) ","description":"","id":4,"section":"posts","tags":["requests","python"],"title":"python2.7 requests不使用系统代理","uri":"https://popo-blog.vercel.app/posts/2023-04-25_11-48-01/"},{"content":"解决方案 #清除缓存文件 git rm -r --cached . git add . git commit -m \u0026#34;.gitignore重写缓存成功\u0026#34; git push 重新提交后发现.gitignore文件生效了\n原理解读 .gitignore文件只会在第一次提交项目的时候写入缓存，也就是说如果你第一次提交项目时候忘记写.gitignore文件，后来再补上是没有用的，.gitignore文件是不生效的。因为在缓存中已经标记该项目不存在ignore文件了（boolean）\n所以我们使用git rm -r \u0026ndash;cached .去清除所有的缓存。然后再次提交代码就可以了，这样.gitignore文件就会生效了。\n","description":"","id":5,"section":"posts","tags":["git"],"title":".gitignore清除缓存生效","uri":"https://popo-blog.vercel.app/posts/2023-03-16_11-58-55/"},{"content":"flv.js API 本文档使用类似TypeScript的定义来描述接口。\n接口 flv.js将所有接口都以flvjs对象暴露在全局上下文window中.\nflvjs 还可以通过require或ES6导入来访问对象。\n方法:\nflvjs.createPlayer() flvjs.isSupported() flvjs.getFeatureList() 类:\nflvjs.FlvPlayer flvjs.NativePlayer flvjs.LoggingControl 枚举:\nflvjs.Events flvjs.ErrorTypes flvjs.ErrorDetails flvjs.createPlayer() 1 function createPlayer(mediaDataSource: MediaDataSource, config?: Config): Player; 根据中指定的type字段创建一个播放器实例mediaDataSource（可选）config。\nMediaDataSource Field Type Description type string 媒体类型，\u0026lsquo;flv\u0026rsquo;或\u0026rsquo;mp4\u0026rsquo; isLive? boolean 数据源是否为实时流 cors? boolean 是否启用CORS进行http提取 withCredentials? boolean 是否对Cookie进行http提取 hasAudio? boolean 流是否有音频轨道 hasVideo? boolean 流中是否有视频轨道 duration? number 总媒体持续时间（以毫秒为单位） filesize? number 媒体文件的总文件大小，以字节为单位 url? string 表示媒体URL，可以以\u0026rsquo;https(s)\u0026lsquo;或\u0026rsquo;ws(s)\u0026rsquo;（WebSocket）开头 segments? Array\u0026lt;MediaSegment\u0026gt; 多段播放的可选字段，请参见MediaSegment 如果segments存在字段，则transmuxer会将其MediaDataSource视为多部分源。\n在多部分模式下，结构中的duration filesize url字段MediaDataSource将被忽略。\nMediaSegment Field Type Description duration number 必填字段，指示段持续时间（以毫秒为单位） filesize? number 可选字段，指示段文件大小（以字节为单位） url string 必填字段，指示段文件URL Config Field Type Default Description enableWorker? boolean false 启用分离的线程进行转换（暂时不稳定） enableStashBuffer? boolean true 启用IO隐藏缓冲区。如果您需要实时（最小延迟）来进行实时流播放，则设置为false，但是如果网络抖动，则可能会停顿。 stashInitialSize? number 384KB 指示IO暂存缓冲区的初始大小。默认值为384KB。指出合适的尺寸可以改善视频负载/搜索时间。 isLive? boolean false 同样要isLive在MediaDataSource，如果忽略已经在MediaDataSource结构集合。 lazyLoad? boolean true 如果有足够的数据可播放，则中止http连接。 lazyLoadMaxDuration? number 3 * 60 指示要保留多少秒的数据lazyLoad lazyLoadRecoverDuration? number 30 指示lazyLoad恢复时间边界，以秒为单位。 deferLoadAfterSourceOpen? boolean true 在MediaSource sourceopen事件触发后加载。在Chrome上，在后台打开的标签页可能不会触发sourceopen事件，除非切换到该标签页。 autoCleanupSourceBuffer boolean false 对SourceBuffer进行自动清理 autoCleanupMaxBackwardDuration number 3 * 60 当向后缓冲区持续时间超过此值（以秒为单位）时，请对SourceBuffer进行自动清理 autoCleanupMinBackwardDuration number 2 * 60 指示进行自动清除时为反向缓冲区保留的持续时间（以秒为单位）。 fixAudioTimestampGap boolean true 当检测到较大的音频时间戳间隙时，请填充无声音频帧，以避免A / V不同步。 accurateSeek? boolean false 精确查找任何帧，不限于视频IDR帧，但可能会慢一些。可用的Chrome \u0026gt; 50，FireFox和Safari。 seekType? string 'range' \u0026lsquo;range\u0026rsquo;使用范围请求进行搜索，或\u0026rsquo;param\u0026rsquo;在url中添加参数以指示请求范围。 seekParamStart? string 'bstart' 指示的搜索起始参数名称 seekType = \u0026lsquo;param\u0026rsquo; seekParamEnd? string 'bend' 指示的搜索结束参数名称 seekType = \u0026lsquo;param\u0026rsquo; rangeLoadZeroStart? boolean false Range: bytes=0-如果使用范围查找，则发送首次负载 customSeekHandler? object undefined 指示自定义搜索处理程序 reuseRedirectedURL? boolean false 重复使用301/302重定向的url进行子序列请求，例如搜索，重新连接等。 referrerPolicy? string no-referrer-when-downgrade 指示使用FetchStreamLoader时的推荐人策略 headers? object undefined 指示将添加到请求的其他标头 flvjs.isSupported() 1 function isSupported(): boolean; 如果基本上可以再您的浏览器上播放则返回true\nflvjs.getFeatureList() 1 function getFeatureList(): FeatureList; 返回FeatureList具有以下详细信息的对象：\nFeatureList Field Type Description mseFlvPlayback boolean 与flvjs.isSupported()相同，表示您的浏览器是否可以进行基本播放。 mseLiveFlvPlayback boolean HTTP FLV实时流是否可以在您的浏览器上工作。 networkStreamIO boolean 指示网络加载程序是否正在流式传输。 networkLoaderName string 指示网络加载程序类型名称。 nativeMP4H264Playback boolean 指示您的浏览器是否本身支持H.264 MP4视频文件。 nativeWebmVP8Playback boolean 指示您的浏览器是否本机支持WebM VP8视频文件。 nativeWebmVP9Playback boolean 指示您的浏览器是否本机支持WebM VP9视频文件。 flvjs.FlvPlayer 1 interface FlvPlayer extends Player {} 实现Player接口的FLV播放器。可以通过new操作进行创建\nflvjs.NativePlayer 1 interface NativePlayer extends Player {} Player wrapper for browser\u0026rsquo;s native player (HTMLVideoElement) without MediaSource src, which implements the Player interface. Useful for singlepart MP4 file playback.\nPlayer 接口 (抽象) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 interface Player { constructor(mediaDataSource: MediaDataSource, config?: Config): Player; destroy(): void; on(event: string, listener: Function): void; off(event: string, listener: Function): void; attachMediaElement(mediaElement: HTMLMediaElement): void; detachMediaElement(): void; load(): void; unload(): void; play(): Promise\u0026lt;void\u0026gt;; pause(): void; type: string; buffered: TimeRanges; duration: number; volume: number; muted: boolean; currentTime: number; mediaInfo: Object; statisticsInfo: Object; } flvjs.LoggingControl A global interface which include several static getter/setter to set flv.js logcat verbose level.\n一个全局接口，其中包括几个用于设置flv.js logcat详细级别的静态getter / setter。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 interface LoggingControl { forceGlobalTag: boolean; globalTag: string; enableAll: boolean; enableDebug: boolean; enableVerbose: boolean; enableInfo: boolean; enableWarn: boolean; enableError: boolean; getConfig(): Object; applyConfig(config: Object): void; addLogListener(listener: Function): void; removeLogListener(listener: Function): void; } flvjs.Events 一系列可以和 Player.on() / Player.off()一起使用的常数. 它们需要前缀flvjs.Events.\n事件 描述 ERROR 播放期间由于任何原因发生错误 LOADING_COMPLETE 输入MediaDataSource已完全缓冲到结束 RECOVERED_EARLY_EOF 缓冲期间发生意外的网络EOF，但已自动恢复 MEDIA_INFO 提供媒体的技术信息，例如视频/音频编解码器，比特率等。 METADATA_ARRIVED 用“ onMetaData”标记提供FLV文件（流）可以包含的元数据。 SCRIPTDATA_ARRIVED 提供FLV文件（流）可以包含的脚本数据（OnCuePoint / OnTextData）。 STATISTICS_INFO 提供播放统计信息，例如丢帧，当前速度等。 flvjs.ErrorTypes 播放期间可能出现的错误。它们需要前缀flvjs.ErrorTypes。\n错误 描述 NETWORK_ERROR 与网络有关的错误 MEDIA_ERROR 与媒体有关的错误（格式错误，解码问题等） OTHER_ERROR 任何其他未指定的错误 flvjs.ErrorDetails 针对网络和媒体错误提供更详细的说明。它们需要前缀flvjs.ErrorDetails。\n错误 描述 NETWORK_EXCEPTION 与网络其他任何问题有关；包含一个message NETWORK_STATUS_CODE_INVALID 与无效的HTTP状态代码（例如403、404等）相关。 NETWORK_TIMEOUT 相关超时请求问题 NETWORK_UNRECOVERABLE_EARLY_EOF 与无法恢复的意外网络EOF相关 MEDIA_MSE_ERROR 与MediaSource的错误有关，例如解码问题 MEDIA_FORMAT_ERROR 与媒体流中的任何无效参数有关 MEDIA_FORMAT_UNSUPPORTED flv.js不支持输入的MediaDataSource格式 MEDIA_CODEC_UNSUPPORTED 媒体流包含不支持的视频/音频编解码器 ","description":"","id":6,"section":"posts","tags":["flv.js"],"title":"flv.js 中文文档","uri":"https://popo-blog.vercel.app/posts/2023-03-16_18-50-53/"},{"content":"设置openwrt软件包 OPKG 基础配置 dest root / dest ram /tmp lists_dir ext /var/opkg-lists option overlay_root /overlay 发行版软件源 # add your custom package feeds here # # src/gz example_feed_name http://www.example.com/path/to/files 自定义软件源 # add your custom package feeds here # # src/gz example_feed_name http://www.example.com/path/to/files src/gz openwrt_core https://op.supes.top/targets/meson/meson8b/5.10.146 src/gz openwrt_base https://op.supes.top/packages/arm_cortex-a5_vfpv4/base src/gz openwrt_packages https://op.supes.top/packages/arm_cortex-a5_vfpv4/packages src/gz openwrt_luci https://op.supes.top/packages/arm_cortex-a5_vfpv4/luci src/gz openwrt_routing https://op.supes.top/packages/arm_cortex-a5_vfpv4/routing src/gz openwrt_kiddin9 https://op.supes.top/packages/arm_cortex-a5_vfpv4/kiddin9 ","description":"","id":7,"section":"posts","tags":["openwrt"],"title":"设置openwrt软件包","uri":"https://popo-blog.vercel.app/posts/%E8%AE%BE%E7%BD%AEopenwrt%E8%BD%AF%E4%BB%B6%E5%8C%85/"},{"content":"SmartDNS设置 https://8.8.8.8/dns-query https://8.8.4.4/dns-query https://doh.opendns.com/dns-query https://doh.dns.sb/dns-query https://dns9.quad9.net/dns-query https://1.1.1.1/dns-query 自定义设置\nbind :6453 -group GW -no-speed-check bind :5335 -group GW -no-speed-check Adguard Home 设置 上游DNS服务器\nhttps://dns.alidns.com/dns-query https://doh.pub/dns-query 设置并行请求\nBootstrap DNS 服务器\n0.0.0.0 DNS 拦截列表\nhttps://cdn.jsdelivr.net/gh/o0HalfLife0o/list@master/ad-mo.txt DNS服务配置 勾选\n启用EDNS客户端子网\n启用DNSSEC\nDNS重写 dns.alidns.com 223.6.6.6 doh.pub 1.12.12.12 设置上网域名 doh.opendns.com\ndoh.dns.sb\ndns9.quad9.net\n","description":"","id":8,"section":"posts","tags":["Openwrt,SmartDNS,Adguard "],"title":"Openwrt设置DNS分流","uri":"https://popo-blog.vercel.app/posts/openwrt%E8%AE%BE%E7%BD%AEdns%E5%88%86%E6%B5%81/"},{"content":"扩容 根目录扩容也就是把linux deploy镜像容量扩容\n第一步：用shell连接linux\n第二步：\ndd if=/dev/zero bs=1024 count=1048576 \u0026gt;\u0026gt; /mnt/sdcard/linux.img 其中\nif 表示input file，表示输入的文件，这里的输入文件为/dev/zero，也就是说扩容的时候，以/dev/zero的内容进行扩容，这里的/dev/zero的内容一般为二进制数据 bs 表示1 block = 1024字节为扩容单位，也就是1K为基本单位扩容 count 表示开辟多少个block，这里是1048576和block，大小即为：1048576/1024/1024 = 1G，也就是说，当前扩容的文件为1GB大小的空间 /mnt/sdcard/linux.img //你的镜像路径。 其他的不需要改 第三步：\ne2fsck -f /mnt/sdcard/linux.img 第四步：\nresize2fs /mnt/sdcard/linux.img 至此扩容完成，可以查看镜像文件.img已增大。\n安装服务 snapdrop\ngit clone https://github.com/Bellisario/node-snapdrop.git \u0026amp;\u0026amp; cd node-snapdrop Install all dependencies with NPM: (npm install 失败 更新nodejs)\nnpm install Start the server with:\nnode index.js Public Run If you want to run in your public \u0026ldquo;sharable\u0026rdquo; IP instead of locally, you can use this command:\nnode index.js public Remember to check your IP Address using your OS command to see where you can access the server.\n更新python\n3.3 安装Python\n回到/root继续安装Python\ncd ~ Python官网的下载页面：\nhttps://www.python.org/downloads/source/ 下载\nwget https://www.python.org/ftp/python/3.9.13/Python-3.9.13.tgz tar -zxvf Python-3.9.13.tgz cd Python-3.9.13 编译\nLD_RUN_PATH=/usr/local/lib ./configure LDFLAGS=\u0026#34;-L/usr/local/lib\u0026#34; CPPFLAGS=\u0026#34;-I/usr/local/include\u0026#34; LD_RUN_PATH=/usr/local/lib make -j8 安装\nsudo make install ","description":"","id":9,"section":"posts","tags":["Linux"],"title":"Linux Deploy使用教程","uri":"https://popo-blog.vercel.app/posts/linux-deploy/"},{"content":"1. 解除BL锁： 小米官方解锁网址\n2. 卡刷 先将手机与电脑连接以便安装好驱动（如果安装失败，可下载 MiFlash 再手动安装）。另外确保手机已完成 BL 解锁。\n电脑下载 Fastboot 工具（解压备用）和对应机型 TWRP（.img 后缀文件，将其放入前面解压的文件夹里）。\n将手机关机，长按开机键 + 音量下键进入 fastboot 模式，与电脑连接。\n电脑打开刚才解压的 platform-tools 文件夹，按住 Shift 键，同时右键点击文件夹空白处，在右键菜单点击“在此处打开 Powershell 窗口”，运行下面命令刷入 TWRP（自行替换文件名）。\n.\\fastboot flash recovery twrp-3.4.0-0-davinci.img 注：如果不希望安装 TWRP，而只是临时使用 TWRP，运行下面命令（自行替换文件名）并忽略第 5 步骤。\n.\\fastboot boot twrp-3.4.0-0-davinci.img 如果运行命令后无法启动 TWRP，一直停在开机界面，可能是 TWRP 版本适配有问题，可尝试使用第三方版。\n为防止重启手机 MIUI 自动替换回官方 Recovery，按住手机音量上键，同时电脑运行下面命令重启手机，直至进入 TWRP 界面。 .\\fastboot reboot \\6. 在进入 TWRP 后，会询问“是否保持系统分区为只读”。这里滑动按钮以允许修改 ，不然不能禁止 MIUI 替换回官方 Recovery。\n3.小米手机安装面具教程（小米手机获取root权限） 一、Bootloader解锁：Xiaomi-unlock\n如果你的手机不能解锁BL，推荐 光速虚拟机（不用解锁BL也可以刷面具）\n二、下载系统包：Get-miui\n三、获取卡刷包里面的boot.img\n四、手机插电脑，文件传输模式，复制 boot.img 和 系统包 到手机 Download 目录\n五、手机下载安装Magisk app：Magisk-download\n六、1.安装 – 2.选项 都不勾（勾了会卡米，部分手机没有选项）- 3.选择并修补一个文件\n八、4.选择boot.img – 5.开始 – 6.修补成功\n九、修补成功，会在 Download 目录生成（magisk_patched-版本_随机.img）文件，每次生成的随机字符都不一样，使用的时候请输入生成的名字。\n十、电脑下载 adb-fastboot：lanzoub.com/b02plghuh（解压出来）\n十一、手机插电脑，文件传输模式，把 boot.img 和 magisk_patched-版本_随机.img 两个文件复制到 adb-fastboot 目录\n十二、手机重启到 fastboot 模式（按电源键重启 马上按住 音量键 –）插上电脑\n十三、打开“打开CMD命令行.bat”，输入下面的命令\nfastboot flash boot 面具文件 十四、出现下面这三行代码，就是成功刷入了。\nSending \u0026#39;boot\u0026#39; (131072 KB) OKAY [ 3.311s] Writing \u0026#39;boot\u0026#39; OKAY [ 0.441s] Finished. Total time: 3.794s 十五、重启手机（开机有震动基本没问题了）耐心等手机开机。（显示Magisk的版本，就是刷好了的）\n温馨提示\n如果刷模块不兼容或者其他骚操作导致不能开机，可以把我们前面提取的boot.img通过fastboot刷回去，恢复原系统，一般都能正常开机！\nboot.img保留一份在电脑，避免出问题了可以自救下！还原boot指令\nfastboot flash boot boot.img 后期系统更新，直接下载全量完整包升级，然后重复上面的步骤就可以继续愉快的使用Magisk了！\n","description":"","id":10,"section":"posts","tags":["刷机"],"title":"红米7a刷机","uri":"https://popo-blog.vercel.app/posts/%E7%BA%A2%E7%B1%B37a%E5%88%B7%E6%9C%BA/"},{"content":"1.frp docker 安装\n服务器\n创建 touch frps.ini touch docker-compose.yml frps.ini 文件内容\n[common] #frp 监听端口，与客户端绑定端口 bind_port= 5443 kcp_bind_port = 5443 #dashboard用户名 dashboard_user= gugu #dashboard密码 dashboard_pwd= passwd #dashboard端口，启动成功后可通过浏览器访问如http://ip:9527 dashboard_port= 9527 #设置客户端token，对应客户端有页需要配置一定要记住，如果客户端不填写你连不上服务端 token = 8ad3d1x429a2d docker-compose.yml 文件内容\nversion: \u0026#39;3.3\u0026#39; services: frps: restart: always network_mode: host volumes: - \u0026#39;./frps.ini:/etc/frp/frps.ini\u0026#39; container_name: frps image: snowdreamtech/frps 启动docker docker-compose up -d 开放端口 更新镜像 docker-compose down docker-compose pull docker-compose up -d docker image prune # prune 命令用来删除不再使用的 docker 对象。删除所有未被 tag 标记和未被容器使用的镜像 卸载\ndocker stop frps docker rm -f frps # 停止容器，此时不会删除映射到本地的数据 rm -rf /root/data/docker_data/frps # 完全删除映射到本地的数据 客户端\nfrpc.ini 文件配置\n# frpc.ini [common] server_addr = 43.132.202.152 server_port = 5443 token = 8ad3d1x429a2d [ssh] type = tcp local_ip = 127.0.0.1 local_port = 222 # 这个自定义，之后再ssh连接的时候要用 remote_port = 6000 [qb] type = tcp local_ip = 127.0.0.1 local_port = 8092 remote_port = 6001 [jellyfin] type = tcp local_ip = 127.0.0.1 local_port = 32771 remote_port = 6002 [NAS] type = tcp local_ip = 127.0.0.1 local_port = 5000 remote_port = 6003 [nextcloud] type = tcp local_ip = 127.0.0.1 local_port = 4433 remote_port = 6004 [RDP] type = tcp local_ip = 127.0.0.1 local_port = 3389 remote_port = 7001 [vnc] type = tcp local_ip = 127.0.0.1 local_port = 5900 remote_port = 5900 use_encryption = true use_compression = true docker-compose 文件配置\nversion: \u0026#39;3.3\u0026#39; services: frpc: restart: always network_mode: host volumes: - \u0026#39;./frpc.ini:/etc/frp/frpc.ini\u0026#39; container_name: frpc image: snowdreamtech/frpc ","description":"","id":11,"section":"posts","tags":["内网穿透"],"title":"内网穿透","uri":"https://popo-blog.vercel.app/posts/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"content":"当前为padavan刷回官方 进入后台，系统管理，服务，打开ssh\n插入U盘\nSSH中执行\ncd /extdisks/sda1 wget http://bigota.miwifi.com/xiaoqiang/rom/r3/miwifi_r3_all_55ac7_2.11.20.bin dd if=miwifi_r3_all_55ac7_2.11.20.bin of=kernel0.bin bs=1 skip=94108 count=2284584 md5sum kernel0.bin mtd_write write kernel0.bin Firmware_Stub md5sum kernel0.bin的结果应为：62e96a64e21de9b176fd51336b963e2c\n完成后执行U盘刷机\n下载官方固件，放在u盘根目录，命名为miwifi.bin\n路由器断电，插入U盘，按住reset，插电，等待指示橙色慢闪后松开\n当前为x-wrt刷回官方，uboot为官方uboot SSH中执行\nfw_setenv flag_last_success 0 fw_setenv flag_try_sys1_failed 0 fw_setenv flag_try_sys2_failed 0 完成后执行U盘刷机 下载官方固件，放在u盘根目录，命名为miwifi.bin\n路由器断电，插入U盘，按住reset，插电，等待指示橙色慢闪后松开\n当前为pandorabox、X-wrt、openwrt刷回官方，uboot为pb-oot 进入pb-boot刷官方固件包\n完成后执行U盘刷机\n下载官方固件，放在u盘根目录，命名为miwifi.bin\n路由器断电，插入U盘，插电，等一会再按住reset（防止进入pb-boot），等待指示橙色慢闪后松开\n已刷padavan，刷pb-boot 路由器联网状态下，进入ssh，执行\ncd /tmp wget http://downloads.pangubox.com:6380/pb-boot/19.03.17/pb-boot-xiaomi3-20190317-61b6d33.img mtd_write unlock Bootloader mtd_write write pb-boot-xiaomi3-20190317-61b6d33.img Bootloader 官方固件刷pb-boot 开启SSH后，ssh中执行\ncd /tmp wget http://downloads.pangubox.com:6380/pb-boot/19.03.17/pb-boot-xiaomi3-20190317-61b6d33.img nvram set uart_en=1 nvram commit mtd write pb-boot-xiaomi3-20190317-61b6d33.img Bootloader 进入pb-boot\n按住reset，插电，1-3秒后松开，浏览器输入：192.168.1.1进入pb-boot\n刷机方法和固件\nx-wrt （优点更新较快）\nhttps://www.right.com.cn/forum/thread-261964-1-1.html\npadavan(教程中的padavan固件可更换为其它padavan,如https://github.com/hanwckf/rt-n56u/releases)\nhttps://www.right.com.cn/forum/thread-348784-1-1.html\n我自己编译的lede，源码来自lean大雕（https://github.com/coolsnowwolf/lede）\nhttps://www.right.com.cn/forum/thread-4015141-1-1.html\n刷机方法：进入pb-boot，刷入openwrt-ramips-mt7620-xiaomi_miwifi-r3-squashfs-pb-boot.bin\n我自己编译的openwrt(不太完善，推荐其它固件，源码来源：https://bitbucket.org/shibajee/openwrt/src/miwifi-r3/)\nhttps://www.right.com.cn/forum/thread-4013523-1-1.html\n刷机方法：进入pb-boot，刷入openwrt-ramips-mt7620-xiaomi_miwifi-r3-squashfs-pb-boot.bin\nPandorabox （已停更，但ipk依然很全，也比较流畅）\nhttp://downloads.pangubox.com:6380/pandorabox/19.01/targets/ralink/mt7620/PandoraBox-ralink-mt7620-xiaomi-r3-2018-12-31-git-4b6a3d5ca-squashfs-sysupgrade.bin\n刷机方法：pb-boot中直接刷\n还有其他问题多在论坛看看帖子，救砖，ttl什么的\nhttps://www.right.com.cn/forum/thread-706545-1-1.html\nhttps://www.right.com.cn/forum/thread-308330-1-1.html\nhttps://www.right.com.cn/forum/thread-342165-1-1.html\n","description":"","id":12,"section":"posts","tags":["刷机"],"title":"小米路由器3刷回官方固件","uri":"https://popo-blog.vercel.app/posts/%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A83%E5%88%B7%E5%9B%9E%E5%AE%98%E6%96%B9%E5%9B%BA%E4%BB%B6/"},{"content":"刷机有风险\n固件信息：\n下载固件\n：http://opt.cn2qq.com/padavan/MI-3_3.4.3.9-099.trx\n固件作者\n：hiboy\n固件更新\n：http://opt.cn2qq.com/\n刷完后路由器信息：\n路由IP：192.168.123.1\n登录账号：admin\n登录密码：admin\nwifi：PDCN\nwifi密码:1234567890\n#工具\nputty\nhttp://downloads.openwrt.org.cn/software/putty.zip\nwinscp\nhttp://downloads.openwrt.org.cn/software/WinSCP.rar\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n#降级\n下载降级固件：miwifi_r3_all_55ac7_2.11.20.bin\n进入路由器后台，常用设置，系统状态，手动升级，选择降级固件，勾选清除配置\n如果文件校验失败，可能文件下载不完整，重新下载。也可能是因为你的路由不是小米路由器3\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n#准备文件\n下载u-boot：\nuboot.zip (44.09 KB, 下载次数: 3526)\n下载固件：http://opt.cn2qq.com/padavan/MI-3_3.4.3.9-099.trx\n解压出\nuboot.bin\n，与固件\nMI-3_3.4.3.9-099.trx\n一起放入u盘根目录\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n#获取ssh\n方法1.官方方法获取\n打开http://d.miwifi.com/rom/ssh\n登陆后下载ssh工具，按说明使用U盘获取\n方法2.漏洞法获取\n登录后台，取得网址栏stok值替换到此处，然后在浏览器中访问，逐条进行\nhttp://192.168.31.1/cgi-bin/luci/;stok=\u0026lt;你的stok值\u0026gt;/api/xqnetwork/set_wifi_ap?ssid=tianbao\u0026amp;encryption=NONE\u0026amp;enctype=NONE\u0026amp;channel=1%3Bnvram%20set%20ssh%5Fen%3D1%3B%20nvram%20commit 返回1616正常\nhttp://192.168.31.1/cgi-bin/luci/;stok=\u0026lt;你的stok值\u0026gt;/api/xqnetwork/set_wifi_ap?ssid=tianbao\u0026amp;encryption=NONE\u0026amp;enctype=NONE\u0026amp;channel=1%3Bsed%20%2Di%20%22%3Ax%3AN%3As%2Fif%20%5C%5B%2E%2A%5C%3B%20then%5Cn%2E%2Areturn%200%5Cn%2E%2Afi%2F%23tb%2F%3Bb%20x%22%20%2Fetc%2Finit.d%2Fdropbear 返回1616正常\nhttp://192.168.31.1/cgi-bin/luci/;stok=\u0026lt;你的stok值\u0026gt;/api/xqnetwork/set_wifi_ap?ssid=tianbao\u0026amp;encryption=NONE\u0026amp;enctype=NONE\u0026amp;channel=1%3B%2Fetc%2Finit.d%2Fdropbear%20start 返回1616正常\nputty登录时，密码为web管理密码，或root密码\nroot密码在此处查看：http://d.miwifi.com/rom/ssh\n如果都无法登录，请尝试更改密码\nhttp://192.168.31.1/cgi-bin/luci/;stok=\u0026lt;你的stok值\u0026gt;/api/xqsystem/set_name_password?oldPwd=\u0026lt;你当前的后台管理密码\u0026gt;\u0026amp;newPwd=\u0026lt;新密码\u0026gt; -\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n#备份固件\n插入U盘，输入df -h\n看到Size是自己的u盘大小那一行，再看Mounted on的对应路径\n比如：/extdisks/sda1\n进入U盘根目录：cd /extdisks/sda1\nputty登录路由器\n查看分区如下，命令：cat /proc/mtd\nroot@XiaoQiang:~# cat /proc/mtd\ndev: size erasesize name mtd0: 08000000 00020000 \u0026#34;ALL\u0026#34; mtd1: 00040000 00020000 \u0026#34;Bootloader\u0026#34; mtd2: 00040000 00020000 \u0026#34;Config\u0026#34; mtd3: 00040000 00020000 \u0026#34;Bdata\u0026#34; mtd4: 00040000 00020000 \u0026#34;Factory\u0026#34; mtd5: 00040000 00020000 \u0026#34;crash\u0026#34; mtd6: 00040000 00020000 \u0026#34;crash_syslog\u0026#34; mtd7: 00080000 00020000 \u0026#34;reserved0\u0026#34; mtd8: 00400000 00020000 \u0026#34;kernel0\u0026#34; mtd9: 00400000 00020000 \u0026#34;kernel1\u0026#34; mtd10: 02000000 00020000 \u0026#34;rootfs0\u0026#34; mtd11: 02000000 00020000 \u0026#34;rootfs1\u0026#34; mtd12: 03600000 00020000 \u0026#34;overlay\u0026#34; putty中执行备份命令（0-12），备份至U盘/extdisks/sda1目录\ndd if=/dev/mtd0 of=mtd0.bin dd if=/dev/mtd1 of=mtd1.bin dd if=/dev/mtd2 of=mtd2.bin dd if=/dev/mtd3 of=mtd3.bin dd if=/dev/mtd4 of=mtd4.bin dd if=/dev/mtd5 of=mtd5.bin dd if=/dev/mtd6 of=mtd6.bin dd if=/dev/mtd7 of=mtd7.bin dd if=/dev/mtd8 of=mtd8.bin dd if=/dev/mtd9 of=mtd9.bin dd if=/dev/mtd10 of=mtd10.bin dd if=/dev/mtd11 of=mtd11.bin dd if=/dev/mtd12 of=mtd12.bin 没有u盘的可以备份至tmp目录，使用winscp下载，协议选择scp\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n#刷入u-boot\n执行以下命令\nnvram set boot_wait=on nvram set uart_en=1 nvram commit mtd write uboot.bin Bootloader -\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n#刷入固件\n执行以下命令\ndd if=MI-3_3.4.3.9-099.trx bs=4194304 count=1 2\u0026gt; /dev/null | dd of=MI-3_3.4.3.9-099.trx.part1 2\u0026gt; /dev/null dd if=MI-3_3.4.3.9-099.trx bs=4194304 skip=1 2\u0026gt; /dev/null | dd of=MI-3_3.4.3.9-099.trx.part2 2\u0026gt; /dev/null mtd write MI-3_3.4.3.9-099.trx.part1 kernel1 mtd write MI-3_3.4.3.9-099.trx.part2 rootfs0 nvram set flag_last_success=1 nvram commit 写入后可以验证一下md5\nmtd verify MI-3_3.4.3.9-099.trx.part1 kernel1 mtd verify MI-3_3.4.3.9-099.trx.part2 rootfs0 写入part1或part2时出错，显示[e]，执行以下语句，并用u盘刷官方固件\nnvram set flag_last_success=0 nvram set flag_try_sys1_failed=1 nvram set flag_try_sys2_failed=1 nvram commit -\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n#重启路由\n在putty中执行命令\nreboot\n不成功则断电重启\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n#附：检查md5命令\nmd5sum 文件名\n简单的说，有u盘，刷开发版，获取ssh，u盘内准备好要刷的u-boot和padavan固件插到路由器上，备份分区至u盘，然后刷入u-boot和固件，重启即可\n手动刷机过程中，一定要验证MD5，否则容易变砖\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n#刷回官方\n方法来自：fyi2000 https://www.right.com.cn/forum/thread-706545-1-1.html\n注意：tmp目录空间一般较小，推荐使用U盘，在u盘目录下操作\ncd /extdisks/sda1 wget -O - http://bigota.miwifi.com/xiaoqiang/rom/r3/miwifi_r3_all_55ac7_2.11.20.bin| dd of=kernel0.bin bs=1 skip=94108 count=2284584 cat kernel0.md5 62e96a64e21de9b176fd51336b963e2c kernel0.bin EOF md5sum -cw kernel0.md5 \u0026amp;\u0026amp; mtd_write write kernel0.bin Firmware_Stub 完成后按照官方U盘刷机教程刷机\nU盘刷机 1.下载官方固件，命名为miwifi.bin,放在u盘根目录\n2.路由器断电，插上u盘\n3.按住reset，可以使用牙签等，注意是按住\n4.路由器插电，等待黄灯慢闪的时候松开，刷机完成会自动重启\n","description":"","id":13,"section":"posts","tags":["刷机"],"title":"小米路由器3刷机","uri":"https://popo-blog.vercel.app/posts/%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A83%E5%88%B7%E6%9C%BA/"},{"content":"1. 如果您正使用VPN或第三方防火墙应用，建议断开 VPN，卸载第三方防火墙应用 2. 同时按【Windows 徽标键+X】，启动【Windows PowerShell（管理员）】 3. 复制（Ctrl+C）和粘贴（Ctrl+V）以下命令，按回车： netsh winsock reset netsh int ip reset ipconfig /release ipconfig /renew ipconfig /flushdns 4. 重启设备 5. 启动【Internet Explorer浏览器】，点击【设置】，打开【Internet 选项】-【高级】 6. 勾选【使用 SSL 3.0】、【使用 TLS 1.0】、【使用 TLS 1.1】、【使用 TLS 1.2】 7. 应用后重启电脑，查看问题是否被解决 ","description":"","id":14,"section":"posts","tags":["重设网络"],"title":"重设网络","uri":"https://popo-blog.vercel.app/posts/%E9%87%8D%E8%AE%BE%E7%BD%91%E8%B7%AF/"},{"content":"为什么有模块概念？\n理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。\n但是，Javascript不是一种模块化编程语言，在es6以前，它是不支持”类”（class），所以也没有”模块”（module）。\n在js里，何为“模块”？\n在js里面，我们可以把模块定义为实现特定功能的一组方法，只要把实现某一功能的函数放一起，就可以看成是一个“模块”。\n模块的基础写法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 例如： // 这是一个弹窗功能的一组方法 // 创建弹窗 function fn1(){ // do something } // 打开弹窗 function fn2(){ // do something } // 关闭弹窗 function fn3(){ // do something } 这种做法的缺点很明显：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。\n对象写法 为了解决上面这种基础写法的缺陷，我们可以把它写成一个对象，模块成员被包含在内。\n1 2 3 4 5 6 7 8 9 10 11 12 let moduleAlert = { id: 1, fn1: function { // do something }, fn2: function { // do something }, fn3: function { // do something } } 调用：\n1 2 3 moduleAlert.fn1(); moduleAlert.fn2(); moduleAlert.fn3(); 封装了一层，更加清晰，调用的时候一目了然。\n模块模式 编程语言中，比如 Java，是支持将方法声明为私有的，即它们只能被同一个类中的其它方法所调用。\n而 JavaScript 没有这种原生支持，但我们可以使用闭包来模拟私有方法。\n私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。\n下面的示例展现了如何使用闭包来定义公共函数，并令其可以访问私有函数和变量。这个方式也称为 模块模式（module pattern）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 var Counter = (function() { var privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment: function() { changeBy(1); }, decrement: function() { changeBy(-1); }, value: function() { return privateCounter; } } })(); console.log(Counter.value()); /* logs 0 */ Counter.increment(); Counter.increment(); console.log(Counter.value()); /* logs 2 */ Counter.decrement(); console.log(Counter.value()); /* logs 1 */ 该共享环境创建于一个立即执行的匿名函数体内。这个环境中包含两个私有项：名为 . privateCounter 的变量和名为 changeBy 的函数。 这两项都无法在这个匿名函数外部直接访问。必须通过匿名函数返回的三个公共函数访问。 这三个公共函数是共享同一个环境的闭包。多亏 JavaScript 的词法作用域，它们都可以访问 privateCounter 变量和 changeBy 函数。\n————————————————\n版权声明：本文为CSDN博主「欧阳呀」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/qq_35942348/article/details/110475765 ","description":"","id":15,"section":"posts","tags":["js"],"title":"js 模块化","uri":"https://popo-blog.vercel.app/posts/js-%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"content":"1. 发现兴趣相似的用户 通常用 Jaccard 公式或者余弦相似度计算两个用户之间的相似度。设 N(u) 为用户 u 喜欢的物品集合，N(v) 为用户 v 喜欢的物品集合，那么 u 和 v 的相似度是多少呢：\nJaccard 公式：\n余弦相似度：\n假设目前共有4个用户： A、B、C、D；共有5个物品：a、b、c、d、e。用户与物品的关系（用户喜欢物品）如下图所示：\n如何一下子计算所有用户之间的相似度呢？为计算方便，通常首先需要建立“物品—用户”的倒排表，如下图所示：\n然后对于每个物品，喜欢他的用户，两两之间相同物品加1。例如喜欢物品 a 的用户有 A 和 B，那么在矩阵中他们两两加1。如下图所示：\n计算用户两两之间的相似度，上面的矩阵仅仅代表的是公式的分子部分。以余弦相似度为例，对上图进行进一步计算：\n到此，计算用户相似度就大功告成，可以很直观的找到与目标用户兴趣较相似的用户。\n2. 推荐物品 首先需要从矩阵中找出与目标用户 u 最相似的 K 个用户，用集合 S(u, K) 表示，将 S 中用户喜欢的物品全部提取出来，并去除 u 已经喜欢的物品。对于每个候选物品 i ，用户 u 对它感兴趣的程度用如下公式计算：\n其中 rvi 表示用户 v 对 i 的喜欢程度，在本例中都是为 1，在一些需要用户给予评分的推荐系统中，则要代入用户评分。\n举个例子，假设我们要给 A 推荐物品，选取 K = 3 个相似用户，相似用户则是：B、C、D，那么他们喜欢过并且 A 没有喜欢过的物品有：c、e，那么分别计算 p(A, c) 和 p(A, e)：\n看样子用户 A 对 c 和 e 的喜欢程度可能是一样的，在真实的推荐系统中，只要按得分排序，取前几个物品就可以了。\n","description":"","id":16,"section":"posts","tags":["js"],"title":"基于用户的协同过滤推荐算法原理和实现","uri":"https://popo-blog.vercel.app/posts/%E5%9F%BA%E4%BA%8E%E7%94%A8%E6%88%B7%E7%9A%84%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/"},{"content":" 1 2 3 ssh-keygen -t rsa -f ~/.ssh/id_rsa_x -C \u0026#34;fourousky@163.com\u0026#34;. //一般都是保存在用户目录的.ssh文件夹下面，这里的id_rsa_x是为了和本来有的id_rsa文件作区分 touch config //编写config文件，指明路径 vim config 其中config文件主要是为了提交远程仓库的时候，ssh 做区分用的\n填写config 内容\n1 2 3 4 5 6 7 8 9 10 # 第一个账号，默认使用的账号 Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa # 第二个账号 Host second.github.com # second为前缀名，可以任意设置 HostName github.com User git IdentityFile ~/.ssh/id_rsa_x #私钥名称 1 2 3 ssh-agent bash ssh-add id_rsa # 添加私钥 ssh-add id_rsa_x 查看添加的私钥\n1 ssh-add -l 测试是否连通\n1 2 ssh -T git@github.com ssh -T git@second.github.com 使用说明\n主要区分也是通过HOST区分的，所以在以后的提交和拉去过程中，要主要，如果用的第一个，都是正常pull和push，但是对于第二个，要改成自己设置的别名second.github.com\n","description":"","id":17,"section":"posts","tags":["git","github"],"title":"git 配置多个账号","uri":"https://popo-blog.vercel.app/posts/git-%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E8%B4%A6%E5%8F%B7/"},{"content":"input 输入框 在自动填充时，背景颜色问题] 问题: 自动填充前：\n自动填充后：\n可以看出，自动填充后，input背景颜色变成了白色,\n解决办法： 纯色阴影覆盖底色 1 2 3 4 input:-webkit-autofill { box-shadow: 0 0 0 1000px #333333 inset; -webkit-text-fill-color: #fff; } 再看看，自动填充后的效果:\n注意： 这个方法有个问题，就是input 输入框，不能有 圆角(border-radius)，而且只适用于纯色背景框。\n可以看到，两边有明显的白色\n设置透明： 1 2 3 4 5 input:-internal-autofill-previewed, input:-internal-autofill-selected { -webkit-text-fill-color: #807c7c; transition: background-color 5000s ease-out 0.5s; } 效果：\n利用动画延迟 1 2 3 4 5 6 7 8 9 10 input:-webkit-autofill, input:-webkit-autofill:hover, input:-webkit-autofill:focus, input:-webkit-autofill:active { transition-delay: 99999s; transition: color 99999s ease-out, background-color 99999s ease-out; -webkit-transition-delay: 99999s; -webkit-transition: color 99999s ease-out, background-color 99999s ease-out; -webkit-text-fill-color: #807c7c; } 效果：\n","description":"","id":18,"section":"posts","tags":["input","css"],"title":"input自动填充时背景色改变问题","uri":"https://popo-blog.vercel.app/posts/input%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%E6%97%B6%E8%83%8C%E6%99%AF%E8%89%B2%E6%94%B9%E5%8F%98%E9%97%AE%E9%A2%98/"},{"content":"参数列表 /S system 指定要连接的远程系统。\n/U [domain]user 指定应该在哪个用户上下文执行这个命令。\n/P [password] 为提供的用户上下文指定密码。如果忽略，提示输入。\n/FI filter 应用筛选器以选择一组任务。允许使用 \u0026ldquo;\u0026quot;。例如，映像名称 eq acme\n/PID processid 指定要终止的进程的 PID。使用 TaskList 取得 PID。\n/IM imagename 指定要终止的进程的映像名称。通配符 \u0026lsquo;*\u0026lsquo;可用来 指定所有任务或映像名称。\n/T 终止指定的进程和由它启用的子进程。\n/F 指定强制终止进程。\n/? 显示帮助消息。\n杀死对应进程 1 2 3 4 5 6 7 taskkill /pid pid taskkill /im xxx.exe taskkill /fi \u0026#34;imagename eq xxx.exe\u0026#34; taskkill /fi \u0026#34;pid eq pid\u0026#34; 可以加 /T /F 强制终止\n1 taskkill /T /F /IM xxx ","description":"","id":19,"section":"posts","tags":["Win","TASKKILL"],"title":"Win TASKKILL 杀死进程","uri":"https://popo-blog.vercel.app/posts/win-taskkill-%E6%9D%80%E6%AD%BB%E8%BF%9B%E7%A8%8B/"},{"content":"方法出处：https://css-tricks.com/fluid-width-video/\nhtml\n1 2 3 4 5 6 \u0026lt;main\u0026gt; \u0026lt;p\u0026gt;A video!\u0026lt;/p\u0026gt; \u0026lt;iframe width=\u0026#34;560\u0026#34; height=\u0026#34;315\u0026#34; src=\u0026#34;https://www.youtube.com/embed/Vbg81kc56FU\u0026#34; frameborder=\u0026#34;0\u0026#34; allow=\u0026#34;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\u0026#34; allowfullscreen\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;p\u0026gt;That YouTube iframe is responsive via FitVids.js\u0026lt;/p\u0026gt; \u0026lt;/main\u0026gt; css\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 main { background: white; height: 100vh; max-width: 400px; margin: 0 auto; padding: 1rem; } .fitVids-wrapper { position: relative; padding-bottom: 56.25%; height: 0; } .fitVids-wrapper iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; } body { margin: 0; background-color: #eee; background-image: url(\u0026#39;data:image/svg+xml,%3Csvg width=\u0026#34;52\u0026#34; height=\u0026#34;26\u0026#34; viewBox=\u0026#34;0 0 52 26\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34;%3E%3Cg fill=\u0026#34;none\u0026#34; fill-rule=\u0026#34;evenodd\u0026#34;%3E%3Cg fill=\u0026#34;%239C92AC\u0026#34; fill-opacity=\u0026#34;0.4\u0026#34;%3E%3Cpath d=\u0026#34;M10 10c0-2.21-1.79-4-4-4-3.314 0-6-2.686-6-6h2c0 2.21 1.79 4 4 4 3.314 0 6 2.686 6 6 0 2.21 1.79 4 4 4 3.314 0 6 2.686 6 6 0 2.21 1.79 4 4 4v2c-3.314 0-6-2.686-6-6 0-2.21-1.79-4-4-4-3.314 0-6-2.686-6-6zm25.464-1.95l8.486 8.486-1.414 1.414-8.486-8.486 1.414-1.414z\u0026#34; /%3E%3C/g%3E%3C/g%3E%3C/svg%3E\u0026#39;); } js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // Vanilla version of FitVids // Still licencened under WTFPL // // Not as robust and fault tolerant as the jQuery version. // It\u0026#39;s BYOCSS. // And also, I don\u0026#39;t support this at all whatsoever. (function(window, document, undefined) { \u0026#34;use strict\u0026#34;; // List of Video Vendors embeds you want to support var players = [\u0026#39;iframe[src*=\u0026#34;youtube.com\u0026#34;]\u0026#39;, \u0026#39;iframe[src*=\u0026#34;vimeo.com\u0026#34;]\u0026#39;]; // Select videos var fitVids = document.querySelectorAll(players.join(\u0026#34;,\u0026#34;)); // If there are videos on the page... if (fitVids.length) { // Loop through videos for (var i = 0; i \u0026lt; fitVids.length; i++) { // Get Video Information var fitVid = fitVids[i]; var width = fitVid.getAttribute(\u0026#34;width\u0026#34;); var height = fitVid.getAttribute(\u0026#34;height\u0026#34;); var aspectRatio = height / width; var parentDiv = fitVid.parentNode; // Wrap it in a DIV var div = document.createElement(\u0026#34;div\u0026#34;); div.className = \u0026#34;fitVids-wrapper\u0026#34;; div.style.paddingBottom = aspectRatio * 100 + \u0026#34;%\u0026#34;; parentDiv.insertBefore(div, fitVid); fitVid.remove(); div.appendChild(fitVid); // Clear height/width from fitVid fitVid.removeAttribute(\u0026#34;height\u0026#34;); fitVid.removeAttribute(\u0026#34;width\u0026#34;); } } })(window, document); ","description":"","id":20,"section":"posts","tags":["iframe"],"title":"iframe去除黑边自适应高度","uri":"https://popo-blog.vercel.app/posts/iframe%E5%8E%BB%E9%99%A4%E9%BB%91%E8%BE%B9%E8%87%AA%E9%80%82%E5%BA%94%E9%AB%98%E5%BA%A6/"},{"content":"有些符号在URL中是不能直接传递的，如果要在URL中传递这些特殊符号，那么就要使用他们的十六进制值编码了。下表中列出了一些URL特殊符号及编码\n1. + URL 中+号表示空格 %2B 2. 空格 URL中的空格可以用+号或者编码 %20 3. / 分隔目录和子目录 %2F 4. ? 分隔实际的 URL 和参数 %3F 5. % 指定特殊字符 %25 6. # 表示书签 %23 7. \u0026amp; URL 中指定的参数间的分隔符 %26 8. = URL 中指定参数的值 %3D 解决的方法： 将字符替换为16进制编码\njs中替换字符\nreplace() 方法如果直接用str.replace(\u0026quot;-\u0026quot;,\u0026quot;!\u0026quot;) 只会替换第一个匹配的字符.\n而str.replace(/-/g,\u0026quot;!\u0026quot;)则可以替换掉全部匹配的字符(g为全局标志)。\nreplace()\njs中替换字符变量如下：\n1 2 3 data2=data2.replace(/\\%/g,\u0026#34;%25\u0026#34;); data2=data2.replace(/\\#/g,\u0026#34;%23\u0026#34;); data2=data2.replace(/\\\u0026amp;/g,\u0026#34;%26\u0026#34;); ","description":"","id":21,"section":"posts","tags":["url 传递参数","字符串"],"title":"url 传递参数(特殊字符)解决方法","uri":"https://popo-blog.vercel.app/posts/url-%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-%E5%89%AF%E6%9C%AC/"},{"content":" 1 2 3 rm -f /etc/iptables/rules.v4 rm -f /etc/iptables/rules.v6 reboot ","description":"","id":22,"section":"posts","tags":["宝塔面板"],"title":"宝塔面板删除防火墙","uri":"https://popo-blog.vercel.app/posts/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%88%A0%E9%99%A4%E9%98%B2%E7%81%AB%E5%A2%99/"},{"content":"Step1. 安装宝塔 根据自己的系统类型安装宝塔（宝塔软件官网：https://www.bt.cn/）\nwget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh \u0026amp;\u0026amp; sudo bash install.sh Step2. 安装软件 进入宝塔控制面板安装LAMP组合 (Nginx，Mysql，Pureftpd，Phpmyadmin，PHP)\nStep3. 安装PlayTube 下载 PlayTube v1.4.2 提取码:3j9j 将程序上传到网站根目录解压，添加站点并添加伪静态规则，然后重启nginx：\nif (!-f $request_filename){ set $rule_0 1$rule_0; } if (!-d $request_filename){ set $rule_0 2$rule_0; } if ($rule_0 = \u0026#34;21\u0026#34;){ rewrite ^/$ /index.php?link1=home ; } rewrite ^/$ /index.php?link1=home ; rewrite ^/reset-password/([^/]+)(/|)$ /index.php?link1=reset-password\u0026amp;code=$1 ; rewrite ^/confirm/(.*)/(.*)$ /index.php?link1=confirm\u0026amp;code=$1\u0026amp;email=$2 ; rewrite ^/api/v(([0-9])([.][0-9]+))(/|)$ /api.php?v=$1 ; rewrite ^/admin-cp$ /admincp.php ; rewrite ^/admin-cp/(.*)$ /admincp.php?page=$1 ; rewrite ^/admin-cdn/(.*)$ /admin-panel/$1 last; rewrite ^/videos/category/(.*)/rss(/|)$ /index.php?link1=videos\u0026amp;page=category\u0026amp;id=$1\u0026amp;feed=rss ; rewrite ^/videos/category/(.*)$ /index.php?link1=videos\u0026amp;page=category\u0026amp;id=$1 ; rewrite ^/videos/(.*)/rss(/|)$ /index.php?link1=videos\u0026amp;page=$1\u0026amp;feed=rss ; rewrite ^/videos/(.*)$ /index.php?link1=videos\u0026amp;page=$1 ; rewrite ^/articles(/|)$ /index.php?link1=articles ; rewrite ^/articles/category/(.*)$ /index.php?link1=articles\u0026amp;category_id=$1 ; rewrite ^/articles/read/(.*)$ /index.php?link1=read\u0026amp;id=$1 ; if (!-f $request_filename){ set $rule_14 1$rule_14; } if (!-d $request_filename){ set $rule_14 2$rule_14; } if ($rule_14 = \u0026#34;21\u0026#34;){ rewrite ^/aj/([^/.]+)/?$ /ajax.php?type=$1\u0026amp;first=$2 last; } rewrite ^/aj/([^/.]+)/([^/.]+)/?$ /ajax.php?type=$1\u0026amp;first=$2 last; rewrite ^/aj/([^/.]+)/([^/.]+)/([^/.]+)/?$ /ajax.php?type=$1\u0026amp;first=$2\u0026amp;second=$3 last; rewrite ^/edit-video/(.*)?$ /index.php?link1=edit-video\u0026amp;id=$1 last; rewrite ^/watch/([^/]+)(/|)?$ /index.php?link1=watch\u0026amp;id=$1 last; rewrite ^/watch/([^/]+)/list/([^/]+)(/|)?$ /index.php?link1=watch\u0026amp;id=$1\u0026amp;list=$2 last; rewrite ^/embed/(.*)?$ /index.php?link1=embed\u0026amp;id=$1 last; rewrite ^/resend/(.*)/(.*)?$ /index.php?link1=resend\u0026amp;id=$1\u0026amp;u_id=$2 last; rewrite ^/redirect/(.*)?$ /index.php?link1=redirect\u0026amp;id=$1 last; rewrite ^/settings/(.*)/(.*)$ /index.php?link1=settings\u0026amp;page=$1\u0026amp;user=$2 ; rewrite ^/settings/(.*)$ /index.php?link1=settings\u0026amp;page=$1 ; rewrite ^/terms/([^/]+)(/|)$ /index.php?link1=terms\u0026amp;type=$1 ; rewrite ^/go_pro(/|)$ /index.php?link1=go_pro ; rewrite ^/ads(/|)$ /index.php?link1=ads ; rewrite ^/ads/create(/|)$ /index.php?link1=create_ads ; rewrite ^/ads/edit/(d+)(/|)$ /index.php?link1=edit_ads\u0026amp;id=$1 ; rewrite ^/contact-us(/|)$ /index.php?link1=contact ; rewrite ^/@([^/]+)(/|)$ /index.php?link1=timeline\u0026amp;id=$1 ; rewrite ^/messages/(.*)$ /index.php?link1=messages\u0026amp;id=$1 ; if (!-f $request_filename){ set $rule_33 1$rule_33; } if (!-d $request_filename){ set $rule_33 2$rule_33; } if ($rule_33 = \u0026#34;21\u0026#34;){ rewrite ^/([^/]+)(/|)$ /index.php?link1=$1 ; } Step4. 网站域名(站点)进行安装 通过phpmyadmin进入到数据库，找到PlayTube所使用数据库，删除langs表，再将根目录里的langs.sql文件导入到数据库即可。授权码：nulled-by-reishi。刷新网站会看到有右下角语言有中文的，如果选择中文后，分类显示不出来，可能是分类语言乱码，这时候我们去根目录assets/langs，将乱码的语言文件改成中文.php即可。\nStep5. 要使用程序完整的功能，还需要安装ffmpeg，这里直接使用ffmpeg一键脚本。 wget https://www.moerats.com/usr/shell/ffmpeg.sh \u0026amp;\u0026amp; sh ffmpeg.sh ffmpeg -version 打开宝塔，点击：软件管理-PHP设置-禁用函数-删除shell_exec。\nStep6. 视频分类设置 网站目录./assets/langs/中文.php修改。\nStep7. 编辑样式表 ./themes/default/css，主样式文件是style.css #添加自己的代码 想在head、body、footer标签中添加自己的代码，请在./themes/default/layout/container.html修改\n","description":"","id":23,"section":"posts","tags":["playtube"],"title":"playtube宝塔安装","uri":"https://popo-blog.vercel.app/posts/playtube%E5%AE%9D%E5%A1%94%E5%AE%89%E8%A3%85/"},{"content":" node.js\n命令行\n1 npm i -g vercel 1 vercel login https://www.xxx.com为代理网址\n1 2 3 4 5 6 { \u0026#34;version\u0026#34;: 2, \u0026#34;routes\u0026#34;: [ {\u0026#34;src\u0026#34;: \u0026#34;/(.*)\u0026#34;,\u0026#34;dest\u0026#34;: \u0026#34;https://www.xxx.com/$1\u0026#34;} ] } 1 vercel -A xxx.json --prod ","description":"","id":24,"section":"posts","tags":["Vercel"],"title":"Vercel反向代理做CDN","uri":"https://popo-blog.vercel.app/posts/vercel%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%81%9Acdn/"},{"content":"界面视图 视图放大 所选视图放大\tCtrl+空格\t所选视图全屏\tCtrl+ALT+空格\t视图切换 调出视图切换菜单\t~（tab上面）\t切换视图\tAlt（按住）+中键拖拽\t透视图\t中键+随意拖拽鼠标\t顶视图\t数字键盘【7】\t底视图\t数字键盘【Ctrl+7或者两下7】\t前视图\t数字键盘【1】\t后视图\t数字键盘【Ctrl+1或者两下1】\t右视图\t数字键盘【3】\t左视图\t数字键盘【Ctrl+3或者两下3】\t摄像机视图\t数字键盘【0】\t正交视图/透视图\t数字键盘【5】\t翻转视角\t数字键盘【9】\t透视图/四视图\tCtrl+ALT+Q\t视图旋转 上下旋转视图\t数字键盘【8】\t下上旋转视图\t数字键盘【2】\t左右旋转视图\t数字键盘【4】\t右左旋转视图\t数字键盘【6】\t视角操作 视角移动\tSHIFT+中键\t视角旋转\t中键（如果开启了3键模拟则也可以使用alt+左键，不推荐，会和环选冲突）\t视角缩放\t直接滚动滚轮或者按住Ctrl+中键并拖拽鼠标（较为精确）\t视图漫游（第一人称视角）\tshift+~\twasd移动（shift冲刺alt减速）\t空格或中键传送至准星位置\t视窗交换 视窗交换\t鼠标放到视窗右下角，按住Ctrl+左键出现+号并拖动到其他视窗\t模式切换 模式切换\tCTRL+TAB/\u0026quot;~\u0026quot;键\t辅助显示系统 显示模式切换\tShift+Z\t1来回切换物体的显示模式；2默认是线框和实体的切换\t显示漫游器\tCTRL+~\t透显模式\tALT+Z\t线框模式+透显模式\tSHIFT+Z\t摄像机 设置活动相机到视角\tctrl +alt+0\t1注意选中摄像机 设置活动物体为摄像机\tctrl+0\t","description":"","id":25,"section":"posts","tags":["Blender"],"title":"Blender快捷键","uri":"https://popo-blog.vercel.app/posts/blender%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"content":"前端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width,initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;websocket\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcss.com/jquery/3.4.1/jquery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;ul id=\u0026#34;content\u0026#34;\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;form class=\u0026#34;form\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;请输入发送的消息\u0026#34; class=\u0026#34;message\u0026#34; id=\u0026#34;message\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;发送\u0026#34; id=\u0026#34;send\u0026#34; class=\u0026#34;connect\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;连接\u0026#34; id=\u0026#34;connect\u0026#34; class=\u0026#34;connect\u0026#34;/\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var oUl=document.getElementById(\u0026#39;content\u0026#39;); var oConnect=document.getElementById(\u0026#39;connect\u0026#39;); var oSend=document.getElementById(\u0026#39;send\u0026#39;); var oInput=document.getElementById(\u0026#39;message\u0026#39;); var ws=null; oConnect.onclick=function(){ ws=new WebSocket(\u0026#39;ws://127.0.0.1:10083\u0026#39;); ws.onopen=function(){ oUl.innerHTML+=\u0026#34;\u0026lt;li\u0026gt;客户端已连接\u0026lt;/li\u0026gt;\u0026#34;; } ws.onmessage=function(evt){ console.log(\u0026#34;fdsa\u0026#34;) oUl.innerHTML+=\u0026#34;\u0026lt;li\u0026gt;\u0026#34;+evt.data+\u0026#34;\u0026lt;/li\u0026gt;\u0026#34;; } ws.onclose=function(){ oUl.innerHTML+=\u0026#34;\u0026lt;li\u0026gt;客户端已断开连接\u0026lt;/li\u0026gt;\u0026#34;; }; ws.onerror=function(evt){ oUl.innerHTML+=\u0026#34;\u0026lt;li\u0026gt;\u0026#34;+evt.data+\u0026#34;\u0026lt;/li\u0026gt;\u0026#34;; }; }; oSend.onclick=function(){ if(ws){ ws.send($(\u0026#34;#message\u0026#34;).val()) } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; *{ margin: 0; padding: 0; } .message{ width: 60%; margin: 0 10px; display: inline-block; text-align: center; height: 40px; line-height: 40px; font-size: 20px; border-radius: 5px; border: 1px solid #B3D33F; } .form{ width:100%; position: fixed; bottom: 300px; left: 0; } .connect{ height: 40px; vertical-align: top; /* padding: 0; */ width: 80px; font-size: 20px; border-radius: 5px; border: none; background: #B3D33F; color: #fff; } \u0026lt;/style\u0026gt; \u0026lt;/html\u0026gt; 后端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 # !/usr/bin/env python # -*- coding: utf-8 -*- import struct import socket import base64 import hashlib import threading def get_headers(data): headers = {} data = str(data, encoding=\u0026#39;utf-8\u0026#39;) header, body = data.split(\u0026#39;\\r\\n\\r\\n\u0026#39;, 1) header_list = header.split(\u0026#39;\\r\\n\u0026#39;) for i in header_list: i_list = i.split(\u0026#39;:\u0026#39;, 1) if len(i_list) \u0026gt;= 2: headers[i_list[0]] = \u0026#34;\u0026#34;.join(i_list[1::]).split() else: i_list = i.split(\u0026#34; \u0026#34;, 1) if i_list and len(i_list) == 2: headers[\u0026#34;method\u0026#34;] = i_list[0] headers[\u0026#34;protocol\u0026#34;] = i_list[1] return headers def send_msg(conn, msg_bytes): token = b\u0026#39;\\x81\u0026#39; length = len(msg_bytes) if length \u0026lt; 126: token += struct.pack(\u0026#39;B\u0026#39;, length) elif length \u0026lt;= 0xFFFF: token += struct.pack(\u0026#39;!BH\u0026#39;, 126, length) else: token += struct.pack(\u0026#39;!BQ\u0026#39;, 127, length) msg = token + msg_bytes conn.sendall(msg) return True # 解码 def parse_payload(payload): payload_len = payload[1] \u0026amp; 127 if payload_len == 126: extend_payload_len = payload[2:4] mask = payload[4:8] decoded = payload[8:] elif payload_len == 127: extend_payload_len = payload[2:10] mask = payload[10:14] decoded = payload[14:] else: extend_payload_len = None mask = payload[2:6] decoded = payload[6:] bytes_list = bytearray() for i in range(len(decoded)): chunk = decoded[i] ^ mask[i % 4] bytes_list.append(chunk) body = str(bytes_list, encoding=\u0026#39;utf-8\u0026#39;) return body # 建立连接 def handler_accept(sock): while True: conn, addr = sock.accept() data = conn.recv(8096) headers = get_headers(data) response_tpl = \u0026#34;HTTP/1.1 101 Switching Protocols\\r\\n\u0026#34;\\ \u0026#34;Upgrade:websocket\\r\\n\u0026#34; \\ \u0026#34;Connection: Upgrade\\r\\n\u0026#34; \\ \u0026#34;Sec-WebSocket-Accept:%s\\r\\n\u0026#34; \\ \u0026#34;WebSocket-Location:ws://%s\\r\\n\\r\\n\u0026#34; magic_string = \u0026#39;258EAFA5-E914-47DA-95CA-C5AB0DC85B11\u0026#39; if headers.get(\u0026#39;Sec-WebSocket-Key\u0026#39;): value = headers[\u0026#39;Sec-WebSocket-Key\u0026#39;][0] + magic_string ac = base64.b64encode(hashlib.sha1(value.encode(\u0026#39;utf-8\u0026#39;)).digest()) response_str = response_tpl % (ac.decode(\u0026#39;utf-8\u0026#39;), headers.get(\u0026#34;Host\u0026#34;)) conn.sendall(bytes(response_str, encoding=\u0026#34;utf-8\u0026#34;)) t = threading.Thread(target=handler_msg, args=(conn, )) t.start() # 请求内容 def handler_msg(conn): with conn as c: while True: data_recv = c.recv(8096) if data_recv[0:1] == b\u0026#39;\\x81\u0026#39;: data_recv = parse_payload(data_recv) print(data_recv) send_msg(c, bytes(\u0026#39;服务端revc:{}\u0026#39;.format(data_recv), encoding=\u0026#39;utf-8\u0026#39;)) # 开起本地的服务 def server_socket(): sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) sock.bind((\u0026#34;127.0.0.1\u0026#34;, 10083)) sock.listen(5) t = threading.Thread(target=handler_accept(sock)) # conn, addr = sock.accept() # print(conn) # data = conn.recv(8096) # headers = get_headers(data) # response_tpl = \u0026#34;HTTP/1.1 101 Switching Protocols\\r\\n\u0026#34;\\ # \u0026#34;Upgrade:websocket\\r\\n\u0026#34; \\ # \u0026#34;Connection: Upgrade\\r\\n\u0026#34; \\ # \u0026#34;Sec-WebSocket-Accept:%s\\r\\n\u0026#34; \\ # \u0026#34;WebSocket-Location:ws://%s\\r\\n\\r\\n\u0026#34; # value = None # if headers.get(\u0026#39;Sec-WebSocket-Key\u0026#39;): # value = headers[\u0026#39;Sec-WebSocket-Key\u0026#39;][0] + magic_string # # ac = base64.b64encode(hashlib.sha1(value.encode(\u0026#39;utf-8\u0026#39;)).digest()) # response_str = response_tpl % (ac.decode(\u0026#39;utf-8\u0026#39;), headers.get(\u0026#34;Host\u0026#34;)) # conn.sendall(bytes(response_str, encoding=\u0026#39;utf-8\u0026#39;)) # # while True: # data_1 = conn.recv(8096) # data_2 = parse_payload(data_1) # print(data_2) # send_msg(conn, b\u0026#39;text\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: server_socket() ","description":"","id":26,"section":"posts","tags":["socket"],"title":"socket前后端传输数据","uri":"https://popo-blog.vercel.app/posts/socket%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE/"},{"content":"申请GitHub Oauth App 需要 GitHub Application，如果没有 点击这里申请，Authorization callback URL 填写当前使用插件页面的域名。\n以本站为例，须填写以下内容：\n字段 内容 备注 Application name gittalk for xbc.me 填写应用名称 Homepage URL https://xbc.me 主页地址 Application description 神秘极客gtalk留言插件 备注 Authorization callback URL https://xbc.me 回调地址 创建模板 在主题目录下，新建模板，如themes/mainload/layouts/partials/gitalk.html\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 {{ if .Site.Params.enableGitalk }} \u0026lt;div id=\u0026#34;gitalk-container\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const gitalk = new Gitalk({ clientID: \u0026#39;{{ .Site.Params.Gitalk.clientID }}\u0026#39;, clientSecret: \u0026#39;{{ .Site.Params.Gitalk.clientSecret }}\u0026#39;, repo: \u0026#39;{{ .Site.Params.Gitalk.repo }}\u0026#39;, owner: \u0026#39;{{ .Site.Params.Gitalk.owner }}\u0026#39;, admin: [\u0026#39;{{ .Site.Params.Gitalk.owner }}\u0026#39;], id: location.pathname, // Ensure uniqueness and length less than 50 distractionFreeMode: false // Facebook-like distraction free mode }); (function() { if ([\u0026#34;localhost\u0026#34;, \u0026#34;127.0.0.1\u0026#34;].indexOf(window.location.hostname) != -1) { document.getElementById(\u0026#39;gitalk-container\u0026#39;).innerHTML = \u0026#39;Gitalk comments not available by default when the website is previewed locally.\u0026#39;; return; } gitalk.render(\u0026#39;gitalk-container\u0026#39;); })(); \u0026lt;/script\u0026gt; {{ end }} 修改主题模板模板layouts/_default/single.html，在{{ partial “comment.html” . }}的下一行，添加以下内容:\n{{ partial \u0026#34;gitalk.html\u0026#34; . }} ###在github中 添加仓库\n创建一个public的仓库，记住仓库名称，填写在下面的repo\n添加配置 需要修改config.toml配置，注意repo添加自己的版本库地址，一般是username.github.io。\n记得开启主题评论功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [Params] enableGitalk = true [Params.Gitalk] clientID = \u0026#34;xxx\u0026#34; # Your client ID clientSecret = \u0026#34;xxx\u0026#34; # Your client secret repo = \u0026#34;xbc.me\u0026#34; # 仓库名称 owner = \u0026#34;geekwho11\u0026#34; # github 名字 admin= \u0026#34;geekwho11\u0026#34; # Required. Github repository owner and collaborators. (Users who having write access to this repository) id= \u0026#34;location.pathname\u0026#34; # The unique id of the page. labels= \u0026#34;gitalk\u0026#34; # Github issue labels. If you used to use Gitment, you can change it perPage= 15 # Pagination size, with maximum 100. pagerDirection= \u0026#34;last\u0026#34; # Comment sorting direction, available values are \u0026#39;last\u0026#39; and \u0026#39;first\u0026#39;. createIssueManually= false # If it is \u0026#39;false\u0026#39;, it is auto to make a Github issue when the administrators login. distractionFreeMode= false # Enable hot key (cmd|ctrl + enter) submit comment. 大功告成 ","description":"","id":27,"section":"posts","tags":["hugo、gittalk"],"title":"hugo添加gittalk组件","uri":"https://popo-blog.vercel.app/posts/hugo%E6%B7%BB%E5%8A%A0gittalk%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/"},{"content":" 1 2 3 4 git clone https://gitee.com/pdusb/pdusb-fast-btpanel.git su ./pdbolt-inst-bt-acel.sh bash /tmp/btp/pdbolt-bt-install/install.sh ","description":"","id":28,"section":"posts","tags":["宝塔面板,arm"],"title":"arm安装宝塔面板","uri":"https://popo-blog.vercel.app/posts/arm%E5%AE%89%E8%A3%85%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/"},{"content":"Supervisor Supervisor是一个进程监控程序。可以查看进程执行状态, 启动异常终止的进程。\n使用场景 我现在有一个进程需要每时每刻不断的跑，但是这个进程又有可能由于各种原因有可能中断。当进程中断的时候我希望能自动重新启动它，此时，我就需要使用到了Supervisor，相当于将一个普通后台变成了守护进程； 有一个脚本需要自定义时间执行（实现想什么时候执行就点一下执行按钮的效果），可以打开Supervisor web页点击执行。 安装使用教程 ubuntu安装： 1 apt-get install supervisor centos安装： 1 2 3 4 5 6 7 8 9 #安装setuptools yum install python-setuptools #安装supervisor easy_install supervisor #测试安装是否成功： echo_supervisord_conf #上面语句若输出配置文件信息表示安装成功 创建进程管理配置文件 1 2 3 4 5 6 7 8 9 10 # 若没有配置文件，创建supervisor配置文件，注意先检查下有没有 # ubuntu /etc/supervisor/supervisord.conf 有的系统是 /etc/supervisord.conf # 创建配置文件 echo_supervisord_conf \u0026gt; /etc/supervisor/supervisord.conf 1、在supervisord.conf 最后增加其他进程配置文件引入 supervisord.conf\n[include] files = /etc/supervisor/conf.d/*.conf 2、在 /etc/supervisor/conf.d/ 目录下创建各子进程配置文件 /etc/supervisor/conf.d/v2.conf\n[program:v2_queue] ;进程名 command = /usr/local/php/bin/php /alidata/www/v2/current/artisan queue:work --sleep=3 --tries=3 ; 进程对应的命令 process_name = %(program_name)s_%(process_num)s numprocs = 1 ; 启动子进程个数，如队列可以启动多个消费队列进程，根据实际需要设置 user=www ;设置执行用户，可以用来管理该listener进程。 autostart = true ;supervisor启动的时候是否随着同时启动 autorestart = true ;当程序退出的时候，这个program会自动重启 startsecs=1 ;程序重启时候停留在runing状态的秒数，设为1表示启动 1 秒后没有异常退出，就当作已经正常启动了 startretries=3 ;启动失败自动重试次数，默认是 3 stdout_logfile = /alidata/log/supervisor/v2_queue_out.log ; 输出日志 stdout_logfile_maxbytes = 10MB ; 输出日志文件最大大小 stderr_logfile = /alidata/log/supervisor/v2_queue_err.log ; 错误日志 stderr_logfile_maxbytes = 10MB ; 输出日志文件最大大小 redirect_stderr=false ; 把 stderr 重定向到 stdout，默认 false 有的操作系统好像是 *.ini 来，这个要注意。\nsupervisorctl 配置文件说明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 [unix_http_server] file=/tmp/supervisor.sock ; socket文件的路径，supervisorctl用XML_RPC和supervisord通信就是通过它进行 的。如果不设置的话，supervisorctl也就不能用了 不设置的话，默认为none。 非必须设置 ;chmod=0700 ; 这个简单，就是修改上面的那个socket文件的权限为0700 不设置的话，默认为0700。 非必须设置 ;chown=nobody:nogroup ; 这个一样，修改上面的那个socket文件的属组为user.group 不设置的话，默认为启动supervisord进程的用户及属组。非必须设置 ;username=user ; 使用supervisorctl连接的时候，认证的用户 不设置的话，默认为不需要用户。 非必须设置 ;password=123 ; 和上面的用户名对应的密码，可以直接使用明码，也可以使用SHA加密 如：{SHA}82ab876d1387bfafe46cc1c8a2ef074eae50cb1d 默认不设置。。。非必须设置 ;[inet_http_server] ; 侦听在TCP上的socket，Web Server和远程的supervisorctl都要用到他 不设置的话，默认为不开启。非必须设置 ;port=127.0.0.1:9001 ; 这个是侦听的IP和端口，侦听所有IP用 :9001或*:9001。 这个必须设置，只要上面的[inet_http_server]开启了，就必须设置它 ;username=user ; 这个和上面的uinx_http_server一个样。非必须设置 ;password=123 ; 这个也一个样。非必须设置 [supervisord] ;这个主要是定义supervisord这个服务端进程的一些参数的 这个必须设置，不设置，supervisor就不用干活了 logfile=/tmp/supervisord.log ; 这个是supervisord这个主进程的日志路径，注意和子进程的日志不搭嘎。 默认路径$CWD/supervisord.log，$CWD是当前目录。。非必须设置 logfile_maxbytes=50MB ; 这个是上面那个日志文件的最大的大小，当超过50M的时候，会生成一个新的日 志文件。当设置为0时，表示不限制文件大小 默认值是50M，非必须设置。 logfile_backups=10 ; 日志文件保持的数量，上面的日志文件大于50M时，就会生成一个新文件。文件 数量大于10时，最初的老文件被新文件覆盖，文件数量将保持为10 当设置为0时，表示不限制文件的数量。 默认情况下为10。。。非必须设置 loglevel=info ; 日志级别，有critical, error, warn, info, debug, trace, or blather等 默认为info。。。非必须设置项 pidfile=/tmp/supervisord.pid ; supervisord的pid文件路径。 默认为$CWD/supervisord.pid。。。非必须设置 nodaemon=false ; 如果是true，supervisord进程将在前台运行 默认为false，也就是后台以守护进程运行。。。非必须设置 minfds=1024 ; 这个是最少系统空闲的文件描述符，低于这个值supervisor将不会启动。 系统的文件描述符在这里设置cat /proc/sys/fs/file-max 默认情况下为1024。。。非必须设置 minprocs=200 ; 最小可用的进程描述符，低于这个值supervisor也将不会正常启动。 ulimit -u这个命令，可以查看linux下面用户的最大进程数 默认为200。。。非必须设置 ;umask=022 ; 进程创建文件的掩码 默认为022。。非必须设置项 ;user=chrism ; 这个参数可以设置一个非root用户，当我们以root用户启动supervisord之后。 我这里面设置的这个用户，也可以对supervisord进行管理 默认情况是不设置。。。非必须设置项 ;identifier=supervisor ; 这个参数是supervisord的标识符，主要是给XML_RPC用的。当你有多个 supervisor的时候，而且想调用XML_RPC统一管理，就需要为每个 supervisor设置不同的标识符了 默认是supervisord。。。非必需设置 ;directory=/tmp ; 这个参数是当supervisord作为守护进程运行的时候，设置这个参数的话，启动 supervisord进程之前，会先切换到这个目录 默认不设置。。。非必须设置 ;nocleanup=true ; 这个参数当为false的时候，会在supervisord进程启动的时候，把以前子进程 产生的日志文件(路径为AUTO的情况下)清除掉。有时候咱们想要看历史日志，当 然不想日志被清除了。所以可以设置为true 默认是false，有调试需求的同学可以设置为true。。。非必须设置 ;childlogdir=/tmp ; 当子进程日志路径为AUTO的时候，子进程日志文件的存放路径。 默认路径是这个东西，执行下面的这个命令看看就OK了，处理的东西就默认路径 python -c \u0026#34;import tempfile;print tempfile.gettempdir()\u0026#34; 非必须设置 ;environment=KEY=\u0026#34;value\u0026#34; ; 这个是用来设置环境变量的，supervisord在linux中启动默认继承了linux的 环境变量，在这里可以设置supervisord进程特有的其他环境变量。 supervisord启动子进程时，子进程会拷贝父进程的内存空间内容。 所以设置的 这些环境变量也会被子进程继承。 小例子：environment=name=\u0026#34;haha\u0026#34;,age=\u0026#34;hehe\u0026#34; 默认为不设置。。。非必须设置 ;strip_ansi=false ; 这个选项如果设置为true，会清除子进程日志中的所有ANSI 序列。什么是ANSI 序列呢？就是我们的\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\t这些东西。 默认为false。。。非必须设置 ; the below section must remain in the config file for RPC ; (supervisorctl/web interface) to work, additional interfaces may be ; added by defining them in separate rpcinterface: sections [rpcinterface:supervisor] ;这个选项是给XML_RPC用的，当然你如果想使用supervisord或者web server 这 个选项必须要开启的 supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface [supervisorctl] ;这个主要是针对supervisorctl的一些配置 serverurl=unix:///tmp/supervisor.sock ; 这个是supervisorctl本地连接supervisord的时候，本地UNIX socket 路径，注意这个是和前面的[unix_http_server]对应的 默认值就是unix:///tmp/supervisor.sock。。非必须设置 ;serverurl=http://127.0.0.1:9001 ; 这个是supervisorctl远程连接supervisord的时候，用到的TCP socket路径 注意这个和前面的[inet_http_server]对应 默认就是http://127.0.0.1:9001。。。非必须项 ;username=chris ; 用户名 默认空。。非必须设置 ;password=123 ; 密码 默认空。。非必须设置 ;prompt=mysupervisor ; 输入用户名密码时候的提示符 默认supervisor。。非必须设置 ;history_file=~/.sc_history ; 这个参数和shell中的history类似，我们可以用上下键来查找前面执行过的命令 默认是no file的。。所以我们想要有这种功能，必须指定一个文件。。。非 必须设置 ; 下面示例是创建子进程的配置 ;[program:theprogramname] ;这个就是咱们要管理的子进程了，\u0026#34;:\u0026#34;后面的是名字，最好别乱写和实际进程 有点关联最好。这样的program我们可以设置一个或多个，一个program就是 要被管理的一个进程 ;command=/bin/cat ; 这个就是我们的要启动进程的命令路径了，可以带参数 例子：/home/test.py -a \u0026#39;hehe\u0026#39; 有一点需要注意的是，我们的command只能是那种在终端运行的进程，不能是 守护进程。这个想想也知道了，比如说command=service httpd start。 httpd这个进程被linux的service管理了，我们的supervisor再去启动这个命令 这已经不是严格意义的子进程了。 这个是个必须设置的项 ;process_name=%(program_name)s ; 这个是进程名，如果我们下面的numprocs参数为1的话，就不用管这个参数 了，它默认值%(program_name)s也就是上面的那个program冒号后面的名字， 但是如果numprocs为多个的话，那就不能这么干了。想想也知道，不可能每个 进程都用同一个进程名吧。 ;numprocs=1 ; 启动进程的数目。当不为1时，就是进程池的概念，注意process_name的设置 默认为1 。。非必须设置 ;directory=/tmp ; 进程运行前，会前切换到这个目录 默认不设置。。。非必须设置 ;umask=022 ; 进程掩码，默认none，非必须 ;priority=999 ; 子进程启动关闭优先级，优先级低的，最先启动，关闭的时候最后关闭 默认值为999 。。非必须设置 ;autostart=true ; 如果是true的话，子进程将在supervisord启动后被自动启动 默认就是true 。。非必须设置 ;autorestart=unexpected ; 这个是设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected 和true。如果为false的时候，无论什么情况下，都不会被重新启动， 如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的退 出码的时候，才会被自动重启。当为true的时候，只要子进程挂掉，将会被无 条件的重启 ;startsecs=1 ; 这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启 动成功了，默认值为1 。。非必须设置 ;startretries=3 ; 当进程启动失败后，最大尝试启动的次数。。当超过3次后，supervisor将把 此进程的状态置为FAIL 默认值为3 。。非必须设置 ;exitcodes=0,2 ; 注意和上面的的autorestart=unexpected对应。。exitcodes里面的定义的 退出码是expected的。 ;stopsignal=QUIT ; 进程停止信号，可以为TERM, HUP, INT, QUIT, KILL, USR1, or USR2等信号 默认为TERM 。。当用设定的信号去干掉进程，退出码会被认为是expected 非必须设置 ;stopwaitsecs=10 ; 这个是当我们向子进程发送stopsignal信号后，到系统返回信息 给supervisord，所等待的最大时间。 超过这个时间，supervisord会向该 子进程发送一个强制kill的信号。 默认为10秒。。非必须设置 ;stopasgroup=false ; 这个东西主要用于，supervisord管理的子进程，这个子进程本身还有 子进程。那么我们如果仅仅干掉supervisord的子进程的话，子进程的子进程 有可能会变成孤儿进程。所以咱们可以设置可个选项，把整个该子进程的 整个进程组都干掉。 设置为true的话，一般killasgroup也会被设置为true。 需要注意的是，该选项发送的是stop信号 默认为false。。非必须设置。。 ;killasgroup=false ; 这个和上面的stopasgroup类似，不过发送的是kill信号 ;user=chrism ; 如果supervisord是root启动，我们在这里设置这个非root用户，可以用来 管理该program 默认不设置。。。非必须设置项 ;redirect_stderr=true ; 如果为true，则stderr的日志会被写入stdout日志文件中 默认为false，非必须设置 ;stdout_logfile=/a/path ; 子进程的stdout的日志路径，可以指定路径，AUTO，none等三个选项。 设置为none的话，将没有日志产生。设置为AUTO的话，将随机找一个地方 生成日志文件，而且当supervisord重新启动的时候，以前的日志文件会被 清空。当 redirect_stderr=true的时候，sterr也会写进这个日志文件 ;stdout_logfile_maxbytes=1MB ; 日志文件最大大小，和[supervisord]中定义的一样。默认为50 ;stdout_logfile_backups=10 ; 和[supervisord]定义的一样。默认10 ;stdout_capture_maxbytes=1MB ; 这个东西是设定capture管道的大小，当值不为0的时候，子进程可以从stdout 发送信息，而supervisor可以根据信息，发送相应的event。 默认为0，为0的时候表达关闭管道。。。非必须项 ;stdout_events_enabled=false ; 当设置为ture的时候，当子进程由stdout向文件描述符中写日志的时候，将 触发supervisord发送PROCESS_LOG_STDOUT类型的event 默认为false。。。非必须设置 ;stderr_logfile=/a/path ; 这个东西是设置stderr写的日志路径，当redirect_stderr=true。这个就不用 设置了，设置了也是白搭。因为它会被写入stdout_logfile的同一个文件中 默认为AUTO，也就是随便找个地存，supervisord重启被清空。。非必须设置 ;stderr_logfile_maxbytes=1MB ; 这个出现好几次了，就不重复了 ;stderr_logfile_backups=10 ; 这个也是 ;stderr_capture_maxbytes=1MB ; 这个一样，和stdout_capture一样。 默认为0，关闭状态 ;stderr_events_enabled=false ; 这个也是一样，默认为false ;environment=A=\u0026#34;1\u0026#34;,B=\u0026#34;2\u0026#34; ; 这个是该子进程的环境变量，和别的子进程是不共享的 ;serverurl=AUTO ; ; The below sample eventlistener section shows all possible ; eventlistener subsection values, create one or more \u0026#39;real\u0026#39; ; eventlistener: sections to be able to handle event notifications ; sent by supervisor. ;[eventlistener:theeventlistenername] ;这个东西其实和program的地位是一样的，也是suopervisor启动的子进 程，不过它干的活是订阅supervisord发送的event。他的名字就叫 listener了。我们可以在listener里面做一系列处理，比如报警等等 楼主这两天干的活，就是弄的这玩意 ;command=/bin/eventlistener ; 这个和上面的program一样，表示listener的可执行文件的路径 ;process_name=%(program_name)s ; 这个也一样，进程名，当下面的numprocs为多个的时候，才需要。否则默认就 OK了 ;numprocs=1 ; 相同的listener启动的个数 ;events=EVENT ; event事件的类型，也就是说，只有写在这个地方的事件类型。才会被发送 ;buffer_size=10 ; 这个是event队列缓存大小，单位不太清楚，楼主猜测应该是个吧。当buffer 超过10的时候，最旧的event将会被清除，并把新的event放进去。 默认值为10。。非必须选项 ;directory=/tmp ; 进程执行前，会切换到这个目录下执行 默认为不切换。。。非必须 ;umask=022 ; 淹没，默认为none，不说了 ;priority=-1 ; 启动优先级，默认-1，也不扯了 ;autostart=true ; 是否随supervisord启动一起启动，默认true ;autorestart=unexpected ; 是否自动重启，和program一个样，分true,false,unexpected等，注意 unexpected和exitcodes的关系 ;startsecs=1 ; 也是一样，进程启动后跑了几秒钟，才被认定为成功启动，默认1 ;startretries=3 ; 失败最大尝试次数，默认3 ;exitcodes=0,2 ; 期望或者说预料中的进程退出码， ;stopsignal=QUIT ; 干掉进程的信号，默认为TERM，比如设置为QUIT，那么如果QUIT来干这个进程 那么会被认为是正常维护，退出码也被认为是expected中的 ;stopwaitsecs=10 ; max num secs to wait b4 SIGKILL (default 10) ;stopasgroup=false ; send stop signal to the UNIX process group (default false) ;killasgroup=false ; SIGKILL the UNIX process group (def false) ;user=chrism ;设置普通用户，可以用来管理该listener进程。 默认为空。。非必须设置 ;redirect_stderr=true ; 为true的话，stderr的log会并入stdout的log里面 默认为false。。。非必须设置 ;stdout_logfile=/a/path ; 这个不说了，好几遍了 ;stdout_logfile_maxbytes=1MB ; 这个也是 ;stdout_logfile_backups=10 ; 这个也是 ;stdout_events_enabled=false ; 这个其实是错的，listener是不能发送event ;stderr_logfile=/a/path ; 这个也是 ;stderr_logfile_maxbytes=1MB ; 这个也是 ;stderr_logfile_backups ; 这个不说了 ;stderr_events_enabled=false ; 这个也是错的，listener不能发送event ;environment=A=\u0026#34;1\u0026#34;,B=\u0026#34;2\u0026#34; ; 这个是该子进程的环境变量 默认为空。。。非必须设置 ;serverurl=AUTO ; override serverurl computation (childutils) ; The below sample group section shows all possible group values, ; create one or more \u0026#39;real\u0026#39; group: sections to create \u0026#34;heterogeneous\u0026#34; ; process groups. ;[group:thegroupname] ;这个东西就是给programs分组，划分到组里面的program。我们就不用一个一个去操作了 我们可以对组名进行统一的操作。 注意：program被划分到组里面之后，就相当于原来 的配置从supervisor的配置文件里消失了。。。supervisor只会对组进行管理，而不再 会对组里面的单个program进行管理了 ;programs=progname1,progname2 ; 组成员，用逗号分开 这个是个必须的设置项 ;priority=999 ; 优先级，相对于组和组之间说的 默认999。。非必须选项 ; The [include] section can just contain the \u0026#34;files\u0026#34; setting. This ; setting can list multiple files (separated by whitespace or ; newlines). It can also contain wildcards. The filenames are ; interpreted as relative to this file. Included files *cannot* ; include files themselves. ;[include] ;这个东西挺有用的，当我们要管理的进程很多的时候，写在一个文件里面 就有点大了。我们可以把配置信息写到多个文件中，然后include过来 ;files = relative/directory/*.ini 进程管理命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # supervisord服务启动 supervisord -c /etc/supervisord.conf # 不重启supervisord服务的情况下更新配置文件，会同步重启配置修改过的子进程 sudo supervisorctl update #supervisor 服务客户端管理命令 supervisorctl # 重新启动配置中的所有程序， 并同时重启 supervisord 服务，这个重启挺慢的，一般不建议用 sudo supervisorctl reload # 终止配置中的所有子进程 sudo supervisorctl stop all # 启动配置中的所有子进程 sudo supervisorctl start all # 重启配置中所有子程序 sudo supervisorctl restart all # 启动配置中的某个子进程 sudo supervisorctl start queue_dispose:* # supervisorctl 执行有时会报错找不到 supervisord.conf 文件，可使用 -c 参数指定 sudo supervisorctl -c /etc/supervisor/supervisord.conf status sudo supervisorctl -c /etc/supervisor/supervisord.conf stop webWeiXinLoginList:webWeiXinLoginList_0 各命令是否会重启子进程 在生产环境修改代码后重启进程，建议使用restart, 不要用 reload, 这个会同时重启 supervisord， 导致进程重启很慢。\n注意：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 1、每次修改配置文件后需进入supervisorctl，执行 update ， 改动部分才能生效 2、Supervisor主要有两个命令: supervisord : 启动supervisor的服务器端 supervisorctl：启动supervisor的命令行窗口，在该命令行中可执行start、stop、status、reload等操作。 3、php脚本执行报\u0026#39;BACKOFF Exited too quickly (process log may have details)\u0026#39;错误解决: 对于执行时间很短的php脚本(执行时间小于配置的 startsecs)，点击进程执行会报以上错误。 \u0026lt;?php require \u0026#39;db.class.php\u0026#39;; $dbHost = \u0026#39;localhost\u0026#39;; $dbUser = \u0026#39;xxxxxx\u0026#39;; $dbPasswd = \u0026#39;xxxxxx\u0026#39;; $dbName = \u0026#39;test\u0026#39;; $pdo = db::getInstance($dbHost, $dbUser, $dbPasswd, $dbName); $pdo-\u0026gt;insert(\u0026#39;test\u0026#39;, [\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;wml\u0026#39;]); sleep(2); #在php脚本最后一行加上一句，可解决该问题 进程 web管理界面 supervisor提供web管理页面，可以在网页端对进程进行监控，启动，终止，重启等操作\n将supervisord.conf中[inet_http_server]部分做相应配置，在supervisorctl中reload即可启动web管理界面\n1 2 3 4 [inet_http_server] ; inet (TCP) server disabled by default port=192.168.10.129:9001 ; 外网ip(ip_address:port specifier, *:port for all iface) username=xxxxxxx ; (default is no username (open server)) password=xxxxxxx ; (default is no password (open server)) 在浏览器打开网址192.168.10.129:9001，输入上面账号xxxxxxx密码xxxxxxx，即可进入web管理页面：\nsupervisor缺点 1 2 3 4 5 1. 单机监控 2. 只能从supervisor启动的程序才能监控，从其他地方启动的无法监控 3. 需要指出的是，被 Supervisor 管理的进程，不能使用 daemon 模式，而必须在前台运行，否则会报错。 进程描述符限制 有时会遇到如一个进程监听到200个长连接后新的连接就连不上了，这是因为supervisor进程描述符的限制。\nsupervisor进程描述符默认为200，对于管理需要更多进程描述符的子进程一定要修改配置文件\n/etc/supervisor/supervisord.conf, 在[supervisord]下面添加minfds=102400（改大即可）。\n可以使用阿里云监控 supervisord 进程， supervisord进程再监控各子进程\n其他监控工具如 monit ，功能更加强大。等以后研究\n@搜索词：sup，super\n","description":"","id":29,"section":"posts","tags":["Supervisor"],"title":"Supervisor使用","uri":"https://popo-blog.vercel.app/posts/supervisor%E4%BD%BF%E7%94%A8/"},{"content":"一次性设置代理 window（cmd） 端口号要看代理软件的端口\n比如：\nssr 软件默认端口是1080\nv2rayN 软件默认端口是10809\n设置代理\nset http_proxy=http://127.0.0.1:10809 set https_proxy=http://127.0.0.1:10809 或者\nset all_proxy=http://127.0.0.1:10809 取消代理\nset http_proxy= set https_proxy= 或者\nset all_proxy= mac/linux（终端） 设置代理\nexport http_proxy=http://127.0.0.1:10809 export https_proxy=http://127.0.0.1:10809 或者\nexport all_proxy=http://127.0.0.1:10809 取消代理\nunset http_proxy unset https_proxy 或者\nunset all_proxy 这样设置是一次性的，终端关闭后失效\n永久设置终端代理 window win+R打开运行命令里面，输入命令。\ncontrol system 打开“高级系统设置“-\u0026gt;环境变量-\u0026gt;Path新建\nmac/linux 编辑.zshrc文件\nvim ~/.zshrc 添加\nexport all_proxy=http://127.0.0.1:10809 还可以设置简写\nalias proxy=‘export all_proxy=http://127.0.0.1:10809’ alias unproxy=‘unset all_proxy’ 之后就可以使用 proxy 开启代理 unproxy 关闭代理\n","description":"","id":30,"section":"posts","tags":["终端代理"],"title":"设置终端代理","uri":"https://popo-blog.vercel.app/posts/%E7%BB%88%E7%AB%AF%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/"},{"content":"sql server 设置数据库引擎 SQL Server 身份验证 1 打开Microsoft SQL Server Management Studio -\u0026gt; 视图 -\u0026gt; 已注册的服务器 1 打开数据库引擎-\u0026gt;本地服务器组- \u0026gt;右键属性 身份验证 设置 SQL Server 身份验证 设置 登录名和密码 对象资源管理器 设置 1 右键属性-\u0026gt;安全性-\u0026gt;设置 SQL Server 和 Windows 身份验证模式 和 失败和成功的登录 重启服务 右键属性-\u0026gt;重新启动\n选择账户密码登录 ","description":"","id":31,"section":"posts","tags":["sql server"],"title":" sql server 设置账户密码登录","uri":"https://popo-blog.vercel.app/posts/sql-server-%E8%AE%BE%E7%BD%AE%E8%B4%A6%E6%88%B7%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95/"},{"content":"使用Unity Hub安装Unity Unity Hub快速安装链接\n或者直接从下面链接下载\n使用方式 用浏览器打开链接 选择打开unity hub\nUnity 2021.2（α）：\n1 unityhub://2021.2.0a10/b8c2bb7e8b36 Unity 2021.1：\n1 unityhub://2021.1.0f1/61a549675243 Unity 2020.3（LTS）：\n1 2 3 unityhub://2020.3.2f1/8fd9074bf66c unityhub://2020.3.1f1/77a89f25062f unityhub://2020.3.0f1/c7b5465681fb Unity 2020.2：\n1 2 3 4 5 6 7 8 unityhub://2020.2.7f1/c53830e277f1 unityhub://2020.2.6f1/8a2143876886 unityhub://2020.2.5f1/e2c53f129de5 unityhub://2020.2.4f1/becced5a802b unityhub://2020.2.3f1/8ff31bc5bf5b unityhub://2020.2.2f1/068178b99f32 unityhub://2020.2.1f1/270dd8c3da1c unityhub://2020.2.0f1/3721df5a8b28 Unity 2020.1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 unityhub://2020.1.17f1/9957aee8edc2 unityhub://2020.1.16f1/f483ad6465d6 unityhub://2020.1.15f1/97d0ae02d19d unityhub://2020.1.14f1/d81f64f5201d unityhub://2020.1.13f1/5e24f28bfbc0 unityhub://2020.1.12f1/55b56f0a86e3 unityhub://2020.1.11f1/698c1113cef0 unityhub://2020.1.10f1/974a9d56f159 unityhub://2020.1.9f1/145f5172610f unityhub://2020.1.8f1/22e8c0b0c3ec unityhub://2020.1.7f1/064ffcdb64ad unityhub://2020.1.6f1/fc477ca6df10 unityhub://2020.1.5f1/e025938fdedc unityhub://2020.1.4f1/fa717bb873ec unityhub://2020.1.3f1/cf5c4788e1d8 unityhub://2020.1.2f1/7b32bc54ba47 unityhub://2020.1.1f1/2285c3239188 unityhub://2020.1.0f1/2ab9c4179772 Unity 2019.4（LTS）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 unityhub://2019.4.20f1/6dd1c08eedfa unityhub://2019.4.19f1/ca5b14067cec unityhub://2019.4.18f1/3310a4d4f880 unityhub://2019.4.17f1/667c8606c536 unityhub://2019.4.16f1/e05b6e02d63e unityhub://2019.4.15f1/fbf367ac14e9 unityhub://2019.4.14f1/4037e52648cd unityhub://2019.4.13f1/518737b1de84 unityhub://2019.4.12f1/225e826a680e unityhub://2019.4.11f1/2d9804dddde7 unityhub://2019.4.10f1/5311b3af6f69 unityhub://2019.4.9f1/50fe8a171dd9 unityhub://2019.4.8f1/60781d942082 unityhub://2019.4.7f1/e992b1a16e65 unityhub://2019.4.6f1/a7aea80e3716 unityhub://2019.4.5f1/81610f64359c unityhub://2019.4.4f1/1f1dac67805b unityhub://2019.4.3f1/f880dceab6fe unityhub://2019.4.2f1/20b4642a3455 unityhub://2019.4.1f1/e6c045e14e4e unityhub://2019.4.0f1/0af376155913 Unity 2019.3：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 unityhub://2019.3.15f1/59ff3e03856d unityhub://2019.3.14f1/2b330bf6d2d8 unityhub://2019.3.13f1/d4ddf0d95db9 unityhub://2019.3.12f1/84b23722532d unityhub://2019.3.11f1/ceef2d848e70 unityhub://2019.3.10f1/5968d7f82152 unityhub://2019.3.9f1/e6e740a1c473 unityhub://2019.3.8f1/4ba98e9386ed unityhub://2019.3.8f1/4ba98e9386ed unityhub://2019.3.7f1/6437fd74d35d unityhub://2019.3.6f1/5c3fb0a11183 unityhub://2019.3.5f1/d691e07d38ef unityhub://2019.3.4f1/4f139db2fdbd unityhub://2019.3.3f1/7ceaae5f7503 unityhub://2019.3.2f1/c46a3a38511e unityhub://2019.3.1f1/89d6087839c2 unityhub://2019.3.0f6/27ab2135bccf Unity 2019.2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 unityhub://2019.2.21f1/9d528d026557 unityhub://2019.2.20f1/c67d00285037 unityhub://2019.2.19f1/929ab4d01772 unityhub://2019.2.18f1/bbf64de26e34 unityhub://2019.2.17f1/8e603399ca02 unityhub://2019.2.16f1/b9898e2d04a4 unityhub://2019.2.15f1/dcb72c2e9334 unityhub://2019.2.14f1/49dd4e9fa428 unityhub://2019.2.13f1/e20f6c7e5017 unityhub://2019.2.12f1/b1a7e1fb4fa5 unityhub://2019.2.11f1/5f859a4cfee5 unityhub://2019.2.10f1/923acd2d43aa unityhub://2019.2.9f1/ebce4d76e6e8 unityhub://2019.2.8f1/ff5b465c8d13 unityhub://2019.2.7f2/c96f78eb5904 unityhub://2019.2.6f1/fe82a0e88406 unityhub://2019.2.5f1/9dace1eed4cc unityhub://2019.2.4f1/c63b2af89a85 unityhub://2019.2.3f1/8e55c27a4621 unityhub://2019.2.2f1/ab112815d860 unityhub://2019.2.1f1/ca4d5af0be6f unityhub://2019.2.0f1/20c1667945cf Unity 2019.1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 unityhub://2019.1.14f1/148b5891095a unityhub://2019.1.13f1/b5956c0a61e7 unityhub://2019.1.12f1/f04f5427219e unityhub://2019.1.11f1/9b001d489a54 unityhub://2019.1.10f1/f007ed779b7a unityhub://2019.1.9f1/d5f1b37da199 unityhub://2019.1.8f1/7938dd008a75 unityhub://2019.1.7f1/f3c4928e5742 unityhub://2019.1.6f1/f2970305fe1c unityhub://2019.1.5f1/0ca0f5646614 unityhub://2019.1.4f1/ffa3a7a2dd7d unityhub://2019.1.3f1/dc414eb9ed43 unityhub://2019.1.2f1/3e18427e571f unityhub://2019.1.1f1/fef62e97e63b unityhub://2019.1.0f2/292b93d75a2c Unity 2018.4 (LTS) ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 unityhub://2018.4.32f1/fba45da84107 unityhub://2018.4.31f1/212ea663d844 unityhub://2018.4.30f1/c698a062d8e6 unityhub://2018.4.29f1/50cce2edf27f unityhub://2018.4.28f1/a2d4f71491a4 unityhub://2018.4.27f1/4e283b7d3f88 unityhub://2018.4.26f1/a7ac1c6396db unityhub://2018.4.25f1/b07bfa0a8827 unityhub://2018.4.24f1/3071911a89e9 unityhub://2018.4.23f1/c9cf1a90e812 unityhub://2018.4.22f1/3362ffbb7aa1 unityhub://2018.4.21f1/fd3915227633 unityhub://2018.4.20f1/008688490035 unityhub://2018.4.19f1/459f70f82ea4 unityhub://2018.4.18f1/61fce66342ad unityhub://2018.4.17f1/b830f56f42f0 unityhub://2018.4.16f1/e6e9ca02b32a unityhub://2018.4.15f1/13f5a1bf9ca1 unityhub://2018.4.14f1/05119b33d0b7 unityhub://2018.4.13f1/497f083a43af unityhub://2018.4.12f1/59ddc4c59b4f unityhub://2018.4.11f1/7098af2f11ea unityhub://2018.4.10f1/a0470569e97b unityhub://2018.4.9f1/ca372476eaba unityhub://2018.4.8f1/9bc9d983d803 unityhub://2018.4.7f1/b9a993fd1334 unityhub://2018.4.6f1/cde1bbcc9f0d unityhub://2018.4.5f1/7b38f8ac282e unityhub://2018.4.4f1/5440768ff61c unityhub://2018.4.3f1/8a9509a5aff9 unityhub://2018.4.2f1/d6fb3630ea75 unityhub://2018.4.1f1/b7c424a951c0 unityhub://2018.4.0f1/b6ffa8986c8d Unity 2018.3：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 unityhub://2018.3.14f1/d0e9f15437b1 unityhub://2018.3.13f1/06548a9e9582 unityhub://2018.3.12f1/8afd630d1f5b unityhub://2018.3.11f1/5063218e4ab8 unityhub://2018.3.10f1/f88de2c96e63 unityhub://2018.3.9f1/947e1ea5aa8d unityhub://2018.3.8f1/fc0fe30d6d91 unityhub://2018.3.7f1/9e14d22a41bb unityhub://2018.3.6f1/a220877bc173 unityhub://2018.3.5f1/76b3e37670a4 unityhub://2018.3.4f1/1d952368ca3a unityhub://2018.3.3f1/393bae82dbb8 unityhub://2018.3.2f1/b3c100a4b73a unityhub://2018.3.1f1/bb579dc42f1d unityhub://2018.3.0f2/6e9a27477296 Unity 2018.2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 unityhub://2018.2.21f1/a122f5dc316d unityhub://2018.2.20f1/cef3e6c0c622 unityhub://2018.2.19f1/06990f28ba00 unityhub://2018.2.18f1/4550892b6062 unityhub://2018.2.17f1/88933597c842 unityhub://2018.2.16f1/39a4ac3d51f6 unityhub://2018.2.15f1/65e0713a5949 unityhub://2018.2.14f1/3262fb3b0716 unityhub://2018.2.13f1/83fbdcd35118 unityhub://2018.2.12f1/0a46ddfcfad4 unityhub://2018.2.11f1/38bd7dec5000 unityhub://2018.2.10f1/674aa5a67ed5 unityhub://2018.2.9f1/2207421190e9 unityhub://2018.2.8f1/ae1180820377 unityhub://2018.2.7f1/4ebd28dd9664 unityhub://2018.2.6f1/c591d9a97a0b unityhub://2018.2.5f1/3071d1717b71 unityhub://2018.2.4f1/cb262d9ddeaf unityhub://2018.2.3f1/1431a7d2ced7 unityhub://2018.2.2f1/c18cef34cbcd unityhub://2018.2.1f1/1a9968d9f99c unityhub://2018.2.0f2/787658998520 Unity 2018.1：\n1 2 3 4 5 6 7 8 9 10 unityhub://2018.1.9f2/a6cc294b73ee unityhub://2018.1.8f1/26051d4de9e9 unityhub://2018.1.7f1/4cb482063d12 unityhub://2018.1.6f1/57cc34175ccf unityhub://2018.1.5f1/732dbf75922d unityhub://2018.1.4f1/1a308f4ebef1 unityhub://2018.1.3f1/a53ad04f7c7f unityhub://2018.1.2f1/a46d718d282d unityhub://2018.1.1f1/b8cbb5de9840 unityhub://2018.1.0f2/d4d99f31acba Unity 2017.4 (LTS) ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 unityhub://2017.4.40f1/6e14067f8a9a unityhub://2017.4.39f1/947131c5be7e unityhub://2017.4.38f1/82ac2fb100ce unityhub://2017.4.37f1/78b69503ebc4 unityhub://2017.4.36f1/c663def8414c unityhub://2017.4.35f1/e57a7bcbbf0b unityhub://2017.4.34f1/121f18246307 unityhub://2017.4.33f1/a8557a619e24 unityhub://2017.4.32f1/4da3ed968770 unityhub://2017.4.31f1/9c8dbc3421cb unityhub://2017.4.30f1/c6fa43736cae unityhub://2017.4.29f1/06508aa14ca1 unityhub://2017.4.28f1/e3a0f7dd2097 unityhub://2017.4.27f1/0c4b856e4c6e unityhub://2017.4.26f1/3b349d10f010 unityhub://2017.4.25f1/9cba1c3a94f1 unityhub://2017.4.24f1/786769fc3439 unityhub://2017.4.23f1/f80c8a98b1b5 unityhub://2017.4.22f1/eb4bc6fa7f1d unityhub://2017.4.21f1/de35fe252486 unityhub://2017.4.20f2/413dbd19b6dc unityhub://2017.4.19f1/47cd37c28be8 unityhub://2017.4.18f1/a9236f402e28 unityhub://2017.4.17f1/05307cddbb71 unityhub://2017.4.16f1/7f7bdd1ef02b unityhub://2017.4.15f1/5d485b4897a7 unityhub://2017.4.14f1/b28150134d55 unityhub://2017.4.13f1/6902ad48015d unityhub://2017.4.12f1/b582b87345b1 unityhub://2017.4.11f1/8c6b8ef6d111 unityhub://2017.4.10f1/f2cce2a5991f unityhub://2017.4.9f1/6d84dfc57ccf unityhub://2017.4.8f1/5ab7f4878ef1 unityhub://2017.4.7f1/de9eb5ca33c5 unityhub://2017.4.6f1/c24f30193bac unityhub://2017.4.5f1/89d1db9cb682 unityhub://2017.4.4f1/645c9050ba4d unityhub://2017.4.3f1/21ae32b5a9cb unityhub://2017.4.2f2/52d9cb89b362 unityhub://2017.4.1f1/9231f953d9d3 Unity 2017.3：\n1 2 unityhub://2017.3.1f1/fc1d3344e6ea unityhub://2017.3.0f3/a9f86dcd79df Unity 2017.2：\n1 2 3 4 5 6 unityhub://2017.2.5f1/588dc79c95ed unityhub://2017.2.4f1/f1557d1f61fd unityhub://2017.2.3f1/372229934efd unityhub://2017.2.2f1/1f4e0f9b6a50 unityhub://2017.2.1f1/94bf3f9e6b5e unityhub://2017.2.0f3/46dda1414e51 Unity 2017.1：\n1 2 3 4 5 6 unityhub://2017.1.5f1/9758a36cfaa6 unityhub://2017.1.4f1/9fd71167a288 unityhub://2017.1.3f1/574eeb502d14 unityhub://2017.1.2f1/cc85bf6a8a04 unityhub://2017.1.1f1/5d30cf096e79 unityhub://2017.1.0f3/472613c02cf7 Unity 5：\n1 2 3 4 5 6 7 8 unityhub://5.6.7f1/e80cc3114ac1 unityhub://5.6.6f2/6bac21139588 unityhub://5.6.5f1/2cac56bf7bb6 unityhub://5.6.4f1/ac7086b8d112 unityhub://5.6.3f1/d3101c3b8468 unityhub://5.6.2f1/a2913c821e27 unityhub://5.6.1f1/2860b30f0b54 unityhub://5.6.0f3/497a0f351392 ","description":"","id":32,"section":"posts","tags":["unity,mac"],"title":"使用Unity Hub安装Unity","uri":"https://popo-blog.vercel.app/posts/%E4%BD%BF%E7%94%A8unity-hub%E5%AE%89%E8%A3%85unity/"},{"content":"步骤1：验证是否正确打开工程目录 你可以查看VSCode左侧的资源管理器，查看列表当中是否有sln文件。如果有继续往下看。\n步骤2：验证工程是否指定正确 VSCode无法进行Unity C#智能提示，代码补全以及方法跳转等功能的解决方案！\n按下键盘的Ctrl/Command + Shift+ P快捷键，选定工程目录下的sln文件。\n至此，如果你以前是有代码提示的，稍等几秒等待自动加载完成以后你可以重试一下是否有代码提示功能\n步骤3：检查和安装对应的.NET开发者版本 记住你的版本号，到这下载对应版本号的开发者版 .NET Framework 。\nhttps://docs.microsoft.com/zh-cn/dotnet/framework/deployment/deployment-guide-for-developers\n注意你需要下载Developer版本的，如果是Runtime版本很可能安装的时候会提示你已经安装了当前或更高版本的.NET从而拒绝你安装。当然稳妥方式都装一遍… 装完以后，重开VSCode。你期待的代码提示就会出现了！ 其他相关 利用控制台定位问题 1.留意你的VSCode控制台输出面板，通常在这里会弹出启动报错信息。仔细阅读输出的报错信息，大部分错误都会有告诉你解决问题的方式。\n代码提示有了，但找不到UnityEngine.UI等类 步骤1：点开Unity的 Package Manager，找到右Visual Studio Code Editor，选择1.2.0以后的版本，然后点击右下角的升级按钮。(注意如果你用的2019,插件不要用太新的版本.否则还是会出现.不出来的情况.)\n步骤2：保存并关闭Unity和VSCode，到工程目录下删除所有的*.sln和*.csproj文件。\n步骤3：重新打开Unity和这个工程，刚被删除的这两个文件将会被重新创建，届时这个故障就解决了。\n如果你不想重启unity和vscode参照这个帖子https://blog.csdn.net/weixin_45476117/article/details/108911678\ngameobject什么的只能.出一个智能引用 这里还是Unity Package Manager的插件惹的祸,我这里用1.2.0可以但是升级到1.2.3就出现这个问题.建议降级到低版本尝试.\n","description":"","id":33,"section":"posts","tags":["VSCode、Unity"],"title":"解决VSCode无法显示Unity代码提示的真正解决办法","uri":"https://popo-blog.vercel.app/posts/%E8%A7%A3%E5%86%B3vscode%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BAunity%E4%BB%A3%E7%A0%81%E6%8F%90%E7%A4%BA%E7%9A%84%E7%9C%9F%E6%AD%A3%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"content":"开发过程中，经常会有一些通用的部分希望抽取出来做成一个公共库来提供给别的工程来使用，而公共代码库的版本管理是个麻烦的事情。git submodule命令就可以解决这个问题。\nGit归并策略\nGit归并有两种策略：递归，章鱼。\n1.递归策略：当分支数只有两个的时候。\n2.章鱼策略：当分支数大于两个的时候。\nGit会自动选择归并的方法。\n3.子树策略：是Git另一种归并方法。（submodule）\n它可以把另一个子项目，嵌入到当前项目。而且会非常聪明的合并这些子项目。\n添加\n为当前工程添加submodule，命令如下：\n1 git submodule add 仓库地址 路径 其中，仓库地址是指子模块仓库地址，路径指将子模块放置在当前工程下的路径。\n注意：路径不能以 / 结尾（会造成修改不生效）、不能是现有工程已有的目录（不能順利 Clone）\n示例:\n1 git submodule add -f http://git.cs/Cmblife_iOS_Internal/modulesLib.git -f 是强制的意思，一般不需要加\n命令执行完成，会在当前工程根路径下生成一个名为“.gitmodules”的文件，其中记录了子模块的信息。添加完成以后，再将子模块所在的文件夹添加到工程中即可。\n删除\nsubmodule的删除稍微麻烦点：首先，要在“.gitmodules”文件中删除相应配置信息。然后，执行“git rm –cached ”命令将子模块所在的文件从git中删除。\n下载的工程带有submodule\n当使用git clone下来的工程中带有submodule时，初始的时候，submodule的内容并不会自动下载下来的，此时，只需执行如下命令：\n1 git submodule update --init --recursive 即可将子模块内容下载下来后工程才不会缺少相应的文件。\n————————————————\n版权声明：本文为CSDN博主「糖果屋的世界」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/ajdfhajdkfakr/article/details/77892137\nI came to this SO post trying to add a submodule with the same path as a submodule that I recently deleted.\nThis is what ultimately worked for me (this article helped out a lot):\nIf you haven\u0026rsquo;t already run\n1 git rm --cached path_to_submodule` (no trailing slash) as well as 1 rm -rf path_to_submodule` Then:\nDelete the relevant lines from the .gitmodules file. e.g. delete these: 1 2 3 [submodule \u0026#34;path_to_submodule\u0026#34;] path = path_to_submodule url = https://github.com/path_to_submodule Delete the relevant section from .git/config. e.g. delete these: 1 2 [submodule \u0026#34;path_to_submodule\u0026#34;] url = https://github.com/path_to_submodule rm -rf .git/modules/path_to_submodule Then, you can finally:\n1 git submodule add https://github.com/path_to_submodule ","description":"","id":34,"section":"posts","tags":["git"],"title":"git 添加子项目","uri":"https://popo-blog.vercel.app/posts/git-%E6%B7%BB%E5%8A%A0%E5%AD%90%E9%A1%B9%E7%9B%AE/"},{"content":" 说明：本页面是书籍《Unity Shader入门精要》的随书彩图集锦，包含了书中所有的插图，使用时可通过图片编号进行搜索。\n作者：冯乐乐\n邮箱：lelefeng1992@gmail.com\n前言 第2章 渲染流水线 图2.1　真实生活中的流水线\n图2.2 渲染流水线中的三个概念阶段\n图2.3 渲染所需的数据（两张纹理以及3个网格）从硬盘最终加载到显存中。在渲染时，GPU可以快速访问这些数据\n图2.4 在同一状态下渲染三个网格。由于没有更改渲染状态，因此三个网格的外观看起来像是同一种材质的物体。\n图2.5 CPU通过调用Draw Call来告诉GPU开始进行一个渲染过程。一个Draw Call会指向本次调用需要渲染的图元列表\n图2.6 GPU的渲染流水线实现。颜色表示了不同阶段的可配置性或可编程性：绿色表示该流水线阶段是完全可编程控制的，黄色表示该流水线阶段可以配置但不是可编程的，蓝色表示该流水线阶段是由GPU固定实现的，开发者没有任何控制权。实线表示该shader必须由开发者编程实现，虚线表示该Shader是可选的\n图2.7 GPU在每个输入的网格顶点上都会调用顶点着色器。顶点着色器必须进行顶点的坐标变换，需要时还可以计算和输出顶点的颜色。例如，我们可能需要进行逐顶点的光照\n图2.8 顶点着色器会将模型顶点的位置变换到齐次裁剪坐标空间下，进行输出后再由硬件做透视除法得到NDC下的坐标\n图2.9 只有在单位立方体的图元才需要被继续处理。因此，完全在单位立方体外部的图元（红色三角形）被舍弃，完全在单位立方体内部的图元（绿色三角形）将被保留。和单位立方体相交的图元（黄色三角形）会被裁剪，新的顶点会被生成，原来在外部的顶点会被舍弃\n图2.10 屏幕映射将x、y坐标从（-1, 1）范围转换到屏幕坐标系中\n图2.11 OpenGL和DirectX的屏幕坐标系差异。对于一张512*512大小的图像，在OpenGL中其（0, 0）点在左下角，而在DirectX中其(0, 0)点在左上角\n图2.12 三角形遍历的过程。根据几何阶段输出的顶点信息，最终得到该三角网格覆盖的像素位置。对应像素会生成一个片元，而片元中的状态是对三个顶点的信息进行插值得到的。例如，对图2.12中三个顶点的深度进行插值得到其重心位置对应的片元的深度值为-10.0\n图2.13 根据上一步插值后的片元信息，片元着色器计算该片元的输出颜色\n图2.14 逐片元操作阶段所做的操作。只有通过了所有的测试后，新生成的片元才能和颜色缓冲区中已经存在的像素颜色进行混合，最后再写入颜色缓冲区中\n图2.15 模板测试和深度测试的简化流程图。\n图2.16 混合操作的简化流程图\n图2.17 图示场景中包含了两个对象：球和长方体，绘制顺序是先绘制球（在屏幕上显示为圆），再绘制长方体（在屏幕上显示为长方形）。如果深度测试在片元着色器之后执行，那么在渲染长方体时，虽然它的大部分区域都被遮挡在球的后面，即它所覆盖的绝大部分片元根本无法通过深度测试，但是我们仍然需要对这些片元执行片元着色器，造成了很大的性能浪费\n图2.18 CPU、OpenGL/DirectX、显卡驱动和GPU之间的关系\n图2.19 命令缓冲区。CPU通过图像编程接口向命令缓冲区中添加命令，而GPU从中读取命令并执行。黄色方框内的命令就是Draw Call，而红色方框内的命令用于改变渲染状态。我们使用红色方框来表示改变渲染状态的命令，\u2028是因为这些命令往往更加耗时\n图2.20 命令缓冲区中的虚线方框表示GPU已经完成的命令。此时，命令缓冲区中没有可以执行的命令了，GPU处于空闲状态，而CPU还没有准备好下一个渲染命令。\n图2.21 利用批处理，CPU在RAM把多个网格合并成一个更大的网格，再发送给GPU，然后在一个Draw Call中渲染它们。但要注意的是，使用批处理合并的网格将会使用同一种渲染状态。也就是说，如果网格之间需要使用不同的渲染状态，那么就无法使用批处理技术\n第3章 Unity Shader基础 图3.1 Unity Shader和材质。首先创建需要的Unity Shader和材质，然后把Unity Shader赋给材质，并在材质面板上调整属性（如使用的纹理、漫反射系数等）。最后，将材质赋给相应的模型来查看最终的渲染效果\n图3.2 将材质直接拖曳到模型的Mesh Renderer组件中\n图3.3 材质提供了一种可视化的方式来调整着色器中使用的参数\n图3.4 Unity Shader的导入设置面板\n图3.5 Gompile and show code下拉列表\n图3.6 Unity Shader为控制渲染过程提供了一层抽象。如果没有使用Unity Shader（左图），开发者需要和很多文件和设置打交道，才能让画面呈现出想要的效果；而在Unity Shader的帮助下（右图），开发者只需要使用ShaderLab来编写Unity Shader文件就可以完成所有的工作\n图3.7 在Unity Shader的名称定义中利用\u2028斜杠来组织在材质面板中的位置\n图3.8 不同属性类型在材质\u2028面板中的显示结果\n图3.9 在Unity Shader的导入设置面板中可以通过Compile and show code按钮来查看Unity对CG片段编译后的代码。通过单击Compile and show code按钮右端的倒三角可以打开下拉菜单，在这个下拉菜单中可以选择编译的平台种类，如只为当前的显卡设备编译特定的汇编代码，或为所有的平台编译汇编代码，我们也可以自定义选择编译到哪些平台上\n第4章 学习Shader所需的数学基础 图4.1 我们的农场游戏。我们的主角妞妞是一头长得最壮、好奇心很强的奶牛\n图4.2 传说，笛卡尔坐标系来源于笛卡尔对天花板上一只苍蝇的运动轨迹的观察。笛卡尔发现，可以使用苍蝇距不同墙面的距离来描述它的当前位置\n图4.3 一个二维笛卡尔坐标系\n图4.4 在屏幕映射时，OpenGL和DirectX使用了不同方向的二维笛卡尔坐标系\n图4.5 笛卡尔坐标系可以让妞妞精确表述自己的位置\n图4.6 一个三维笛卡尔坐标系\n图4.7 左手坐标系\n图4.8 右手坐标系\n图4.9 用左手法则和右手法则来判断旋转正方向\n图4.10 为了移动到新的位置，妞妞需要首先向某个方向平移1个单位，再向另一个方向平移4个单位，最后再向一个方向旋转60°\n图4.11 左图和右图分别表示了在左手坐标系和右手坐标系中描述妞妞这次运动的结果，得到的数学描述是不同的\n图4.12 在模型空间和世界空间中，Unity使用的是左手坐标系。图中，球的坐标轴显示了它在模型空间中的3个坐标轴（红色为x轴，绿色是y轴，蓝色是z轴）\n图4.13 在Unity中，观察空间使用的是右手坐标系，摄像机的前向是z轴的负方向，\u2028z轴越小，物体的深度越大，离摄像机越远\n图4.14 摄像机的位置是（0, 1, -10），球体的位置是（0, 1, 0）\n图4.15 一个二维向量以及它的头和尾\n图4.16 点和矢量之间的关系\n图4.17 二维矢量和一些标量的乘法和除法\n图4.18 二维矢量的加法和减法\n图4.19 使用矢量减法来计算从点a到点b的位移\n图4.20 矢量的模\n图4.21 二维空间的单位矢量都会落在单位圆上\n图4.22 矢量b在单位矢量a方向上的投影\n图4.23 点积的符号\n图4.24 两个单位矢量进行点积\n图4.25 三维矢量叉积的计算规律。不同颜色的线表示了计算结果矢量中对应颜色的分量的计算路径。以红色为例，即结果矢量的第一个分量，它是从第一个矢量的y分量出发乘以第二个矢量的z分量，再减去第一个矢量的z分量和第二矢量的y分量的乘积\n图4.26 使用矢量a和矢量b构建一个平行四边形\n图4.27 分别使用左手坐标系和右手坐标系得到的叉积结果\n图4.28 使用右手法则判断右手坐标系中a×b的方向\n图4.29 三角形的三个顶点位于xy平面上，人眼位于z轴负方向，向z轴正方向观察\n图4.30 计算c23的过程\n图4.31 场景中的妞妞（左图）和屏幕上的妞妞（右图）。妞妞想知道，自己的鼻子是如何被画到屏幕上的\n图4.32 在我们的农场游戏中，每个奶牛都有自己的模型坐标系。在模型坐标系中妞妞鼻子的位置是(0, 2, 4, 1)\n图4.33 Unity的Transform组件可以调节模型的位置.如果Transform有父节点，如图中的“Mesh”，那么Position将是在其父节点（这里是“Cow”）的模型空间中的位置；如果没有父节点，Position就是在世界空间中的位置\n图4.34 农场游戏中的世界空间。世界空间的原点被放置在农场的中心。左下角显示了妞妞在世界空间中所做的变换。我们想要把妞妞的鼻子从模型空间变换到世界空间中\n图4.35 农场游戏中摄像机的观察空间。观察空间的原点位于摄像机处。注意在观察空间中，摄像机的前向是z轴的负方向（图中只画出了z轴正方向），这是因为Unity在观察空间中使用了右手坐标系。左下角显示了摄像机在世界空间中所做的变换。我们想要把妞妞的鼻子从世界空间变换到观察空间中\n图4.36 透视投影（左图）和正交投影（右图）。左下角分别显示了当前摄像机的投影模式和相关属性\n图4.37 视锥体和裁剪平面。左图显示了透视投影的视锥体，右图显示了正交投影的视锥体\n图4.38 透视摄像机的参数对透视投影视锥体的影响\n图4.39 在透视投影中，投影矩阵对顶点进行了缩放。图3.38中标注了4个关键点经过投影矩阵变换后的结果。从这些结果可以看出x、y、z和w分量的范围发生的变化\n图4.40 正交摄像机的参数对正交投影视锥体的影响\n图4.41 在正交投影中，投影矩阵对顶点进行了缩放。图中标注了4个关键点经过投影矩阵变换后的结果。从这些结果可以看出x、y、z和w分量范围发生的变化\n图4.42 农场游戏使用的摄像机参数和游戏画面的横纵比\n图4.43 经过齐次除法后，透视投影的裁剪空间会变换到一个立方体\n图4.44 经过齐次除法后，正交投影的裁剪空间会变换到一个立方体\n图4.45 渲染流水线中顶点的空间变换过程\n图4.46 Unity中各个坐标空间的旋向性\n图4.47 顶点的切线和法线。切线和法线互相垂直\n图4.48 进行非统一缩放时，如果使用和变换顶点相同的变换矩阵来变换法线，就会得到错误的结果，即变换后的法线方向与平面不再垂直\n图4.49 由片元的像素位置得到的图像\n图4.50 图中两个坐标系的x轴和y轴是重合的，区别仅在于z轴的方向。左手坐标系的（0, 0, 1）点和右手坐标系中的（0, 0, 1）点是不同的，但它们旋转后的点却对应到了同一点\n图4.51 绝对空间中的同一点，在左手和右手坐标系中进行同样角度的旋转，其旋转方向是不一样的。在左手坐标系中将按顺时针方向旋转，在右手坐标系中将按逆时针方向旋转\n图4.52 在左手坐标系中，如果叉积结果为负，那么3点的顺序是顺时针方向\n第5章 开始Unity Shader学习之旅 图5.1 在Unity 5中新建一个场景得到的效果\n图5.2 用一个最简单的顶点/片元着色器得到一个白色的球\n图5.3 Unity的内置着色器\n图5.4 用假彩色对Unity Shader进行调试\n图5.5 使用颜色拾取器来查看调试信息\n图5.6 帧调试器\n图5.7 单击Knot的深度图渲染事件，在Game视图会显示该事件的效果，在Hierarchy视图中会高亮显示Knot对象，在帧调试器的右侧窗口会显示出该事件的细节\n图5.8 OpenGL和DirectX使用了不同的屏幕空间坐标\n第6章 Unity中的基础光照 图6.1 在左图中，光是垂直照射到物体表面，因此光线之间的垂直距离保持不变；而在右图中，光是斜着照射到物体表面，在物体表面光线之间的距离是d/cosθ，因此单位面积上接收到的光线数目要少于左图\n图6.2 散射时，光线会发生折射和反射现象。对于不透明物体，折射的光线会在物体内部继续传播，最终有一部分光线会重新从物体表面被发射出去\n图6.3 使用Phong模型计算高光反射\n图6.4 Blinn模型\n图6.5 在Unity的Window -\u0026gt; Lighting面板中，我们可以通过Ambient Source/Ambient Color/Ambient Intensity来控制场景中的环境光的颜色和强度\n图6.6 逐顶点的漫反射光照效果\n图6.7 逐像素的漫反射光照效果\n图6.8 逐顶点漫反射光照、逐像素漫反射光照、半兰伯特光照的对比效果\n图6.9 CG的reflect函数\n图6.10 逐顶点的高光反射光照效果\n图6.11 逐像素的高光反射光照效果\n图6.12 逐顶点的高光反射光照、逐像素的高光反射光照（Phong光照模型）和Blinn-Phong高光反射光照的对比结果\n第7章 基础纹理 图7.1 Unity中的纹理坐标\n图7.2 使用单张纹理\n图7.3 调节纹理的平铺（缩放）和偏移（平移）属性\n图7.4 纹理的属性\n图7.5 Wrap Mode决定了当纹理坐标超过[0, 1]范围后将会如何被平铺\n图7.6 偏移（Offset）属性决定了纹理坐标的偏移量\n图7.7 在放大纹理时，分别使用三种Filter Mode得到的结果\n图7.8 在Advanced模式下可以设置多级渐远纹理的相关属性\n图7.9 从上到下： Point滤波 + 多级渐远纹理技术，Bilinear滤波 + 多级渐远纹理技术，Trilinear滤波 + 多级渐远纹理技术\n图7.10 选择纹理的最大尺寸和纹理模式\n图7.11 高度图\n图7.12 模型顶点的切线空间。其中，原点对应了顶点坐标，x轴是切线方向（t），y轴是副切线方向（b），z轴是法线方向（n）\n图7.13 左图：模型空间下的法线纹理。右图：切线空间下的法线纹理\n图7.14 使用法线纹理\n图7.15 使用Bump Scale属性来调整模型的凹凸程度\n图7.16 当使用UnpackNormal函数计算法线纹理中的法线方向时，需要把纹理类型标识为Normal map\n图7.17 当勾选了Create from Grayscale后，Unity会根据高度图来生成一张切线空间下的法线纹理\n图7.18 使用不同的渐变纹理控制漫反射光照，左下角给出了每张图使用的渐变纹理\n图7.19 Wrap Mode分别为Repeat和Clamp模式的效果对比\n图7.20 使用高光遮罩纹理。从左到右：只包含漫反射，未使用遮罩的高光反射，使用遮罩的高光反射\n图7.21 本节使用的高光遮罩纹理\n第8章 透明效果 图8.1 场景中有两个物体，其中A（黄色）是半透明物体，B（紫色）是不透明物体\n图8.2 场景中有两个物体，其中A和B都是半透明物体\n图8.3 循环重叠的半透明物体总是无法得到正确的半透明效果\n图8.4 使用哪个深度对物体进行排序。红色点分别标明了网格上距离摄像机最近的点、最远的点以及网格中点\n图8.5 一张透明纹理，其中每个方格的透明度都不同\n图8.6 透明度测试\n图8.7 随着Alpha cutoff参数的增大，更多的像素由于不满足透明度测试条件而被剔除\n图8.8 透明度混合\n图8.9 随着Alpha Scale参数的增大，模型变得越来越透明\n图8.10 当模型网格之间有互相交叉的结构时，往往会得到错误的半透明效果\n图8.11 开启了深度写入的半透明效果\n图8.12 不同混合状态设置得到的效果\n图8.13 双面渲染的透明度测试的物体\n图8.14 双面渲染的透明度混合的物体\n第9章 更复杂的光照 图9.1 设置Unity项目的渲染路径\n图9.2 摄像机组件的Rendering Path中的设置可以覆盖Project Settings中的设置\n图9.3 设置光源的类型和渲染模式\n图9.4 前向渲染的两种Pass\n图9.5 平行光\n图9.6 点光源\n图9.7 开启Scene视图中的光照\n图9.8 聚光灯\n图9.9 使用一个平行光和一个点光源共同照亮物体。右图显示了胶囊体、平行光和点光源在场景中的相对位置\n图9.10 使用1个平行光 + 4个点光源照亮一个物体\n图9.11 打开帧调试器查看场景的绘制事件\n图9.12 本例中的6个渲染事件，绘制顺序是从左到右、从上到下进行的\n图9.13 如果物体不在一个光源的光照范围内（从右图可以看出，胶囊体不在最左方的点光源的照明范围内），Unity是不会调用Additional Pass来为该物体处理该光源的\n图9.14 当把光源的Render Mode设为Not Important时，这些光源就不会按逐像素光来处理\n图9.15 开启光源的阴影效果\n图9.16 Mesh Renderer组件的Cast Shadows和Receive Shadows属性可以控制该物体是否投射/接收阴影\n图9.17 开启Cast Shadows和Receive Shadows，从而让正方体可以投射和接收阴影\n图9.18 把Cast Shadows设置为Two Sided可以让右侧平面的背光面也产生阴影\n图9.19 正方体可以接收来自右侧平面的阴影\n图9.20 使用帧调试器查看阴影绘制过程\n图9.21 正方体对深度纹理的更新结果\n图9.22 屏幕空间的阴影图\n图9.23 Unity绘制屏幕阴影的过程\n图9.24 可以投射阴影的使用透明度测试的物体\n图9.25 正确设置了Fallback的使用透明度测试的物体\n图9.26 正确设置了Cast Shadow属性的使用透明度测试的物体\n图9.27 把使用了透明度混合的Unity Shader的Fallback设置为内置的Transparent/VertexLit。半透明物体不会向下方的平面投射阴影，也不会接收来自右侧平面的阴影，它看起来就像是完全透明一样\n图9.28 把Fallback设为VertexLit来强制为半透明物体生成阴影\n第10章 高级纹理 图10.1 对立方体纹理的采样\n图10.2 天空盒子材质\n图10.3 为场景使用自定义的天空盒子\n图10.4 使用了天空盒子的场景\n图10.5 使用脚本创建立方体纹理\n图10.6 使用脚本渲染立方体纹理\n图10.7 使用了反射效果的Teapot模型\n图10.8 斯涅尔定律\n图10.9 使用了折射效果的Teapot模型\n图10.10 使用了菲涅耳反射的Teapot模型\n图10.11 镜子效果\n图10.12 左图：把摄像机的Target Texture设置成自定义的渲染纹理。右图：渲染纹理使用的纹理设置\n图10.13 玻璃效果\n图10.14 本例使用的立方体纹理\n图10.15 脚本生成的程序纹理\n图10.16　调整程序纹理的参数来得到不同的程序纹理\n图10.17　后缀为.sbsar的Substance材质\n图10.18　程序纹理资源\n图10.19　调整程序纹理属性可以得到看似完全不同的程序材质效果\n第11章 让画面动起来 图11.1 本节使用的序列帧图像\n图11.2 使用序列帧动画来实现爆炸效果\n图11.3 无限滚动的背景（纹理来源：forest-background © 2012-2013 Julien Jorge julien.jorge@stuff-o-matic.com）\n图11.4 使用顶点动画来模拟2D的河流\n图11.5 法线固定（总是指向视角方向）时，计算广告牌技术中的三个正交基的过程\n图11.6 广告牌效果。左图显示了摄像机和5个广告牌之间的位置关系，摄像机是从斜上方向下观察它们的。中间的图显示了当Vertical Restraints属性为1，即固定法线方向为观察视角时所得到的效果，可以看出，所有的广告牌都完全面朝摄像机。右图显示了当Vertical Restraints属性为0，即固定指向上的方向为(0, 1, 0)时所得到的效果，可以看出，广告牌虽然最大限度地面朝摄像机，但其指向上的方向并未发生改变\n图11.7 当进行顶点动画时，如果仍然使用内置的ShadowCaster Pass来渲染阴影，可能会得到错误的阴影效果\n图11.8 使用自定义的ShadowCaster Pass\u2028为变形物体绘制正确的阴影\n第12章 屏幕后处理效果 图12.1 左图：原效果。右图：调整了亮度（值为1.2）、饱和度（值为1.6）和对比度（值为1.2）后的效果\n图12.2 为脚本设置Shader的默认值\n图12.3 左图：12.2节得到的结果。\u2028右图：进行边缘检测后的效果\n图12.4 卷积核与卷积。使用一个3×3大小的卷积核对一张5×5大小的图像进行卷积操作，当计算图中红色方块对应的像素的卷积结果时，我们首先把卷积核的中心放置在该像素位置，翻转核之后再依次计算核中每个元素和其覆盖的图像像素值的乘积并求和，得到新的像素值\n图12.5 三种常见的边缘检测算子\n图12.6 只显示边缘的屏幕效果\n图12.7 左图：原效果。右图：高斯模糊后的效果\n图12.8 一个5×5大小的高斯核。左图显示了标准方差为1的高斯核的权重分布。我们可以把这个二维高斯核拆分成两个一维的高斯核（右图）\n图12.9 动画短片《大象之梦》中的Bloom效果。光线透过门扩散到了周围较暗的区域中\n图12.10 左图：原效果。右图：Bloom处理后的效果\n图12.11 左图：原效果。右图：应用运动模糊后的效果\n第13章 使用深度和法线纹理 图13.1 在透视投影中，投影矩阵首先对顶点进行了缩放。在经过齐次除法后，透视投影的裁剪空间会变换到一个立方体。图中标注了4个关键点经过投影矩阵变换后的结果\n图13.2 在正交投影中，投影矩阵对顶点进行了缩放。在经过齐次除法后，正交投影的裁剪空间会变换到一个立方体。图中标注了4个关键点经过投影矩阵变换后的结果\n图13.3 使用Frame Debugger查看深度纹理（左）和深度+法线纹理（右）。如果当前摄像机需要生成深度和法线纹理，帧调试器的面板中就会出现相应的渲染事件。只要单击对应的事件就可以查看得到的深度和法线纹理\n图13.4 左图：线性空间下的深度纹理。右图：解码后并且被映射到[0, 1]范围内的视角空间下的法线纹理\n图13.5 左图：原效果。右图：添加全局雾效后的效果\n图13.6 计算interpolatedRay\n图13.7 采样得到的深度值并非是点到摄像机的欧式距离\n图13.8 左图：原效果。右图：直接对颜色图像进行边缘检测的结果\n图13.9 在深度和法线纹理上进行更健壮的边缘检测。左图：在原图上描边的效果。右图：只显示描边的效果\n图13.10 Roberts算子\n第14章 非真实感渲染 图14.1 游戏《大神》（英文名：Okami）的游戏截图\n图14.2 卡通风格的渲染效果\n图14.3 左图：未对高光区域进行抗锯齿处理。右图：使用fwidth函数对高光区域进行抗锯齿处理\n图14.4 一个TAM的例子（来源：Praun E, et al. Real-time hatching4）\n图14.5 素描风格的渲染效果\n第15章 使用噪声 图15.1 箱子的消融效果\n图15.2 消融效果使用的噪声纹理\n图15.3 包含菲涅耳反射的水面波动效果。在左图中，视角方向和水面法线的夹角越大，反射效果越强。在右图中，视角方向和水面法线的夹角越大，折射效果越强\n图15.4 本例使用的立方体纹理\n图15.5 水波效果使用的噪声纹理。左图：噪声纹理的灰度图。右图：由左图生成的法线纹理\n图15.6 左图：均匀雾效。右图：使用噪声纹理后的非均匀雾效\n图15.7 本节使用的噪声纹理\n第16章 Unity中的渲染优化技术 图16.1 Unity 5的渲染统计窗口\n图16.2 使用Unity的性能分析器中的渲染区域来查看更多关于渲染的统计信息\n图16.3 使用帧调试器来查看单独的draw call的绘制结果\n图16.4 动态批处理\n图16.5 多光源对动态批处理的影响结果\n图16.6 静态批处理前的渲染统计数据\n图16.7 把物体标志为Static\n图16.8 静态批处理\n图16.9 静态批处理中Unity会合并所有被标识为“Static”的物体\n图16.10 静态批处理会占用更多的内存。左图：静态批处理前的渲染统计数据。右图：静态批处理后的渲染统计数据\n图16.11 处理其他逐像素光的Pass不会被静态批处理\n图16.12 Unity的高级纹理设置面板\n第17章 Surface Shader探秘 图17.1 表面着色器的例子。左图：在一个平行光下的效果。右图：添加了一个点光源（蓝色）和一个聚光灯（紫色）后的效果\n图17.2 查看表面着色器生成的代码\n图17.3 表面着色器的渲染计算流水线。黄色：可以自定义的函数。灰色：Unity自动生成的计算步骤\n图17.4 沿顶点法线对模型进行膨胀。左图：膨胀前。右图：膨胀后\n第18章 基于物理的渲染 图18.1 在理想的边界处，折射率的突变会把光线分成两个方向\n图18.2 左图：光滑表面的微平面的法线变化较小，反射光线的方向变化也更小。\u2028右图：粗糙表面的微平面的法线变化较大，反射光线的方向变化也更大\n图18.3 微表面对光的折射。这些被折射的光中一部分被吸收，一部分又被散射到外部\n图18.4 次表面散射。左图：次表面散射的光线会从不同于入射点的位置射出。如果这些距离值小于需要被着色的像素大小，那么渲染就可以完全在局部完成（右图）。否则，就需要使用次表面散射渲染技术\n图18.5 BRDF描述的两种现象。高光反射部分用于描述反射，漫反射部分用于描述次表面散射\n图18.6 （a）那些m=h的微面元会恰好把入射光从I反射到v上，只有这部分微面元才可以添加到BRDF的计算中。（b）一部分满足（a）的微面元会在I方向上被其他微面元遮挡住，它们不会接受到光照，因此会形成阴影。（c）还有一部分满足（a）的微面元会在反射方向v上被其他微面元挡住，因此，这部分反射光也不会被看到\n图18.7 Standard Shader中前向渲染路径使用的Pass（简化版本的PBS使用了VertexOutputBaseSimple等结构体来代替相应的结构体）\n图18.8 Unity提供的校准表格。左图：金属工作流\u2028使用的校准表格。右图：高光反射工作流使用的校准表格\n图18.9 使用金属工作流来实现不同类型的材质。左边的球体：金属材质。右边的球体：塑料材质\n图18.10 在Unity 5中使用基于物理的渲染技术，场景在不同光照下的渲染结果\n图18.11 光照面板下的Scene标签页\n图18.12 左图：当关闭场景中的所有光源并把环境光照强度设为0后，使用了Standard Shader的物体仍然具有光照效果。右图：在左图的基础上，把反射源设置为空，使得物体不接受任何默认的反射信息\n图18.13 使用的平行光\n图18.14 左图：将Bounce Intensity设置为0，物体不再受到间接光照的影响，木屋内阴影部分的可见细节很少。右图：将Bounce Intensity设为8，阴影部分的细节更加清楚\n图18.15 左图：未使用反射探针。右图：在场景中放置了两个反射探针，注意墙上的盾牌与左图的差别\n图18.16 使用反射探针实现相互反射的效果\n图18.17 左图：在线性空间下的渲染结果。右图：在伽马空间下的渲染结果\n图18.18 人眼更容易感知暗部区域的变换，而对较亮区域的变化比较不敏感\n图18.19 编码伽马和显示伽马\n![gamma_light.png-32.1k《Unity Shader入门精要》随书彩色插图\n说明：本页面是书籍《Unity Shader入门精要》的随书彩图集锦，包含了书中所有的插图，使用时可通过图片编号进行搜索。\n作者：冯乐乐\n邮箱：lelefeng1992@gmail.com\n前言 第2章 渲染流水线 图2.1　真实生活中的流水线\n图2.2 渲染流水线中的三个概念阶段\n图2.3 渲染所需的数据（两张纹理以及3个网格）从硬盘最终加载到显存中。在渲染时，GPU可以快速访问这些数据\n图2.4 在同一状态下渲染三个网格。由于没有更改渲染状态，因此三个网格的外观看起来像是同一种材质的物体。\n图2.5 CPU通过调用Draw Call来告诉GPU开始进行一个渲染过程。一个Draw Call会指向本次调用需要渲染的图元列表\n图2.6 GPU的渲染流水线实现。颜色表示了不同阶段的可配置性或可编程性：绿色表示该流水线阶段是完全可编程控制的，黄色表示该流水线阶段可以配置但不是可编程的，蓝色表示该流水线阶段是由GPU固定实现的，开发者没有任何控制权。实线表示该shader必须由开发者编程实现，虚线表示该Shader是可选的\n图2.7 GPU在每个输入的网格顶点上都会调用顶点着色器。顶点着色器必须进行顶点的坐标变换，需要时还可以计算和输出顶点的颜色。例如，我们可能需要进行逐顶点的光照\n图2.8 顶点着色器会将模型顶点的位置变换到齐次裁剪坐标空间下，进行输出后再由硬件做透视除法得到NDC下的坐标\n图2.9 只有在单位立方体的图元才需要被继续处理。因此，完全在单位立方体外部的图元（红色三角形）被舍弃，完全在单位立方体内部的图元（绿色三角形）将被保留。和单位立方体相交的图元（黄色三角形）会被裁剪，新的顶点会被生成，原来在外部的顶点会被舍弃\n图2.10 屏幕映射将x、y坐标从（-1, 1）范围转换到屏幕坐标系中\n图2.11 OpenGL和DirectX的屏幕坐标系差异。对于一张512*512大小的图像，在OpenGL中其（0, 0）点在左下角，而在DirectX中其(0, 0)点在左上角\n图2.12 三角形遍历的过程。根据几何阶段输出的顶点信息，最终得到该三角网格覆盖的像素位置。对应像素会生成一个片元，而片元中的状态是对三个顶点的信息进行插值得到的。例如，对图2.12中三个顶点的深度进行插值得到其重心位置对应的片元的深度值为-10.0\n图2.13 根据上一步插值后的片元信息，片元着色器计算该片元的输出颜色\n图2.14 逐片元操作阶段所做的操作。只有通过了所有的测试后，新生成的片元才能和颜色缓冲区中已经存在的像素颜色进行混合，最后再写入颜色缓冲区中\n图2.15 模板测试和深度测试的简化流程图。\n图2.16 混合操作的简化流程图\n图2.17 图示场景中包含了两个对象：球和长方体，绘制顺序是先绘制球（在屏幕上显示为圆），再绘制长方体（在屏幕上显示为长方形）。如果深度测试在片元着色器之后执行，那么在渲染长方体时，虽然它的大部分区域都被遮挡在球的后面，即它所覆盖的绝大部分片元根本无法通过深度测试，但是我们仍然需要对这些片元执行片元着色器，造成了很大的性能浪费\n图2.18 CPU、OpenGL/DirectX、显卡驱动和GPU之间的关系\n图2.19 命令缓冲区。CPU通过图像编程接口向命令缓冲区中添加命令，而GPU从中读取命令并执行。黄色方框内的命令就是Draw Call，而红色方框内的命令用于改变渲染状态。我们使用红色方框来表示改变渲染状态的命令，\u2028是因为这些命令往往更加耗时\n图2.20 命令缓冲区中的虚线方框表示GPU已经完成的命令。此时，命令缓冲区中没有可以执行的命令了，GPU处于空闲状态，而CPU还没有准备好下一个渲染命令。\n图2.21 利用批处理，CPU在RAM把多个网格合并成一个更大的网格，再发送给GPU，然后在一个Draw Call中渲染它们。但要注意的是，使用批处理合并的网格将会使用同一种渲染状态。也就是说，如果网格之间需要使用不同的渲染状态，那么就无法使用批处理技术\n第3章 Unity Shader基础 图3.1 Unity Shader和材质。首先创建需要的Unity Shader和材质，然后把Unity Shader赋给材质，并在材质面板上调整属性（如使用的纹理、漫反射系数等）。最后，将材质赋给相应的模型来查看最终的渲染效果\n图3.2 将材质直接拖曳到模型的Mesh Renderer组件中\n图3.3 材质提供了一种可视化的方式来调整着色器中使用的参数\n图3.4 Unity Shader的导入设置面板\n图3.5 Gompile and show code下拉列表\n图3.6 Unity Shader为控制渲染过程提供了一层抽象。如果没有使用Unity Shader（左图），开发者需要和很多文件和设置打交道，才能让画面呈现出想要的效果；而在Unity Shader的帮助下（右图），开发者只需要使用ShaderLab来编写Unity Shader文件就可以完成所有的工作\n图3.7 在Unity Shader的名称定义中利用\u2028斜杠来组织在材质面板中的位置\n图3.8 不同属性类型在材质\u2028面板中的显示结果\n图3.9 在Unity Shader的导入设置面板中可以通过Compile and show code按钮来查看Unity对CG片段编译后的代码。通过单击Compile and show code按钮右端的倒三角可以打开下拉菜单，在这个下拉菜单中可以选择编译的平台种类，如只为当前的显卡设备编译特定的汇编代码，或为所有的平台编译汇编代码，我们也可以自定义选择编译到哪些平台上\n第4章 学习Shader所需的数学基础 图4.1 我们的农场游戏。我们的主角妞妞是一头长得最壮、好奇心很强的奶牛\n图4.2 传说，笛卡尔坐标系来源于笛卡尔对天花板上一只苍蝇的运动轨迹的观察。笛卡尔发现，可以使用苍蝇距不同墙面的距离来描述它的当前位置\n图4.3 一个二维笛卡尔坐标系\n图4.4 在屏幕映射时，OpenGL和DirectX使用了不同方向的二维笛卡尔坐标系\n图4.5 笛卡尔坐标系可以让妞妞精确表述自己的位置\n图4.6 一个三维笛卡尔坐标系\n图4.7 左手坐标系\n图4.8 右手坐标系\n图4.9 用左手法则和右手法则来判断旋转正方向\n图4.10 为了移动到新的位置，妞妞需要首先向某个方向平移1个单位，再向另一个方向平移4个单位，最后再向一个方向旋转60°\n图4.11 左图和右图分别表示了在左手坐标系和右手坐标系中描述妞妞这次运动的结果，得到的数学描述是不同的\n图4.12 在模型空间和世界空间中，Unity使用的是左手坐标系。图中，球的坐标轴显示了它在模型空间中的3个坐标轴（红色为x轴，绿色是y轴，蓝色是z轴）\n图4.13 在Unity中，观察空间使用的是右手坐标系，摄像机的前向是z轴的负方向，\u2028z轴越小，物体的深度越大，离摄像机越远\n图4.14 摄像机的位置是（0, 1, -10），球体的位置是（0, 1, 0）\n图4.15 一个二维向量以及它的头和尾\n图4.16 点和矢量之间的关系\n图4.17 二维矢量和一些标量的乘法和除法\n图4.18 二维矢量的加法和减法\n图4.19 使用矢量减法来计算从点a到点b的位移\n图4.20 矢量的模\n图4.21 二维空间的单位矢量都会落在单位圆上\n图4.22 矢量b在单位矢量a方向上的投影\n图4.23 点积的符号\n图4.24 两个单位矢量进行点积\n图4.25 三维矢量叉积的计算规律。不同颜色的线表示了计算结果矢量中对应颜色的分量的计算路径。以红色为例，即结果矢量的第一个分量，它是从第一个矢量的y分量出发乘以第二个矢量的z分量，再减去第一个矢量的z分量和第二矢量的y分量的乘积\n图4.26 使用矢量a和矢量b构建一个平行四边形\n图4.27 分别使用左手坐标系和右手坐标系得到的叉积结果\n图4.28 使用右手法则判断右手坐标系中a×b的方向\n图4.29 三角形的三个顶点位于xy平面上，人眼位于z轴负方向，向z轴正方向观察\n图4.30 计算c23的过程\n图4.31 场景中的妞妞（左图）和屏幕上的妞妞（右图）。妞妞想知道，自己的鼻子是如何被画到屏幕上的\n图4.32 在我们的农场游戏中，每个奶牛都有自己的模型坐标系。在模型坐标系中妞妞鼻子的位置是(0, 2, 4, 1)\n图4.33 Unity的Transform组件可以调节模型的位置.如果Transform有父节点，如图中的“Mesh”，那么Position将是在其父节点（这里是“Cow”）的模型空间中的位置；如果没有父节点，Position就是在世界空间中的位置\n图4.34 农场游戏中的世界空间。世界空间的原点被放置在农场的中心。左下角显示了妞妞在世界空间中所做的变换。我们想要把妞妞的鼻子从模型空间变换到世界空间中\n图4.35 农场游戏中摄像机的观察空间。观察空间的原点位于摄像机处。注意在观察空间中，摄像机的前向是z轴的负方向（图中只画出了z轴正方向），这是因为Unity在观察空间中使用了右手坐标系。左下角显示了摄像机在世界空间中所做的变换。我们想要把妞妞的鼻子从世界空间变换到观察空间中\n图4.36 透视投影（左图）和正交投影（右图）。左下角分别显示了当前摄像机的投影模式和相关属性\n图4.37 视锥体和裁剪平面。左图显示了透视投影的视锥体，右图显示了正交投影的视锥体\n图4.38 透视摄像机的参数对透视投影视锥体的影响\n图4.39 在透视投影中，投影矩阵对顶点进行了缩放。图3.38中标注了4个关键点经过投影矩阵变换后的结果。从这些结果可以看出x、y、z和w分量的范围发生的变化\n图4.40 正交摄像机的参数对正交投影视锥体的影响\n图4.41 在正交投影中，投影矩阵对顶点进行了缩放。图中标注了4个关键点经过投影矩阵变换后的结果。从这些结果可以看出x、y、z和w分量范围发生的变化\n图4.42 农场游戏使用的摄像机参数和游戏画面的横纵比\n图4.43 经过齐次除法后，透视投影的裁剪空间会变换到一个立方体\n图4.44 经过齐次除法后，正交投影的裁剪空间会变换到一个立方体\n图4.45 渲染流水线中顶点的空间变换过程\n图4.46 Unity中各个坐标空间的旋向性\n图4.47 顶点的切线和法线。切线和法线互相垂直\n图4.48 进行非统一缩放时，如果使用和变换顶点相同的变换矩阵来变换法线，就会得到错误的结果，即变换后的法线方向与平面不再垂直\n图4.49 由片元的像素位置得到的图像\n图4.50 图中两个坐标系的x轴和y轴是重合的，区别仅在于z轴的方向。左手坐标系的（0, 0, 1）点和右手坐标系中的（0, 0, 1）点是不同的，但它们旋转后的点却对应到了同一点\n图4.51 绝对空间中的同一点，在左手和右手坐标系中进行同样角度的旋转，其旋转方向是不一样的。在左手坐标系中将按顺时针方向旋转，在右手坐标系中将按逆时针方向旋转\n图4.52 在左手坐标系中，如果叉积结果为负，那么3点的顺序是顺时针方向\n第5章 开始Unity Shader学习之旅 图5.1 在Unity 5中新建一个场景得到的效果\n图5.2 用一个最简单的顶点/片元着色器得到一个白色的球\n图5.3 Unity的内置着色器\n图5.4 用假彩色对Unity Shader进行调试\n图5.5 使用颜色拾取器来查看调试信息\n图5.6 帧调试器\n图5.7 单击Knot的深度图渲染事件，在Game视图会显示该事件的效果，在Hierarchy视图中会高亮显示Knot对象，在帧调试器的右侧窗口会显示出该事件的细节\n图5.8 OpenGL和DirectX使用了不同的屏幕空间坐标\n第6章 Unity中的基础光照 图6.1 在左图中，光是垂直照射到物体表面，因此光线之间的垂直距离保持不变；而在右图中，光是斜着照射到物体表面，在物体表面光线之间的距离是d/cosθ，因此单位面积上接收到的光线数目要少于左图\n图6.2 散射时，光线会发生折射和反射现象。对于不透明物体，折射的光线会在物体内部继续传播，最终有一部分光线会重新从物体表面被发射出去\n图6.3 使用Phong模型计算高光反射\n图6.4 Blinn模型\n图6.5 在Unity的Window -\u0026gt; Lighting面板中，我们可以通过Ambient Source/Ambient Color/Ambient Intensity来控制场景中的环境光的颜色和强度\n图6.6 逐顶点的漫反射光照效果\n图6.7 逐像素的漫反射光照效果\n图6.8 逐顶点漫反射光照、逐像素漫反射光照、半兰伯特光照的对比效果\n图6.9 CG的reflect函数\n图6.10 逐顶点的高光反射光照效果\n图6.11 逐像素的高光反射光照效果\n图6.12 逐顶点的高光反射光照、逐像素的高光反射光照（Phong光照模型）和Blinn-Phong高光反射光照的对比结果\n第7章 基础纹理 图7.1 Unity中的纹理坐标\n图7.2 使用单张纹理\n图7.3 调节纹理的平铺（缩放）和偏移（平移）属性\n图7.4 纹理的属性\n图7.5 Wrap Mode决定了当纹理坐标超过[0, 1]范围后将会如何被平铺\n图7.6 偏移（Offset）属性决定了纹理坐标的偏移量\n图7.7 在放大纹理时，分别使用三种Filter Mode得到的结果\n图7.8 在Advanced模式下可以设置多级渐远纹理的相关属性\n图7.9 从上到下： Point滤波 + 多级渐远纹理技术，Bilinear滤波 + 多级渐远纹理技术，Trilinear滤波 + 多级渐远纹理技术\n图7.10 选择纹理的最大尺寸和纹理模式\n图7.11 高度图\n图7.12 模型顶点的切线空间。其中，原点对应了顶点坐标，x轴是切线方向（t），y轴是副切线方向（b），z轴是法线方向（n）\n图7.13 左图：模型空间下的法线纹理。右图：切线空间下的法线纹理\n图7.14 使用法线纹理\n图7.15 使用Bump Scale属性来调整模型的凹凸程度\n图7.16 当使用UnpackNormal函数计算法线纹理中的法线方向时，需要把纹理类型标识为Normal map\n图7.17 当勾选了Create from Grayscale后，Unity会根据高度图来生成一张切线空间下的法线纹理\n图7.18 使用不同的渐变纹理控制漫反射光照，左下角给出了每张图使用的渐变纹理\n图7.19 Wrap Mode分别为Repeat和Clamp模式的效果对比\n图7.20 使用高光遮罩纹理。从左到右：只包含漫反射，未使用遮罩的高光反射，使用遮罩的高光反射\n图7.21 本节使用的高光遮罩纹理\n第8章 透明效果 图8.1 场景中有两个物体，其中A（黄色）是半透明物体，B（紫色）是不透明物体\n图8.2 场景中有两个物体，其中A和B都是半透明物体\n图8.3 循环重叠的半透明物体总是无法得到正确的半透明效果\n图8.4 使用哪个深度对物体进行排序。红色点分别标明了网格上距离摄像机最近的点、最远的点以及网格中点\n图8.5 一张透明纹理，其中每个方格的透明度都不同\n图8.6 透明度测试\n图8.7 随着Alpha cutoff参数的增大，更多的像素由于不满足透明度测试条件而被剔除\n图8.8 透明度混合\n图8.9 随着Alpha Scale参数的增大，模型变得越来越透明\n图8.10 当模型网格之间有互相交叉的结构时，往往会得到错误的半透明效果\n图8.11 开启了深度写入的半透明效果\n图8.12 不同混合状态设置得到的效果\n图8.13 双面渲染的透明度测试的物体\n图8.14 双面渲染的透明度混合的物体\n第9章 更复杂的光照 图9.1 设置Unity项目的渲染路径\n图9.2 摄像机组件的Rendering Path中的设置可以覆盖Project Settings中的设置\n图9.3 设置光源的类型和渲染模式\n图9.4 前向渲染的两种Pass\n图9.5 平行光\n图9.6 点光源\n图9.7 开启Scene视图中的光照\n图9.8 聚光灯\n图9.9 使用一个平行光和一个点光源共同照亮物体。右图显示了胶囊体、平行光和点光源在场景中的相对位置\n图9.10 使用1个平行光 + 4个点光源照亮一个物体\n图9.11 打开帧调试器查看场景的绘制事件\n图9.12 本例中的6个渲染事件，绘制顺序是从左到右、从上到下进行的\n图9.13 如果物体不在一个光源的光照范围内（从右图可以看出，胶囊体不在最左方的点光源的照明范围内），Unity是不会调用Additional Pass来为该物体处理该光源的\n图9.14 当把光源的Render Mode设为Not Important时，这些光源就不会按逐像素光来处理\n图9.15 开启光源的阴影效果\n图9.16 Mesh Renderer组件的Cast Shadows和Receive Shadows属性可以控制该物体是否投射/接收阴影\n图9.17 开启Cast Shadows和Receive Shadows，从而让正方体可以投射和接收阴影\n图9.18 把Cast Shadows设置为Two Sided可以让右侧平面的背光面也产生阴影\n图9.19 正方体可以接收来自右侧平面的阴影\n图9.20 使用帧调试器查看阴影绘制过程\n图9.21 正方体对深度纹理的更新结果\n图9.22 屏幕空间的阴影图\n图9.23 Unity绘制屏幕阴影的过程\n图9.24 可以投射阴影的使用透明度测试的物体\n图9.25 正确设置了Fallback的使用透明度测试的物体\n图9.26 正确设置了Cast Shadow属性的使用透明度测试的物体\n图9.27 把使用了透明度混合的Unity Shader的Fallback设置为内置的Transparent/VertexLit。半透明物体不会向下方的平面投射阴影，也不会接收来自右侧平面的阴影，它看起来就像是完全透明一样\n图9.28 把Fallback设为VertexLit来强制为半透明物体生成阴影\n第10章 高级纹理 图10.1 对立方体纹理的采样\n图10.2 天空盒子材质\n图10.3 为场景使用自定义的天空盒子\n图10.4 使用了天空盒子的场景\n图10.5 使用脚本创建立方体纹理\n图10.6 使用脚本渲染立方体纹理\n图10.7 使用了反射效果的Teapot模型\n图10.8 斯涅尔定律\n图10.9 使用了折射效果的Teapot模型\n图10.10 使用了菲涅耳反射的Teapot模型\n图10.11 镜子效果\n图10.12 左图：把摄像机的Target Texture设置成自定义的渲染纹理。右图：渲染纹理使用的纹理设置\n图10.13 玻璃效果\n图10.14 本例使用的立方体纹理\n图10.15 脚本生成的程序纹理\n图10.16　调整程序纹理的参数来得到不同的程序纹理\n图10.17　后缀为.sbsar的Substance材质\n图10.18　程序纹理资源\n图10.19　调整程序纹理属性可以得到看似完全不同的程序材质效果\n第11章 让画面动起来 图11.1 本节使用的序列帧图像\n图11.2 使用序列帧动画来实现爆炸效果\n图11.3 无限滚动的背景（纹理来源：forest-background © 2012-2013 Julien Jorge julien.jorge@stuff-o-matic.com）\n图11.4 使用顶点动画来模拟2D的河流\n图11.5 法线固定（总是指向视角方向）时，计算广告牌技术中的三个正交基的过程\n图11.6 广告牌效果。左图显示了摄像机和5个广告牌之间的位置关系，摄像机是从斜上方向下观察它们的。中间的图显示了当Vertical Restraints属性为1，即固定法线方向为观察视角时所得到的效果，可以看出，所有的广告牌都完全面朝摄像机。右图显示了当Vertical Restraints属性为0，即固定指向上的方向为(0, 1, 0)时所得到的效果，可以看出，广告牌虽然最大限度地面朝摄像机，但其指向上的方向并未发生改变\n图11.7 当进行顶点动画时，如果仍然使用内置的ShadowCaster Pass来渲染阴影，可能会得到错误的阴影效果\n图11.8 使用自定义的ShadowCaster Pass\u2028为变形物体绘制正确的阴影\n第12章 屏幕后处理效果 图12.1 左图：原效果。右图：调整了亮度（值为1.2）、饱和度（值为1.6）和对比度（值为1.2）后的效果\n图12.2 为脚本设置Shader的默认值\n图12.3 左图：12.2节得到的结果。\u2028右图：进行边缘检测后的效果\n图12.4 卷积核与卷积。使用一个3×3大小的卷积核对一张5×5大小的图像进行卷积操作，当计算图中红色方块对应的像素的卷积结果时，我们首先把卷积核的中心放置在该像素位置，翻转核之后再依次计算核中每个元素和其覆盖的图像像素值的乘积并求和，得到新的像素值\n图12.5 三种常见的边缘检测算子\n图12.6 只显示边缘的屏幕效果\n图12.7 左图：原效果。右图：高斯模糊后的效果\n图12.8 一个5×5大小的高斯核。左图显示了标准方差为1的高斯核的权重分布。我们可以把这个二维高斯核拆分成两个一维的高斯核（右图）\n图12.9 动画短片《大象之梦》中的Bloom效果。光线透过门扩散到了周围较暗的区域中\n图12.10 左图：原效果。右图：Bloom处理后的效果\n图12.11 左图：原效果。右图：应用运动模糊后的效果\n第13章 使用深度和法线纹理 图13.1 在透视投影中，投影矩阵首先对顶点进行了缩放。在经过齐次除法后，透视投影的裁剪空间会变换到一个立方体。图中标注了4个关键点经过投影矩阵变换后的结果\n图13.2 在正交投影中，投影矩阵对顶点进行了缩放。在经过齐次除法后，正交投影的裁剪空间会变换到一个立方体。图中标注了4个关键点经过投影矩阵变换后的结果\n图13.3 使用Frame Debugger查看深度纹理（左）和深度+法线纹理（右）。如果当前摄像机需要生成深度和法线纹理，帧调试器的面板中就会出现相应的渲染事件。只要单击对应的事件就可以查看得到的深度和法线纹理\n图13.4 左图：线性空间下的深度纹理。右图：解码后并且被映射到[0, 1]范围内的视角空间下的法线纹理\n图13.5 左图：原效果。右图：添加全局雾效后的效果\n图13.6 计算interpolatedRay\n图13.7 采样得到的深度值并非是点到摄像机的欧式距离\n图13.8 左图：原效果。右图：直接对颜色图像进行边缘检测的结果\n图13.9 在深度和法线纹理上进行更健壮的边缘检测。左图：在原图上描边的效果。右图：只显示描边的效果\n图13.10 Roberts算子\n第14章 非真实感渲染 图14.1 游戏《大神》（英文名：Okami）的游戏截图\n图14.2 卡通风格的渲染效果\n图14.3 左图：未对高光区域进行抗锯齿处理。右图：使用fwidth函数对高光区域进行抗锯齿处理\n图14.4 一个TAM的例子（来源：Praun E, et al. Real-time hatching4）\n图14.5 素描风格的渲染效果\n第15章 使用噪声 图15.1 箱子的消融效果\n图15.2 消融效果使用的噪声纹理\n图15.3 包含菲涅耳反射的水面波动效果。在左图中，视角方向和水面法线的夹角越大，反射效果越强。在右图中，视角方向和水面法线的夹角越大，折射效果越强\n图15.4 本例使用的立方体纹理\n图15.5 水波效果使用的噪声纹理。左图：噪声纹理的灰度图。右图：由左图生成的法线纹理\n图15.6 左图：均匀雾效。右图：使用噪声纹理后的非均匀雾效\n图15.7 本节使用的噪声纹理\n第16章 Unity中的渲染优化技术 图16.1 Unity 5的渲染统计窗口\n图16.2 使用Unity的性能分析器中的渲染区域来查看更多关于渲染的统计信息\n图16.3 使用帧调试器来查看单独的draw call的绘制结果\n图16.4 动态批处理\n图16.5 多光源对动态批处理的影响结果\n图16.6 静态批处理前的渲染统计数据\n图16.7 把物体标志为Static\n图16.8 静态批处理\n图16.9 静态批处理中Unity会合并所有被标识为“Static”的物体\n图16.10 静态批处理会占用更多的内存。左图：静态批处理前的渲染统计数据。右图：静态批处理后的渲染统计数据\n图16.11 处理其他逐像素光的Pass不会被静态批处理\n图16.12 Unity的高级纹理设置面板\n第17章 Surface Shader探秘 图17.1 表面着色器的例子。左图：在一个平行光下的效果。右图：添加了一个点光源（蓝色）和一个聚光灯（紫色）后的效果\n图17.2 查看表面着色器生成的代码\n图17.3 表面着色器的渲染计算流水线。黄色：可以自定义的函数。灰色：Unity自动生成的计算步骤\n图17.4 沿顶点法线对模型进行膨胀。左图：膨胀前。右图：膨胀后\n第18章 基于物理的渲染 图18.1 在理想的边界处，折射率的突变会把光线分成两个方向\n图18.2 左图：光滑表面的微平面的法线变化较小，反射光线的方向变化也更小。\u2028右图：粗糙表面的微平面的法线变化较大，反射光线的方向变化也更大\n图18.3 微表面对光的折射。这些被折射的光中一部分被吸收，一部分又被散射到外部\n图18.4 次表面散射。左图：次表面散射的光线会从不同于入射点的位置射出。如果这些距离值小于需要被着色的像素大小，那么渲染就可以完全在局部完成（右图）。否则，就需要使用次表面散射渲染技术\n图18.5 BRDF描述的两种现象。高光反射部分用于描述反射，漫反射部分用于描述次表面散射\n图18.6 （a）那些m=h的微面元会恰好把入射光从I反射到v上，只有这部分微面元才可以添加到BRDF的计算中。（b）一部分满足（a）的微面元会在I方向上被其他微面元遮挡住，它们不会接受到光照，因此会形成阴影。（c）还有一部分满足（a）的微面元会在反射方向v上被其他微面元挡住，因此，这部分反射光也不会被看到\n图18.7 Standard Shader中前向渲染路径使用的Pass（简化版本的PBS使用了VertexOutputBaseSimple等结构体来代替相应的结构体）\n图18.8 Unity提供的校准表格。左图：金属工作流\u2028使用的校准表格。右图：高光反射工作流使用的校准表格\n图18.9 使用金属工作流来实现不同类型的材质。左边的球体：金属材质。右边的球体：塑料材质\n图18.10 在Unity 5中使用基于物理的渲染技术，场景在不同光照下的渲染结果\n图18.11 光照面板下的Scene标签页\n图18.12 左图：当关闭场景中的所有光源并把环境光照强度设为0后，使用了Standard Shader的物体仍然具有光照效果。右图：在左图的基础上，把反射源设置为空，使得物体不接受任何默认的反射信息\n图18.13 使用的平行光\n图18.14 左图：将Bounce Intensity设置为0，物体不再受到间接光照的影响，木屋内阴影部分的可见细节很少。右图：将Bounce Intensity设为8，阴影部分的细节更加清楚\n图18.15 左图：未使用反射探针。右图：在场景中放置了两个反射探针，注意墙上的盾牌与左图的差别\n图18.16 使用反射探针实现相互反射的效果\n图18.17 左图：在线性空间下的渲染结果。右图：在伽马空间下的渲染结果\n图18.18 人眼更容易感知暗部区域的变换，而对较亮区域的变化比较不敏感\n图18.19 编码伽马和显示伽马\n图18.20 左图：伽马空间下的渲染结果。右图：线性空间下的渲染结果\n图18.21 左图：伽马空间下的混合结果。右图：线性空间下的混合结果\n第19章 Unity 5更新了什么 图19.1 在shader的导入面板中，单击图中按钮可查看Unity为该固定管线着色器生成的顶点/片元着色器代码B](http://static.zybuluo.com/candycat/xuxe7bp91pykknxybt6yu2wu/gamma_light.png)\n图18.20 左图：伽马空间下的渲染结果。右图：线性空间下的渲染结果\n图18.21 左图：伽马空间下的混合结果。右图：线性空间下的混合结果\n第19章 Unity 5更新了什么 图19.1 在shader的导入面板中，单击图中按钮可查看Unity为该固定管线着色器生成的顶点/片元着色器代码\n","description":"","id":35,"section":"posts","tags":["Unity Shader入门精要"],"title":"《Unity Shader入门精要》随书彩色插图","uri":"https://popo-blog.vercel.app/posts/unity-shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E9%9A%8F%E4%B9%A6%E5%BD%A9%E8%89%B2%E6%8F%92%E5%9B%BE/"},{"content":"第一部分：\npublic/private/protected的具体区别\n在说明这四个关键字之前，就class之间的关系做一个简单的定义，对于继承自己的class，base class可以认为他们都是自己的子女，而对于和自己一个目录下的classes，认为都是自己的朋友。\n1、public：public表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用\n2、private：private表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用，私有财产神圣不可侵犯嘛，即便是子女，朋友，都不可以使用。\n3、protected：protected对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private。\n第二部分：\n派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。\n我们可以根据访问权限总结出不同的访问类型，如下所示：\n一个派生类继承了所有基类的方法，但下列情况除外：\n*基类的构造函数、析构函数和拷贝构造函数（可能是为了多继承定义不出现冲突）\n*除了赋值运算符重载函数以外，所有的运算符重载函数都可以被派生类继承。 （原因：“赋\n值运算符重载函数”不是不能被派生类继承，而是被派生类的默认“赋值运算符重载函数”给\n覆盖了。这就是 C++赋值运算符重载函数不能被派生类继承的真实原因！ ） ，更详细的解释传\n送门：http://blog.csdn.net/wuyuan2011woaini/article/details/9407933，感谢这位网友。\n*基类的友元函数（父亲的朋友不一定是你的朋友）\n————————————————\n版权声明：本文为CSDN博主「spu20134823091」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/spu20134823091/article/details/53836192\n","description":"","id":36,"section":"posts","tags":["public，private，protected"],"title":"public，private，protected的区别，继承方法与访问权限","uri":"https://popo-blog.vercel.app/posts/public-private-protected/"},{"content":"顶点、 图元、片元、像素的含义 *阶段1. 顶点 -\u0026gt;图元*\n几何顶点被组合为图元（点，线段或多边形），然后图元被合成片元，最后片元被转换为帧缓存中的象素数据。\n*阶段2. 图元 -\u0026gt;片元*\n图元被分几步转换为片元：图元被适当的裁剪，颜色和纹理数据也相应作出必要的调整，相关的坐标被转换为窗口坐标。最后，光栅化将裁剪好的图元转换为片元。\n裁剪 在裁剪时点，线段和多边形处理略微不同。对于点，要么保留原始状态（在裁剪体内部），要么被裁掉（在裁剪体外部）。对于线段和多边形来说，如果部分在裁剪体外部，则需要在裁剪点生成新的几何顶点。对于多边形，还需要在新增的顶点间增加完整的边。不论裁剪了线段还是多边形，都需要给新增几何点赋予边界标志、法线、颜色和纹理坐标信息。\n裁剪过程时两步：\na 应用程序指定裁剪（Application-specific clipping），一旦组合图元完成后，如果在程序中用glClipPlane()函数定义了任意的裁剪面，就进行裁剪。\nb 视景体裁剪（View volume clipping），随后，图元被投影矩阵投影（进入裁剪坐标系），被相应的视景体裁剪。投影矩阵可以由glFrustum() 或者glOrtho()定义，投影矩阵的操作和上面其他矩阵变换的操作相同。\n2） 转换到窗口坐标\n裁剪坐标在转换为窗口坐标之前，要除以规格化设备坐标（normalized device coordinates）的w值进行规范化。然后对这些规范化数据进行视口变换（viewport）计算生成窗口坐标。可以用glDepthRange()和glViewport()控制视口大小，决定屏幕上显示图象的区域。\n光栅化 光栅化是将一个图元转变为一个二维图象（其实只是布满平面，没有真正的替换帧缓存区）的过程。二维图象上每个点都包含了颜色、深度和纹理数据。将该点和相关信息叫做一个片元（fragment）。（yuyu注：这就是片元和像素之间的关键区别，虽然两者的直观印象都是的像素，但是片元比像素多了许多信息，在光栅化中纹理映射之后图元信息转化为了像素）在这个阶段，对象素绘制和位图进行操作需要用到当前栅格位置（用glRasterPos*()定义）。正如上面讨论的，三种图元的光栅化方法是不同的，另外，象素块和位图也需要光栅化。\na）图元\n采用glPointSize(), glLineWidth(), glLineStipple()和 glPolygonStipple()函数可以选择图元的光栅化维数和模式。另外，还可以用glCullFace(), glFrontFace()和glPolygonMode()控制多边形正反面不同的光栅化效果。\nb）象素\n有几个函数实现象素保存和转换。函数glPixelStore*()用于内存中的象素是如何保存的。glPixelTransfer*() and glPixelMap*()用于象素在写入帧缓冲区前是如何处理的。glDrawPixels()定义了一个象素矩形。用glPixelZoom()实现象素的缩放。\nc）位图\n位图是具有特定片元模式的0和1的矩形。每个片元有相同的相关数据。可以用glBitmap()定义。\nd）纹理存储\n纹理贴图是将指定的部分纹理图象映射到每个图元上。每个片元（fragment）具有的纹理坐标属性，该坐标与纹理图象坐标对应，得到纹理图象该位置的颜色值来修改片元的RGBA颜色，从而完成这个映射过程。用glTexImage2D()或glTexImage1D()来定义纹理图象。glTexParameter*()和glTexEnv*()来控制纹理如何解释和应用到一个片元上。\ne)雾\n已经光栅化的片元具有纹理贴图修正后颜色，可以采用融合因子再融合雾颜色，该融合因子大小根据视点和片元间的距离来定。用glFog*()指定雾化颜色和融合因子。\n*阶段3. 片元-\u0026gt;像素*\nOpenGL允许光栅化生成一个片元，只要该片元通过一系列检测就可以修改帧缓冲区中对应象素。如果它通过测试，片元数据可以直接替换帧缓冲区中的已有值，或者和已有值合并，这取决于设置的模式。\n1）象素所有权（ownership）检测\n第一个测试是判断在帧缓冲区中的象素所对应的某个片元是否属于当前OpenGL上下文。如果属于，片元进行下一个测试。如果不属于，窗口系统决定是否忽略该片元，或者是否进行下一步片元操作。\n2）裁剪检测\n用glScissor()函数，可以定义一个任意屏幕校准矩形，在该矩形外的片元将被忽略。\n3）Alpha检测\nAlpha测试只能在RGBA模式下进行，如果片元的alpha值超出一个固定参照值，片元将被忽略，这个比较函数可以用glAlphaFunc()实现并设定参考值。\n4）模版检测\n当模版缓冲区的值超出一个参照值，模版测试将有条件的忽略该片元。这个比较函数和固定值可以用glStencilFunc()实现。不论图元通过或没有通过模版测试，模版缓冲区中的值会根据glStencilOp()函数进行修改。\n5）深度检测\n当深度缓冲区的值与参照值的比较失败，深度测试忽略该片元。GlDepthFuc()用来执行这个比较命令。如果模版启用，深度比较的结果会影响模版缓冲区值的更新。\n6）融合\n融合合并了一个片元R、G、B和A值和存储在帧缓冲区对应位置的这些值。融合只能在RGBA模式下实现，它的实现需要片元的alpha值和对应当前存储象素，还需要RGB值。用glBendFun()控制，可以修改融合因子的源和目标。\n7）抖动\n如果启动抖动，片元的颜色或者颜色索引采用抖动算法。这个算法只需要片元的颜色值和它的x和y坐标。\n8）逻辑操作\n最后，在片元和帧缓冲区对应值之间要进行一个逻辑操作，结果将替换当前帧缓冲区的值。用glLogicOp定义想要的逻辑操作。这个逻辑操作只能在颜色索引模式下运行，而不能在RGBA模式运行。\n*象素*\n在OpenGL流水线的上个阶段，片元转换为帧缓冲区中的象素。帧缓冲区实际上是一组逻辑缓冲区——包括颜色缓冲区、深度缓冲区、模版缓冲区和累积缓冲区。颜色缓冲区包括左、前右、后左、后右和一些辅助缓存值（auxiliary buffers）。可以直接从中读取或者复制。对于OpenGL不同上下文，这些缓冲区可能不全\n1）帧缓冲区操作\n用glDrawBuffer为绘图选择一个颜色缓冲区。另外在预片元化（per-fragment）操作后，可以用四个不同函数保留写入这些逻辑缓冲区的操作，glIndexMask(), glColorMask(), glDepthMask(), and glStencilMask()。glAccum()对累积缓冲区进行操作。最后glClearColor(), glClearIndex(), glClearDepth(), glClearStencil()和glClearAccum().对不同缓冲区中指定相对应的颜色值、颜色索引值、深度值、模板值和累积值。\n2)读取和复制象素\n用glReadPixel()从帧缓冲区中把象素读到内存中，进行各种操作，保存处理结果。另外，可以用glCopyPixel()从帧缓冲区中复制一块象素到另一个帧混存。glReadBuffer()可以读取和复制颜色缓冲区中的象素。\n转载： https://blog.csdn.net/u014800094/article/details/53035889\n","description":"","id":37,"section":"posts","tags":["顶点、 图元、片元、像素"],"title":"顶点、 图元、片元、像素的含义","uri":"https://popo-blog.vercel.app/posts/%E9%A1%B6%E7%82%B9-%E5%9B%BE%E5%85%83%E7%89%87%E5%85%83%E5%83%8F%E7%B4%A0%E7%9A%84%E5%90%AB%E4%B9%89/"},{"content":"题目描述：\nchar szNum[]=\u0026ldquo;123456789\u0026rdquo;;\nint n=(short)(szNum+4)- (short)(szNum);\n问n = ？\n答案大家可以编程实现，n=1028。就这题来说，无论是小端还是大端 都是1028。\n看你的系统是小端还是大端可以用下面这个函数测试：\n//如果字节序为big-endian，返回true;\n//反之为 little-endian，返回false\nbool IsBig_Endian()\n{\nunsigned short test = 0x1234;\nif(( (unsigned char) \u0026amp;test ) == 0x12)\nreturn TRUE;\nelse\nreturn FALSE;\n}//IsBig_Endian()\n(short)(szNum+4) 这句话 首先是将szNum + 4 这个字符型地址 强制转换成short型地址，因为地址都是4个字节存储的，所以值不会变。也就是说，这个地址由指向字符的地址变成了指向short型变量的地址了。而这个地址值没有变。那么这个区别在哪里呢？\n因为地址指向的都是相同的地方，那么区别就在于取值了。\n如果是小端，那么计算机存储的是高位在高地址，低位在低地址，而short型是两个字节的变量。所以(short*)(szNum+4) 这个指向的值是低位，它只指了一个字节，而short有两个字节，而第二个字节就是这个地址的下一个地址所指向的值，这个值就是高位，例如问题里，szNum+4 指向的是字符‘5’，这个只是一个字节，它代表的是低位，而下一个字节自然就是字符‘6’，它代表的是高位，所以*(short*)(szNum+4)取出来的值就是0x36 35 ，这里因为字符’5‘的十六进制为35 字符‘6’的十六进制为36 所以取出的即为此值。\n同理取*(short*)(szNum) 也是这个原理，取‘1’， ‘2’ 两个字节，值为0x32 31 ，结果即为0x36 35 - 0x32 31 = 1028\n如果是大端，就只是将高低位转换一下，和小端类似，小端对计算机易于处理，而大端符合人类正常思维。\n————————————————\n版权声明：本文为CSDN博主「娜一笑最倾城」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/ljd4305/article/details/8929345\n","description":"","id":38,"section":"posts","tags":["关于一个指针取值的问题"],"title":"关于一个指针取值的问题","uri":"https://popo-blog.vercel.app/posts/%E5%85%B3%E4%BA%8E%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E5%8F%96%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/"},{"content":"字节、字、位、比特之间的关系是： 1位=1比特；1字=2字节；1字节=8位；1字=16位。\n位 位是计算机存储的最小单位，简记为b，也称为比特（bit）计算机中用二进制中的0和1来表示数据，一个0或1就代表一位。位数通常指计算机中一次能处理的数据大小；\n比特 比特（bit）是由英文BIT音译而来，比特同时也是二进制数字中的位，是信息量的度量单位，为信息量的最小单位；\n字节 字节，英文Byte，是计算机用于计量存储容量的一种计量单位，通常情况下一字节等于八位，字节同时也在一些计算机编程语言中表示数据类型和语言字符，在现代计算机中，一个字节等于八位；\n字 字是表示计算机自然数据单位的术语，在某个特定计算机中，字是其用来一次性处理事务的一个固定长度的位（bit）组，在现代计算机中，一个字等于两个字节。\n扩展资料：\n计算机中的存储单位有：bit、B、KB、MB、GB、TB、PB、EB、ZB、YB、BB、NB、DB等。\n这些单位中最小的单位是——位 bit (比特)(Binary Digits)，一个位存放一位二进制数，即 0 或 1，它是计算机存储中最小的存储单位。\n其他的单位相互之间的换算关系入下：\n1 Byte（B）= 8 bit；\n1 Kilo Byte（KB） = 1024B；\n1 Mega Byte（MB） = 1024 KB；\n1 Giga Byte （GB）= 1024 MB；\n1 Tera Byte（TB）= 1024 GB；\n1 Peta Byte（PB） = 1024 TB；\n1 Exa Byte（EB） = 1024 PB；\n1 Zetta Byte（ZB） = 1024 EB；\n1Yotta Byte（YB）= 1024 ZB；\n1 Bronto Byte（BB） = 1024 YB；\n1 Nona Byte（NB）=1024 BB；\n1 Dogga Byte（DB）=1024 NB；\n1 Corydon Byte（CB）=1024DB；\n1 Xero Byte （XB）=1024CB；\n","description":"","id":39,"section":"posts","tags":["字节、字、位、比特"],"title":"字节、字、位、比特之间的关系","uri":"https://popo-blog.vercel.app/posts/%E5%AD%97%E8%8A%82%E5%AD%97%E4%BD%8D%E6%AF%94%E7%89%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"content":" 本地安装好git； 桌面右键 Git Bash Here 打开git命令行； ssh-keygen -t rsa -C \u0026ldquo;nideyouxiang@xxx.com\u0026rdquo; （全部按enter）； cd ~/.ssh （如果没有执行第三步，则不会有这个文件夹）； cat id_rsa.pub 在命令行打开这个文件，会直接输出密钥； 复制，打开github ，点自己头像 \u0026raquo; settings \u0026raquo; SSH and GPG keys \u0026raquo;New SSH key titile 随便写。 key里 粘贴第六步的内容；完成。 ","description":"","id":41,"section":"posts","tags":["git"],"title":"git 配置 私钥","uri":"https://popo-blog.vercel.app/posts/%E9%85%8D%E7%BD%AEgit%E7%A7%81%E9%92%A5/"},{"content":"数据结构笔记 顺序栈和顺序队列使用动态数组实现\n以下不是C++中stack的实现\n顺序栈 特点：后进先出，先进后出\n栈可以用数组或者链表写\n开始时，栈顶Top=-1\n顺序栈操作 Push（栈顶添加元素）\nTop（返回当前栈顶数据）\nPop （删除栈顶数据）\nIsEmpty（检查栈是否为空）\n数组实现 实现自动扩大数组大小 模板类实现和声明要写在一起 1 2 3 4 5 6 7 8 9 10 template\u0026lt;class T\u0026gt; void ChangeSize1D(T* \u0026amp;a,const int oldSize, const int newSize) { if(newSize\u0026lt;0) throw \u0026#34;newSize must be \u0026gt;=0\u0026#34;; T* temp =new T[newSize]; int number = min(oldSize,newSize); std::copy(a,a+number,temp); delete[] a; a=temp; } 顺序队列（Queue） 特点：先进先出，后进后出\n队列操作 Push（队尾添加元素） Pop （队首删除元素） Front（返回当前队首数据） Rear（返回当前队尾数据） IsEmpty（检查队列是否为空） 实现回绕（利用数组删除后留下的空间） rear=front front++ 如果front=rear表示队列满了，要自动扩大数组大小 链表 链表：1.数据域 2.链接域 数组缺点：插入数据时慢，需要向后移动，删除数据时，需要向前移动。 链表可以弥补这些缺点。 树 数组缺点：插入数据，数据要移动。 数组优点：二分查找 链表缺点：无法二分查找 链表优点: 插入删除数据快 树 = 数组的优点 + 链表的优点 ","description":"","id":42,"section":"posts","tags":["数据结构"],"title":"数据结构学习","uri":"https://popo-blog.vercel.app/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"},{"content":"创造字典 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # jsonDictList 数据 # schema 设置作为搜索依据的内容 def createSearch(jsonDictList): schema = Schema( title=TEXT(stored=True, analyzer=ChineseAnalyzer()), url = ID(stored=True), ) # # 存储schema信息至indexdir目录 if not os.path.exists(indexdir): os.mkdir(indexdir) ix = create_in(indexdir, schema) # # # 按照schema定义信息，增加需要建立索引的文档 writer = ix.writer() for jsonDict in jsonDictList: writer.add_document(title=jsonDict[\u0026#34;title\u0026#34;],url = jsonDict[\u0026#34;url\u0026#34;]) writer.commit() 搜索内容 1 2 3 4 5 6 7 8 9 10 11 def searchByTitle(title): ix = index.open_dir(indexdir) # 创建一个检索器 searcher = ix.searcher() # 检索 results = searcher.find(\u0026#34;title\u0026#34;, title,limit=None) resultsList = [] print(\u0026#39;一共发现%d个稿件。\u0026#39; % len(results)) for res in results: resultsList.append(res.fields()) return resultsList 更新内容 1 2 3 4 5 6 7 #jsonDictList 更新的数据 def updateSearch(jsonDictList): ix = index.open_dir(indexdir) writer = ix.writer() for jsonDict in jsonDictList: writer.add_document(title=jsonDict[\u0026#34;title\u0026#34;],url = jsonDict[\u0026#34;url\u0026#34;]) writer.commit() ","description":"","id":43,"section":"posts","tags":["whoosh"],"title":"whoosh实现搜索功能","uri":"https://popo-blog.vercel.app/posts/whoosh%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2/"},{"content":"1、使用sm.ms官网进行注册， 注册账号\n2、登录后进入面板界面 dashborad\n3、获取token 获取token\n4、Typora配置图床 文件-偏好设置\n在第5步的时候将文件配置为\n1 2 3 4 5 6 7 8 9 { \u0026#34;picBed\u0026#34;: { \u0026#34;current\u0026#34;: \u0026#34;smms\u0026#34;, \u0026#34;smms\u0026#34;: { \u0026#34;token\u0026#34;: \u0026#34;这里是你的 SM.MS 账号的 API Token\u0026#34; } }, \u0026#34;picgoPlugins\u0026#34;: {} } 5、复制图片即可返回文件的url地址，也可在官网中查看到已上传的图片 已上传的图片\n","description":"","id":44,"section":"posts","tags":[" sm.ms"],"title":"sm.ms作为图床","uri":"https://popo-blog.vercel.app/posts/sm.ms%E5%81%9A%E5%9B%BE%E5%BA%8A/"},{"content":"1. 注册一个Github账号 首先你需要一个github账号，如果没有的话，先注册。\ngithub官网地址： https://github.com/\n注册过程省略，因为这是保姆都不管的事情。\n友情提示：可能在注册过程中会出现 “Unable to verify your captcha response… …”，一直不能正常注册。\n网上有各种解决方案：换浏览器、换电脑… …\n2. 配置Github 2.1 创建一个新仓库，用于存放图片。 填写仓库名称和描述，且仓库必须是public的，否则存储的图片不能正常访问。\n2.2 生成一个token，用于picGo访问github 选择左侧菜单的Developer settings\n之后选择左侧Personal access tokens，再点击Generate new token\n填写Note，勾选repo.\n注意，生成的token只会在这里显示一次，所以记得单独保存下来哦。\n至此，Github的配置完成。\n3. 下载picGo，并进行配置 3.1 下载 网络不好的情况下，PicGo下载可能会多次失败，所以我把下载好的应用放在百度网盘了。\n大家按需取用。\n网盘地址：https://pan.baidu.com/s/1LvkzLJyZcjpflK2Evq3X9A 提取码：s6x7\n下载完成，双击启动安装即可。\n如果安装成功，picGo不能正常使用，则可以用兼容模式启动。【此问题因电脑而异，也是我在配置过程中踩过的坑。】\n3.2 配置 仓库名：[github用户名]/[第一步新建的仓库名称]\n分支：默认master，从2020.10.01开始，github的默认分支名变更为main\n设定token：第一步创建的token\n指定存储路径：可填可不填，如果填写了，图片就会存储在img文件夹下\n设定自定义域名：https://cdn.jsdelivr.net/gh/[github用户名]/[仓库名]@main，注意，此处的分支一定要填写@main，否则默认使用master分支。而现在github创建的默认分支名为main，如果不指定，则会出现图片不能上传的情况。【踩坑两小时】\n至此，github+picGo的配置完成，可以在上传区进行图片上传了。\n3.3 补充几点 1.原本github的自定义域名应该是：[https://raw.githubusercontent.com/username]/[仓库名]\n但是使用这种方式访问图片巨慢，所以教程中使用了jsdelivr作为cdn加速。改变域名即可，不需要任何其他配置。\n2.配置完成，可能出现不能上传的情况，请大家耐心检查，也许某一步的配置出现了问题，就像检查bug一样耐心、细心。想象一下图床搭建成功后，写起文章来的丝滑感，是不是又有动力了？\n4. PicGo集成Typora 使用MarkDown语法写文章，我使用的编辑器是typora，一款超级好用的编辑器。在一个编辑框内，编辑完成后，可以马上显示MarkDown语法效果。\n举个栗子：\n并且typora可以和picGo联合在一起使用，当你在编辑器中插入、粘贴图片时，typora+picGo的组合方式，可以自动把图片上传至github保存。\n4.1 下载安装 Typora新版本是收费的，所以建议大家使用旧版本就可以了，完全能满足写作需求。\n旧版本安装包和picGo放在一起了（下载地址见上文），大家按需取用即可。\n下载完成后正常步骤安装即可。\n4.2 配置 在typora顶部菜单界面，选择“文件” - \u0026gt; “偏好设置”，设置图片存储方式。\n选择图片存储方式：上传图片。\n上传服务：PicGo(app)\nPicGo路径：picGo安装的地址\n设置完成，点击“验证图片上传”，提示上传成功，即代表配置成功。\n注意一点，typora图片验证中的端口，需要与picGo中的server设置内的端口一致，否则typora中不能正常上传。\n4.3 picGo监听端口设置 选择“PicGo设置”–\u0026gt;“设置server”\n【此处有坑】如果监听端口不是36677，则需要修改为36677。否则会出现picGo能正常上传 图片，而typora上传图片失败的情况。\n最后，在苹果电脑中可以使用Typora+Ipic+Github的方式，有兴趣的话可以自行尝试\n总结：github+picGo+typora他们三个是好基友。\n","description":"","id":45,"section":"posts","tags":["Github","picGo"],"title":"使用Github+picGo搭建图床","uri":"https://popo-blog.vercel.app/posts/github/%E4%BD%BF%E7%94%A8github+picgo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"},{"content":"一、设置root密码 先选择从浏览器打开ssh连接服务器\nLINUX | 谷歌云开启SSH及设置root密码 切换到root账号 sudo -i 设置root密码 passwd 然后会要求输入新密码，然后再重复一次密码，输入密码的时候不会显示出来，所以直接输入密码，然后回车，再然后重复输入密码回车\n二、开启SSH权限 ①方法一\n修改SSH配置文件/etc/ssh/sshd_config\nvi /etc/ssh/sshd_config\n然后再输”i”进入编辑模式\ni\n找到以下内容并修改\nPermitRootLogin yes //默认为no，需要开启root用户访问改为yes\nPasswordAuthentication yes //默认为no，改为yes开启密码登陆\nLINUX | 谷歌云开启SSH及设置root密码 – Vedio Talk - VLOG、科技、生活、乐分享\n修改完成后，再下按 esc 键，然后再输入\n:wq\nLINUX | 谷歌云开启SSH及设置root密码 – Vedio Talk - VLOG、科技、生活、乐分享\n重启SSH服务\nservice sshd restart\n②方法二\nCentOS和Debian通用，输入以下两条命令 sed -i \u0026#39;s/PermitRootLogin no/PermitRootLogin yes/g\u0026#39; /etc/ssh/sshd_config sed -i \u0026#39;s/PasswordAuthentication no/PasswordAuthentication yes/g\u0026#39; /etc/ssh/sshd_config Ubuntu系统，输入以下两条命令 sed -i \u0026#39;s/#PermitRootLogin prohibit-password/PermitRootLogin yes/g\u0026#39; /etc/ssh/sshd_config sed -i \u0026#39;s/PasswordAuthentication no/PasswordAuthentication yes/g\u0026#39; /etc/ssh/sshd_config 重启服务器 reboot ","description":"","id":46,"section":"posts","tags":["谷歌云"],"title":"谷歌云开启SSH及设置root密码","uri":"https://popo-blog.vercel.app/posts/%E8%B0%B7%E6%AD%8C%E4%BA%91%E5%BC%80%E5%90%AFssh%E5%8F%8A%E8%AE%BE%E7%BD%AEroot%E5%AF%86%E7%A0%81/"},{"content":" 安装Aria2 1 wget -N https://git.io/aria2.sh \u0026amp;\u0026amp; chmod +x aria2.sh \u0026amp;\u0026amp; bash aria2.sh 系统要求：CentOS 6+ / Debian 6+ / Ubuntu 14.04+。\n输入“1”开始安装，完成后记录下图的信息：\n安装AriaNg 手机端安装包：点击下载 ；\n依次点击“AriaNg设置”——“RPC”，\n在Aria2 RPC地址栏输入之前记录的Aria2配置信息的地址，在Aria2 RPC密钥栏中输入之前记录的Aria2配置信息的密钥，然后点击“Reload Page”即可远程连接Aria2。\nWindows系统安装包：点击下载；\n设置方法和手机端一样.\n安装可道云\n安装宝塔\n1 yum install -y wget \u0026amp;\u0026amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh \u0026amp;\u0026amp; sh install.sh 其他VPS系统脚本命令可以到宝塔官方网站查询，安装完成后登录宝塔面板，安装运行环境，这里需要注意要安装PHP7.2，否则无法安装可道云。\n然后安装宝塔一键部署源码\n然后一键部署可道云，域名栏输入VPS的ip即可：\n点击“提交”开始部署，然后访问站点并设置密码：\n更改Aria2的默认下载目录；\n由于AriaNg无法管理所下载的文件，比如对文件进行打开或删除的操作，所以需要把Aria2的默认下载目录修改到可道云中，在可道云的【我的文档】建一个名为【download】的文件夹：\n右键点击文件夹download，打开属性，记录下完整的路径.\n再次执行\n1 wget -N https://git.io/aria2.sh \u0026amp;\u0026amp; chmod +x aria2.sh \u0026amp;\u0026amp; bash aria2.sh 输入“7”，再输入“3”，然后粘贴上面的路径就可以修改Aria2的默认下载目录：\n记得放行6800端口；因为安装了宝塔面板，会屏蔽部分端口，包括6800端口，导致Aria2无法连接，所以需要通过宝塔面板放行6800端口，操作方法如下图：\n","description":"","id":47,"section":"posts","tags":["aria2"],"title":"Aria2 VPS下载器","uri":"https://popo-blog.vercel.app/posts/aria2-vps%E4%B8%8B%E8%BD%BD%E5%99%A8/"},{"content":"搭建网盘过程 1.安装docker 通过yum源安装docker 1 sudo yum -y install docker 启动docker 1 sudo systemctl start docker 开机自启 1 sudo systemctl enable docker 2.获取nextcloud镜像, 完成网盘搭建 1 docker run -d -p 8080:80 nextcloud ","description":"","id":48,"section":"posts","tags":["nextcloud"],"title":"nextcloud搭建","uri":"https://popo-blog.vercel.app/posts/nextcloud-%E6%90%AD%E5%BB%BA/"},{"content":"aria2 简单使用 整体方案是 独立的 aria2 程序 + aria2-conf + Chrome 插件\naria2 在 https://github.com/aria2/aria2/releases 下载最新的 Release\naria2-conf 使用 https://github.com/ttttmr/aria2-conf 的配置文件，下载 zip 包即可（或者 git clone）\n配置 把下好的压缩包解压，存一起，重命名一下\naria2-1.34.0-win-64bit-build1` -\u0026gt; `bin aria2-conf-master` -\u0026gt; `conf 先给 aria2 的 bin 配上环境变量，也方便命令行里用\n然后配置一下 conf/aria2.conf 文件就可以用了\n主要更改如下\n#设置密码 18 rpc-secret = xxxxxx ... 89 dir = D:\\Download #填默认下载目录 双击 HideRun.vbs 就可以启动 aria2 了，需要自启的话可以将快捷方式发送到开始菜单 startup 里\nstartup 在这里 %APPDATA%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\n启动双击 start.bat ，后台运行双击 HideRun.vbs ，关闭双击 stop.bat ，重启双击 restart.bat\nChrome 联动 Chrome 插件用的是 Aria2 for Chrome\n一共有 2 个要填密码的地方\n一个是在插件设置填 RPC 地址\nhttp://token:xxxx@localhost:6800/jsonrpc xxx 是你设置的密码\n一个是 ariang 的 RPC 配置\n","description":"","id":49,"section":"posts","tags":["aria2"],"title":"aria2 简单使用","uri":"https://popo-blog.vercel.app/posts/aria2-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"content":"Mac安装Homebrew 国内安装(可用)： /bin/zsh -c \u0026#34;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)\u0026#34; 以上方法来自：https://zhuanlan.zhihu.com/p/111014448\n","description":"","id":50,"section":"posts","tags":["Mac"],"title":"Mac 安装homebrew","uri":"https://popo-blog.vercel.app/posts/mac/mac-%E5%AE%89%E8%A3%85homebrew/"},{"content":"Docker删除镜像和容器 查看运行的容器 1 docker ps 查看已经退出的容器 1 docker ps -a 删除镜像 1 docker rmi -f 镜像id 删除容器 1 docker rm -f 容器id ","description":"","id":51,"section":"posts","tags":["Docker"],"title":"Docker删除镜像和容器","uri":"https://popo-blog.vercel.app/posts/docker%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F%E5%92%8C%E5%AE%B9%E5%99%A8/"},{"content":"剑指office（一）二维数组查找\n剑指office（二）替换空格\n剑指office（三）从尾到头打印链表\n剑指office（四）重建二叉树\n剑指office（五）用两个栈实现队列\n剑指office（六）用两个栈实现队列\n剑指office（七）用两个栈实现队列\n剑指office（八）跳台阶\n剑指office（九）跳台阶扩展问题\n剑指office（十）矩形覆盖\n剑指office（十一）二进制中1的个数\n剑指office（十二）数值的整数次方\n剑指office（十三）调整数组顺序使奇数位于偶数前面\n剑指office（十四）链表中倒数第k个结点\n剑指office（十五）反转链表\n剑指office（十六）合并两个排序的链表\n剑指office（十七）树的子结构\n剑指office（十八）二叉树的镜像\n剑指office（十九）顺时针打印矩阵\n剑指office（二十）包含min函数的栈\n剑指office（二十一）栈的压入、弹出序列\n剑指office（二十二）从上往下打印二叉树\n剑指office（二十三）二叉树搜索树的后序遍历序列\n剑指office（二十四）二叉树中和为某一值的路径\n剑指office（二十五）复杂链表的复制\n剑指office（二十六）二叉树搜索树与双向链表\n","description":"剑指office","id":52,"section":"learn","tags":["剑指office"],"title":"剑指office","uri":"https://popo-blog.vercel.app/learn/%E5%89%91%E6%8C%87offer%E7%9B%AE%E5%BD%95/"},{"content":"剑指office（一）二维数组查找\n剑指office（二）替换空格\n剑指office（三）从尾到头打印链表\n剑指office（四）重建二叉树\n剑指office（五）用两个栈实现队列\n剑指office（六）用两个栈实现队列\n剑指office（七）用两个栈实现队列\n剑指office（八）跳台阶\n剑指office（九）跳台阶扩展问题\n剑指office（十）矩形覆盖\n剑指office（十一）二进制中1的个数\n剑指office（十二）数值的整数次方\n剑指office（十三）调整数组顺序使奇数位于偶数前面\n剑指office（十四）链表中倒数第k个结点\n剑指office（十五）反转链表\n剑指office（十六）合并两个排序的链表\n剑指office（十七）树的子结构\n剑指office（十八）二叉树的镜像\n剑指office（十九）顺时针打印矩阵\n剑指office（二十）包含min函数的栈\n剑指office（二十一）栈的压入、弹出序列\n剑指office（二十二）从上往下打印二叉树\n剑指office（二十三）二叉树搜索树的后序遍历序列\n剑指office（二十四）二叉树中和为某一值的路径\n剑指office（二十五）复杂链表的复制\n剑指office（二十六）二叉树搜索树与双向链表\n","description":"剑指office","id":53,"section":"posts","tags":["剑指office"],"title":"剑指office","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer%E7%9B%AE%E5%BD%95/"},{"content":"Git Flow 的正确使用姿势 Git Flow 的概念 在使用Git的过程中如果没有清晰流程和规划，否则,每个人都提交一堆杂乱无章的commit,项目很快就会变得难以协调和维护。\nGit版本管理同样需要一个清晰的流程和规范。\nVincent Driessen 为了解决这个问题提出了 A Successful Git Branching Model\n以下是基于Vincent Driessen提出的Git Flow 流程图\nGit Flow 的常用分支 Production 分支 也就是我们经常使用的Master分支，这个分支最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支直接修改\nDevelop 分支 这个分支是我们是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支\nFeature 分支 这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release\nRelease分支 当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支\nHotfix分支 当我们在Production发现新的Bug时候，我们需要创建一个Hotfix, 完成Hotfix后，我们合并回Master和Develop分支，所以Hotfix的改动会进入下一个Release。\nGit Flow 如何使用 Master/Devlop 分支 所有在Master分支上的Commit应该打上Tag，一般情况下Master不存在Commit，Devlop分支基于Master分支创建。\nFeature 分支 Feature分支做完后，必须合并回Develop分支, 合并完分支后一般会删点这个Feature分支，毕竟保留下来意义也不大。\nRelease 分支 Release分支基于Develop分支创建，打完Release分支之后，我们可以在这个Release分支上测试，修改Bug等。同时，其它开发人员可以基于Develop分支新建Feature (记住：一旦打了Release分支之后不要从Develop分支上合并新的改动到Release分支)发布Release分支时，合并Release到Master和Develop， 同时在Master分支上打个Tag记住Release版本号，然后可以删除Release分支了。\nHotfix 分支 hotfix分支基于Master分支创建，开发完后需要合并回Master和Develop分支，同时在Master上打一个tag。\nGit Flow 命令示例 创建 Devlop 1 2 git branch develop git push -u origin develop 开始 Feature 1 2 3 4 5 6 7 8 9 # 通过develop新建feaeure分支 git checkout -b feature develop # 或者, 推送至远程服务器: git push -u origin feature # 修改md文件 git status git add . git commit 完成 Feature 1 2 3 4 5 6 7 8 9 10 11 12 13 git pull origin develop git checkout develop #--no-ff：不使用fast-forward方式合并，保留分支的commit历史 #--squash：使用squash方式合并，把多次分支commit历史压缩为一次 git merge --no-ff feature git push origin develop git branch -d some-feature # 如果需要删除远程feature分支: git push origin --delete feature 开始 Release 1 git checkout -b release-0.1.0 develop 完成 Release 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 git checkout master git merge --no-ff release-0.1.0 git push git checkout develop git merge --no-ff release-0.1.0 git push git branch -d release-0.1.0 git push origin --delete release-0.1.0 # 合并master/devlop分支之后，打上tag git tag -a v0.1.0 master git push --tags 开始 Hotfix 1 git checkout -b hotfix-0.1.1 master 完成 Hotfix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 git checkout master git merge --no-ff hotfix-0.1.1 git push git checkout develop git merge --no-ff hotfix-0.1.1 git push git branch -d hotfix-0.1.1 git push origin --delete hotfix-0.1.1 git tag -a v0.1.1 master git push --tags 使用建议 如果你的代码没有清晰流程和规划，那么强烈推荐使用Vincent Driessen 提出的GIt flow让你的代码管理骚起来。\n结尾 本站文章图片等等来源于网络,仅作为学习之用,版权归原作者所有.如果侵犯了您的权益,请来信告知,我会尽快删除.\n","description":"","id":54,"section":"posts","tags":["git"],"title":"Git Flow 的正确使用姿势","uri":"https://popo-blog.vercel.app/posts/github/git-flow-%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/"},{"content":"删除 .DS_Store 如果你的项目中还没有自动生成的 .DS_Store 文件，那么直接将 .DS_Store 加入到 .gitignore 文件就可以了。如果你的项目中已经存在 .DS_Store 文件，那就需要先从项目中将其删除，再将它加入到 .gitignore。如下：\n删除项目中的所有.DS_Store。这会跳过不在项目中的 .DS_Store find . -name .DS_Store -print0 | xargs -0 git rm -f \u0026ndash;ignore-unmatch\n将 .DS_Store 加入到 .gitignore\necho .DS_Store \u0026raquo; ~/.gitignore\n更新项目 git add \u0026ndash;all\ngit commit -m \u0026lsquo;.DS_Store banished!\u0026rsquo;\n如果你只需要删除磁盘上的 .DS_Store，可以使用下面的命令来删除当前目录及其子目录下的所有.DS_Store 文件:\n1 find . -name \u0026#39;*.DS_Store\u0026#39; -type f -delete 禁用或启用自动生成\n禁止.DS_store生成：\n1 defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE 恢复.DS_store生成：恢复.DS_store生成：\n1 defaults delete com.apple.desktopservices DSDontWriteNetworkStores ","description":"","id":55,"section":"posts","tags":["Mac"],"title":"Mac中删除.DS_Store","uri":"https://popo-blog.vercel.app/posts/mac/mac%E4%B8%AD%E5%88%A0%E9%99%A4.ds_store/"},{"content":"入参 参数 描述 是否必传 默认值 gitee-username Gitee用户名 是 - gitee-password Gitee密码 是 - gitee-repo Gitee仓库（严格区分大小写） 是 - branch 要部署的分支 否 master directory 要部署的分支上的目录 否 '' https 是否强制使用https 否 true 示例 在GitHub的仓库创建 .github/workflows/ 文件夹并且创建一个**sync.yml** 文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 name: Sync on: push: branches: [ giteePage ] jobs: build: runs-on: ubuntu-latest steps: - name: Sync to Gitee uses: wearerequired/git-mirror-action@master env: # 注意在 Settings-\u0026gt;Secrets 配置 PRIVATE SSH_PRIVATE_KEY: ${{ secrets.PRIVATE }} with: # 注意替换为你的 GitHub 源仓库地址 source-repo: \u0026#34;git@github.com:username/username.github.io.git\u0026#34; # 注意替换为你的 Gitee 目标仓库地址 destination-repo: \u0026#34;git@gitee.com:username/username.git\u0026#34; - name: Build Gitee Pages uses: yanglbme/gitee-pages-action@master with: # 注意替换为你的 Gitee 用户名 gitee-username: username # 注意在 Settings-\u0026gt;Secrets 配置 PASSWORD gitee-password: ${{ secrets.PASSWORD }} # 注意替换为你的 Gitee 仓库 gitee-repo: username/username # 提交到gitee的github仓库的分支 branch: giteePage 先使用 wearerequired/git-mirror-action 将 GitHub 仓库同步到 Gitee 仓库，再使用 yanglbme/gitee-pages-action 实现 Gitee Pages 的自动部署。\n运行需要在 GitHub 项目的 Settings -\u0026gt; Secrets 路径下配置好 **PRIVATE **以及 PASSWORD 两个密钥。其中：\n**PRIVATE **: 存放你的 id_rsa 私钥。PASSWORD: 存放你的 Gitee 账户密码。\n1. 配置PRIVATE 生成SSH密钥\n1 ssh-keygen -t rsa -C \u0026#34;name\u0026#34; \u0026ldquo;name\u0026quot;是任意指定的标识\n获取公钥 1 cat ~/.ssh/id_rsa.pub 绑定Gitee 复制公钥，通过仓库主页个人图像下拉设置-\u0026gt;SSH公钥添加公钥\n测试\n打开终端输入：\n1 ssh -T git@gitee.com 显示如下图则成功\n绑定Github\n复制公钥，通过仓库主页个人图像下拉Setting-\u0026gt;SSH and GPG keys添加公钥\n测试\n打开终端输入：\n1 ssh -T git@github.com 显示如下图则成功\n配置\n获取私钥\n1 cat ~/.ssh/id_rsa 复制私钥，在仓库的Setting-\u0026gt;Secrets路径下命名PRIVATE，Value添加私钥（记得复制全部内容）\n2. 配置PASSWORD 在仓库的Setting-\u0026gt;Secrets路径下命名PASSWORD，Value添加**Gitee**账户密码。\n如果一切配置正常，并成功触发 Gitee Pages Action ，我们可能会收到一封来自 Gitee 的告警邮件/站内信。放心，这是 GitHub Action 程序帮我们登录到 Gitee 官网，并为我们点击了项目的部署按钮。\nFAQ 问题 1：遇到短信验证码导致无法自动部署，怎么解决？ 因为 Gitee Pages Action 使用的是 GitHub 自家的服务器（美国），在这种情况下，当 Action 自动\t帮我们登录 Gitee 的时候，会触发 Gitee 帐号异常登录告警，提示用户在非正常的 IP 地址登陆\tGitee，需要输入验证码。\n解决方案是：关注「码云 Gitee」 微信公众号，绑定个人微信到码云帐号。这样 Action 在登录的过程中，Gitee 就不会下发短信验证码，而是通过「码云 Gitee」公众号给我们发送一个登录通知，Action 就能成功登录了。\n问题 2：报 deploy error occurred, message: \u0026lsquo;NoneType\u0026rsquo; object has no attribute \u0026lsquo;group\u0026rsquo; 错误，怎么办？ 报了这个错误，说明 Action 已经成功帮我们登录 Gitee 帐号了，但在访问 Gitee Repo 的过程中出现问题。\n这种情况，一般是 Gitee Pages Action 的参数配置错误导致，请仔细检查你的配置信息。\n注意：gitee-repo 参数严格区分大小写，请准确填写，比如 doocs/advanced-java，当你写成 doocs/Advanced-java 的时候，是访问不到的，不信你可以试试访问：https://gitee.com/Doocs/Advanced-java\n","description":"","id":56,"section":"posts","tags":["Github Action","github"],"title":"Github Action 同步gitee和github单个仓库","uri":"https://popo-blog.vercel.app/posts/github/github-action-%E5%90%8C%E6%AD%A5gitee%E5%92%8Cgithub%E5%8D%95%E4%B8%AA%E4%BB%93%E5%BA%93/"},{"content":"插入图片 使用 Markdown 编写文档或博客时，经常需要对图片的位置与尺寸进行调整。\n插入图片后，Markdown 表示图片的语法格式如下：\n![图片描述](图片链接) 调整图片位置 居左 （1）方法一：添加位置标识。\n1 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200822014538211.png#pic_left) （2）方法二：嵌入 HTML 代码。\n1 2 3 \u0026lt;div align=\u0026#34;left\u0026#34;\u0026gt; \u0026lt;img src=https://img-blog.csdnimg.cn/20200822014538211.png /\u0026gt; \u0026lt;/div\u0026gt; 居中 （1）方法一：添加位置标识。\n1 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200822014538211.png#pic_center) （2）方法二：嵌入 HTML 代码。\n1 2 3 \u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;img src=https://img-blog.csdnimg.cn/20200822014538211.png /\u0026gt; \u0026lt;/div\u0026gt; 居右 （1）方法一：添加位置标识。\n1 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200822014538211.png#pic_right) （2）方法二：嵌入 HTML 代码。\n1 2 3 \u0026lt;div align=\u0026#34;right\u0026#34;\u0026gt; \u0026lt;img src=https://img-blog.csdnimg.cn/20200822014538211.png /\u0026gt; \u0026lt;/div\u0026gt; 调整图片大小 等比缩放 相对于父级窗口 使用百分比只定义宽即可等比例缩放。注意：宽度相对于图片所在父级窗口。\n1 \u0026lt;img src=https://img-blog.csdnimg.cn/20200822014538211.png width=60% /\u0026gt; 相对于自身 非等比缩放 将图片的宽高缩小或放大为原来的指定百分比。\n固定宽高 1 \u0026lt;img src=https://img-blog.csdnimg.cn/20200822014538211.png width=200 height=100 /\u0026gt; ","description":"","id":57,"section":"posts","tags":["Markdown"],"title":"Markdown 调整图片位置与大小","uri":"https://popo-blog.vercel.app/posts/markdown/markdown-%E8%B0%83%E6%95%B4%E5%9B%BE%E7%89%87%E4%BD%8D%E7%BD%AE%E4%B8%8E%E5%A4%A7%E5%B0%8F/"},{"content":"安装软件 安装 node.js 下载地址\n安装PicGO客户端 下载地址\n在Picgo里面安装Gitee扩展插件\n安装完成后重启应用在图床设置会显示gitee\n注册Gitee账号并创建图床仓库，获取Token 自行注册账号，创建仓库，仓库记得初始化。 Gitee官网\n1 个人图片下拉栏 -\u0026gt; 设置 -\u0026gt; 私人令牌 在设置中创建私人令牌（Token）自行保存好，它只会在创建的时候显示一次，之后就不再显示，只能重新生成或者创建\n配置Picgo上的Gitee 至此Picgo搭配Gitee的图床就搭建完了\n刚快尝试上传图片吧。\n使用Typora的Picgo插件 下载 Typora 下载地址\n配置Picgo\n进入Typora设置\n该设置完成之后，直接将图片复制进Typora 的编辑区即可完成图片的上传，并且文章使用的图片Url就是图床相应的Url。\n","description":"","id":58,"section":"posts","tags":["PicGo","个人图床"],"title":"PicGo配合gtiee实现个人图床","uri":"https://popo-blog.vercel.app/posts/picgo%E9%85%8D%E5%90%88gtiee%E5%AE%9E%E7%8E%B0%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/"},{"content":"git回退到上个版本 1 git reset --hard HEAD^ 回退到前3次提交之前，以此类推，回退到n次提交之前 1 git reset --hard HEAD~3 查看commit的sha码 1 git log 1 git show dde8c25694f34acf8971f0782b1a676f39bf0a46 退到/进到 指定commit的sha码 1 git reset --hard dde8c25694f34acf8971f0782b1a676f39bf0a46 强推到远程 git push origin HEAD --force 把git add添加进去的文件撤销添加 git reset HEAD 相对路径名\n1 git reset HEAD public/uploads/ git练习地址: https://learngitbranching.js.org/?locale=en_US\n","description":"","id":59,"section":"posts","tags":["git"],"title":"git回退上一个版本","uri":"https://popo-blog.vercel.app/posts/github/git%E5%9B%9E%E9%80%80%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"content":"创建repo repo名称为\u0026lt;username\u0026gt;.github.io 设置github actions自动部署 将博客源码放到一个private repo 或者 public repo 中，\n创建一个blogSite分支。\nblogSite分支，用于存放博客源码\nmaster分支，用于存放博客网页代码\n需要获取一个personal_token或者deploy_key来获取repo的权限，这里选择personal_token的方式，这种方式更简单，后者可以自行了解。\n生成一个personal_token 点击GitHub头像在下拉栏里进入Setting-Developer -\u0026gt; Setting-Personal access\n选择 Generate new token\n在上方填入名字ACTION_ACCESS_TOKEN，并勾选repo里的所有选项，还有admin:repo_hook\n点击 Generate token 生成 token，\n并先复制保存该token（记得保存后面要用到）\n然后执行以下几步：\n1.在源码repo里新建一个blogSite分支：git checkout -b blogSite 2.在repo根目录新建嵌套的两个文件夹.github/workflows 3.在workflows里新建一个后缀为.yml的配置文件，名字自取。 4.写进去以下配置（从hugo官方文档修改而来）： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 name: github pages # 名字自取 on: push: branches: - blogSite # 这个是博客源码分支 jobs: deploy: # 任务名自取 runs-on: ubuntu-18.04\t# 在什么环境运行任务 steps: - uses: actions/checkout@v2\t# 引用actions/checkout这个action，与所在的github仓库同名 with: submodules: true # Fetch Hugo themes (true OR recursive) 获取submodule主题 fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo\t# 步骤名自取 uses: peaceiris/actions-hugo@v2\t# hugo官方提供的action，用于在任务环境中获取hugo with: hugo-version: \u0026#39;latest\u0026#39;\t# 获取最新版本的hugo # extended: true - name: Build run: hugo --minify\t# 使用hugo构建静态网页 - name: Deploy uses: peaceiris/actions-gh-pages@v3\t# 一个自动发布github pages的action with: # github_token: ${{ secrets.GITHUB_TOKEN }} 该项适用于发布到源码相同repo的情况，不能用于发布到其他repo external_repository: username/username.github.io\t# username 是你的仓库repo的名称，也是你的用户名 personal_token: ${{ secrets.ACTION_ACCESS_TOKEN }}\t# 发布到其他repo需要提供上面生成的personal access token publish_dir: ./public\t# 注意这里指的是要发布哪个文件夹的内容，而不是指发布到目的仓库的什么位置，因为hugo默认生成静态网页到public文件夹，所以这里发布public文件夹里的内容 publish_branch: master\t# 发布到哪个branch 记得修改 external_repository中的username 接下来在源码repo中添加上面的personal access token： 进入repo的Settings-Secrets一栏，选择New repository secret\n在下面填入刚才生成的token，名字注意需要与上面yml文件里XXX相同\npersonal_token: ${{ secrets.XXX }}\n这里的名称是ACTION_ACCESS_TOKEN\n添加token之后，进入github actions里点击刚才失败的任务，点击右上角Re-run jobs\n这时应该能够成功运行该任务，这说明自动部署已经开始在工作了，以后往blogSite分支push新文章时github actions会自动生成静态博客并发布到master中。\n","description":"","id":60,"section":"posts","tags":["Github Action","Hugo"],"title":"Hugo使用Github Action自动部署博客到Github Pages","uri":"https://popo-blog.vercel.app/posts/github/hugo%E4%BD%BF%E7%94%A8github-action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0github-pages/"},{"content":"配置后的效果如下: 1. 安装Unity 2.下载安装.Net Core SDK https://dotnet.microsoft.com/download/dotnet\n运行命令检查安装是否成功\n1 dotnet --version 3.下载安装Mono SDK https://www.mono-project.com/download/stable/\n运行命令检查安装是否成功\n1 mono --version 4. 安装VsCode 4.1 安装VsCode插件 1 2 3 4 5 6 7 C# C# Extensions C# FixFormat Fixed Debugger for Unity Unity Tools Unity Code Snippets Unity Snippets 4.2 VsCode 配置omnisharp路径 设置路径\nCode -\u0026gt; Preferences -\u0026gt; Settings, 检索mono, 点击settings.json 配置omnisharp(很重要) 1 2 \u0026#34;omnisharp.monoPath\u0026#34;: \u0026#34;/Library/Frameworks/Mono.framework/Versions/Current/Commands/mono\u0026#34;, \u0026#34;omnisharp.useGlobalMono\u0026#34;: \u0026#34;always\u0026#34; 设置.zshrc/.bash_profile环境变量(很重要) 1 export FrameworkPathOverride=/Library/Frameworks/Mono.framework/Versions/Current 5.设置Unity代码编辑器 ","description":"","id":61,"section":"posts","tags":["VSCode Unity环境搭建"],"title":"Mac VSCode开发Unity环境搭建","uri":"https://popo-blog.vercel.app/posts/mac/mac-vscode%E5%BC%80%E5%8F%91unity%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"content":"获取宝塔面板的登陆链接和用户名、密码 /etc/init.d/bt default ","description":"","id":62,"section":"posts","tags":["宝塔面板","服务器"],"title":"宝塔面板命令行","uri":"https://popo-blog.vercel.app/posts/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/"},{"content":"Part1 安装oh-my-zsh 第一步 clone oh-my-zsh项目 1 git clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh 第二步 复制 .zshrc 1 cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 第三步 更改你的默认 Shell 1 chsh -s /bin/zsh 第四步 新打开终端 compaudit | xargs chmod g-w,o-w 修改后终端变为这样\nps:这里选择了steeef主题，不是默认的robbyrussell主题\n终端的命令提示符 Part2 主题配置 修改.zshrc cd ~ vim ~/.zshrc 更改主题\n将 ZSH_THEME=\u0026ldquo;robbyrussell\u0026rdquo; 改成 ZSH_THEME=\u0026ldquo;steeef\u0026rdquo;\n应用到.zshrc source ~/.zshrc P.S. 这些主题都保存在 \u0026ldquo;~/.oh-my-zsh/themes\u0026rdquo; 目录中\n插件\noh-my-zsh 的自带插件都储存在 \u0026ldquo;~/.oh-my-zsh/plugins\u0026rdquo; 目录中,\n在 ~/.zshrc 中的 plugins 加入插件名称，这样设置就完成了。\n安装 zsh-syntax-highlighting 对于oh-my-zsh\ngit clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 在 ~/.zshrc 中加入插件的名字\nplugins=(zsh-syntax-highlighting)\n，最后source生效\nsource ~/.zshrc 对于osx\n可以直接\nbrew install zsh-syntax-highlighting 并且source生效\nsource /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh Ps 新打开终端才会显示。\n","description":"","id":63,"section":"posts","tags":["Mac"],"title":"Mac终端美化","uri":"https://popo-blog.vercel.app/posts/mac/mac%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96/"},{"content":"一级标题 二级标题 一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 Markdown 段落 Runoob.com\nGoogle.com\n字体 斜体字体\n粗体\n斜粗体\n分割线 删除线 baidu.com 双波浪线是英文字符\n下划线 带下划线\n脚注 格式 [^要注明的文本]\n创建脚注格式类似这样1\nMarkdown 列表 无序 第一 第二 第三 第一 第二 第三 第一 第二 第三 有序 第一 第二 第三 列表嵌套 第一项 第一项嵌套的第一个元素 第一项嵌套的第二个元素 第二项 第二项嵌套的第一个元素 第二项嵌套的第二个元素 Markdown 区块 区块引用\n菜鸟教程\n学的不仅是技术更是梦想\n区块嵌套 最外层\n第一层嵌套\n第二层嵌套\n区块中列表 第一项 第二项 第一项 第二项 第三项 列表中使用区块 第一项 菜鸟教程\n学的不仅是技术更是梦想\n第二项 Markdown 代码 printf() 函数\n\u0026lt;?php echo 'RUNOOB'; function test(){ echo 'test' } 可以指定一种语言或者不指定\n1 2 3 $(document).ready(function()){ alert(\u0026#39;RUNOOB\u0026#39;); }); 1 print(\u0026#34;hello world\u0026#34;) Markdown 链接 格式 链接名称\n这个是一个链接 菜鸟教程\n直接使用链接\nhttps://runoob.com\n高级链接 这个链接用 1 作为网址变量 Google\n这个链接用 runoob 作为网址变量 Runoob\n注意至少空一行\nMarkdown 图片 格式 使用实例：\n图片地址引用：\n这个链接用 1 作为网址变量RUNOOB\n指定图片的高度 宽度\nMarkdown 表格 Markdown 制作表格使用 | 来分隔不同的单元格 使用 - 来分隔表头和其它行\n表头 表头 单元格 单元格 单元格 单元格 对齐方式：\n-: 设置右对齐 :- 设置左对齐 :-: 设置居中对齐 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 Markdown 高级技巧 支持的HTML元素\n目前支持的HTML元素有： \u0026lt;kbd\u0026gt; \u0026lt;b\u0026gt; \u0026lt;i\u0026gt; \u0026lt;em\u0026gt; \u0026lt;sup\u0026gt; \u0026lt;sub\u0026gt; \u0026lt;br\u0026gt; 等\n使用Ctrl+Alt+Del 重启电脑\n斜体\n斜体\n图片上移动\n图片下移动\n\u0026lt;br\u0026gt;我换行了\n我换行了\n加反斜杆转义特殊字符 ** 正常显示星号 **\nMarkdown 支持以下符号加上反斜杠变成普通字符\n\\反斜线\n` 反引号\n* 星号\n_ 下划线\n{} 花括号\n[] 方括号\n() 小括号\n# 井字号\n+ 加号\n- 减号\n. 英文句号\n! 感叹号\n1. 横向流程图源码格式：\ngraph LR A[方形] --\u0026gt;B(圆角) B --\u0026gt; C{条件a} C --\u0026gt;|a=1| D[结果1] C --\u0026gt;|a=2| E[结果2] F[横向流程图] 2. 竖向流程图源码格式：\ngraph TD A[方形] --\u0026gt; B(圆角) B --\u0026gt; C{条件a} C --\u0026gt; |a=1| D[结果1] C --\u0026gt; |a=2| E[结果2] F[竖向流程图] 3. 标准流程图源码格式：\nst=\u0026gt;start: 开始框 op=\u0026gt;operation: 处理框 cond=\u0026gt;condition: 判断框(是或否?) sub1=\u0026gt;subroutine: 子流程 io=\u0026gt;inputoutput: 输入输出框 e=\u0026gt;end: 结束框 st-\u0026gt;op-\u0026gt;cond cond(yes)-\u0026gt;io-\u0026gt;e cond(no)-\u0026gt;sub1(right)-\u0026gt;op 4. 标准流程图源码格式（横向）：\nst=\u0026gt;start: 开始框 op=\u0026gt;operation: 处理框 cond=\u0026gt;condition: 判断框(是或否?) sub1=\u0026gt;subroutine: 子流程 io=\u0026gt;inputoutput: 输入输出框 e=\u0026gt;end: 结束框 st(right)-\u0026gt;op(right)-\u0026gt;cond cond(yes)-\u0026gt;io(bottom)-\u0026gt;e cond(no)-\u0026gt;sub1(right)-\u0026gt;op 5. UML时序图源码样例：\n对象A-\u0026gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--\u0026gt;对象A: 我很好(响应) 对象A-\u0026gt;对象B: 你真的好吗？ 6. UML时序图源码复杂样例：\nTitle: 标题：复杂使用 对象A-\u0026gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--\u0026gt;对象A: 我很好(响应) 对象B-\u0026gt;小三: 你好吗 小三--\u0026gt;\u0026gt;对象A: 对象B找我了 对象A-\u0026gt;对象B: 你真的好吗？ Note over 小三,对象B: 我们是朋友 participant C Note right of C: 没人陪我玩 7. UML标准时序图样例：\n%% 时序图例子,-\u0026gt; 直线，--\u0026gt;虚线，-\u0026gt;\u0026gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-\u0026gt;王五: 王五你好吗？ loop 健康检查 王五-\u0026gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 \u0026lt;br/\u0026gt;看医生... 李四--\u0026gt;\u0026gt;张三: 很好! 王五-\u0026gt;李四: 你怎么样? 李四--\u0026gt;王五: 很好! 菜鸟教程 \u0026ndash; 早点歇息\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":64,"section":"posts","tags":["markdown"],"title":"Markdown显示","uri":"https://popo-blog.vercel.app/posts/markdown/markdown%E6%98%BE%E7%A4%BA/"},{"content":"Markdown语法整理 目录\n一.分级目录\n二.斜体与粗体\n三.超链接\n3.1.行内式 3.2.参考式 3.3.自动连接 四.锚点\n4.1.页内超链接 4.2.文章内部标题链接 五.列表\n5.1.无需列表 5.2.有序列表 5.3.定义型列表 5.4.列表缩进 5.5.包含段落的列表 5.6.任务列表 六.表格\n6.1.竖杠|下划线-写法 6.2.html写法 七.创建和突出显示代码块\n7.1.栅栏代码块 7.2.语法高亮显示 7.3.引用代码 7.4.引用文字 7.5.删除线 使用LaTeX方法\n说明：本文中中语法里面的代码就是需要写的Markdown语法，展示效果就是最后生成的页面\n此语法编写和测试环境：windows上使用MarkdownPad2的GitHub离线风格的Markdown语法，使用在线风格好像不支持文章内部链接跳转\n一.分级目录 语法： * 总目录 * 一级目录 * 二级目录 * 三级目录 说明：层级列表一般只支持三级列表，第一级实心圆点，第二级空心圆点，第三级以后都是实心方点。要实现层级列表，每下一级都要比上一级多输入2个空格或者一个Tab，而且第一级前面不要超过3个空格.\n展示效果： 总目录 一级目录 二级目录 三级目录 二.斜体与粗体 语法： *斜体* **粗体** 展示效果： 斜体\n粗体\n三.超链接 Markdown支持两种形式的链接语法：行内式和参考式，行内式一般用的比较多。 3.1.行内式： 语法： [打开百度](http://www.baidu.com) [打开百度](http://www.baidu.com \u0026#34;打开百度\u0026#34;) 说明:[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。[链接文字](链接地址 “链接标题”)这样的形式。链接地址与链接标题前有一个空格。\n展示效果: 打开百度\n打开百度\n3.2.参考式: 参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。\n语法: 我经常浏览的几个网站[Google][1]、[Baidu][2]、[51CTO][3]和看视频的网站[爱奇艺][4]感觉都是很不错的[网站][]. [1]:http://www.google.com \u0026#34;google\u0026#34; [2]:http://www.baidu.com \u0026#34;Baidu\u0026#34; [3]:http://www.51cto.com \u0026#34;51cto\u0026#34; [4]:http://www.aiqiyi.com \u0026#34;aiqiyi\u0026#34; [网站]:http://www.qq.com 展示效果： 我经常浏览的几个网站Google、Baidu、51CTO和看视频的网站爱奇艺感觉都是很不错的网站.\n3.3.自动连接： 语法： \u0026lt;http://www.baidu.com/\u0026gt; \u0026lt;admin@baidu.com\u0026gt; 说明：Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用\u0026lt;\u0026gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样。\n展示效果： http://www.baidu.com/\nadmin@baidu.com\n四.锚点 网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。\n注意：Markdown Extra 只支持在标题后插入锚点，其它地方无效\n4.1.页内超链接: 语法： # 1.分级目录{#index} 跳转到[标题]{#index} 说明：在你准备跳转到的指定标题后插入锚点{#标记}，然后在文档的其它地方写上连接到锚点的链接。此处使用的是GitHub风格的Markdown语法所以无法正常显示效果，推荐使用以下4.2.文章内部标题链接。\n展示效果： 1.分级目录 跳转到1.分级目录\n说明：这里是在本文的分级目录设置的，不然效果不明显\n4.2.文章内部标题链接： 语法： * [目录1](#40) * [标题1](#41) * [标题2](#42) * [标题3](#43) * [标题4](#44) \u0026lt;h3 id=\u0026#34;41\u0026#34;\u0026gt;标题1\u0026lt;/h3\u0026gt; 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 \u0026lt;h3 id=\u0026#34;42\u0026#34;\u0026gt;标题2\u0026lt;/h3\u0026gt; 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 \u0026lt;h3 id=\u0026#34;43\u0026#34;\u0026gt;标题3\u0026lt;/h3\u0026gt; 我轻轻的招手， 作别西天的云彩。 \u0026lt;h3 id=\u0026#34;44\u0026#34;\u0026gt;标题4\u0026lt;/h3\u0026gt; 作别西天的云彩。 展示效果： 目录1 标题1 标题2 标题3 标题4 标题1 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。\n标题2 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。\n标题3 我轻轻的招手， 作别西天的云彩。\n标题4 作别西天的云彩。\n五.列表 5.1.无需列表: 使用 *，+，- 表示无序列表\n语法： - 无序列表一 + 无序列表二 * 无序列表三 展现效果： 无序列表一\n无序列表二\n无序列表三\n5.2.有序列表： 有序列表则使用数字接着一个英文句点\n语法： 1.有序列表一 2.有序列表二 3.有序列表三 展现效果： 有序列表一 有序列表二 有序列表三 5.3.定义型列表: 语法： 名词1 : 定义 1（左侧有一个可见的冒号和四个不可见的空格） 代码块 2 : 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 说明：\n定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab)\n展现效果： 名词1 定义 1（左侧有一个可见的冒号和四个不可见的空格） 代码块 2 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 5.4.列表缩进： 语法： * 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ * 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 说明：列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。\n效果： 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。\n那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。\n软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。\n但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！\n悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 5.5.包含段落的列表: 语法： * 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ * 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 说明：\n列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符（显示效果与代码一致）：如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许\n效果： 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。\n那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。\n软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！\n那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。\n寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。\n但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！\n悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。\n5.6.任务列表: 要创建任务列表，前缀列表项[ ]。要将任务标记为完整，请使用[x]\n语法： - [] 跑步 - [] 骑车 - [x] 吃饭 - [] 睡觉 展现效果： 跑步 骑车 吃饭 睡觉 六.表格 6.1.竖杠|下划线-写法: 使用竖杠|下划线-写法\n语法： |名字|性别|年龄|国籍| |---|----|----|---| |张三|男|23|中国| |小红|女|18|中国| |Tom|男|46|美国| 展现效果： 名字 性别 年龄 国籍 张三 男 23 中国 小红 女 18 中国 Tom 男 46 美国 6.2.html写法: 使用\u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt;\n语法： \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;车次\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;开车时间\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;到达时间\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;D110\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;10:22\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;11:00\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 展现效果： 车次 开车时间 到达时间 D110 10:22 11:00 这里是因为使用github离线风格导致空格，使用在线就没有了\n七.创建和突出显示代码块 7.1.栅栏代码块: 语法： function test() {\nconsole.log（“在此函数之前注意空白行?\u0026quot;);\n}\n展现效果： function test() { console.log(\u0026#34;在此函数之前注意空白行?\u0026#34;); } 7.2.语法高亮显示: 高亮度需要使用github在线风格才能显示颜色\n语法： ```ruby require \u0026#39;redcarpet\u0026#39; markdown = Redcarpet.new(\u0026#34;Hello World!\u0026#34;) puts markdown.to_html ​``` 展现效果： ruby语法：\n​```ruby\nrequire \u0026lsquo;redcarpet\u0026rsquo;\nmarkdown = Redcarpet.new(\u0026ldquo;Hello World!\u0026rdquo;)\nputs markdown.to_html\n\u0026gt; python语法： ```python def foo(): if not bar: return True 本文使用的markdownPad2需要使用github在线markdown风格才会显示，其他不显示。\n7.3.引用代码: 您可以使用单个反引号来调用句子中的代码或命令。反引号内的文本将不被格式化。\n语法： Use `git status` to list all new or modified files that haven\u0026#39;t yet been committed. 展现效果: Use git status to list all new or modified files that haven\u0026rsquo;t yet been committed.\n7.4.引用文字: 你可以用引用文本\u0026gt;.\n语法： In the words of Abraham Lincoln: \u0026gt; Pardon my French 展现效果: In the words of Abraham Lincoln:\nPardon my French\n7.5.删除线: 语法： ~~This was mistaken text~~ 展现效果: This was mistaken text\n使用LaTeX方法 使用LaTeX方法： 下面还有些没有显示出效果，先扔着把，毕竟才开始玩，先这样吧\nMathJax是一款相当强悍的在网页显示数学公式的插件。本教程介绍MathJax如何使用LaTeX语法编写数学公式。\n如何插入公式 L aTeX的数学公式有两种：行中公式和独立公式。行中公式放在文中与其它文字混编，独立公式单独成行。\n行中公式可以用如下两种方法表示：\n1 ＼(数学公式＼)　或　￥数学公式￥（要把人民币符号换成美元符号） 独立公式可以用如下两种方法表示：\n1 ＼[数学公式＼]　或　￥￥数学公式￥￥（要把人民币符号换成美元符号） 例子：\n1 $$ ＼[J\\alpha(x) = \\sum{m=0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha}＼] $$ 显示：\n$$ \\J*\\alpha(x) = \\sum*{m=0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha}\\ ] $$\n如何输入上下标 ^表示上标,_表示下标。如果上下标的内容多于一个字符，要用{}把这些内容括起来当成一个整体。上下标是可以嵌套的，也可以同时使用。\n例子：\n1 $$ x^{y^z}=(1+{\\rm e}^x)^{-2xy^w} $$ 显示：\n$$ x^{y^z}=(1+{\\rm e}^x)^{-2xy^w} $$\n另外，如果要在左右两边都有上下标，可以用\\sideset命令。\n例子：\n1 \\sideset{^12}{^34}\\bigotimes 显示：\n$$ \\sideset{^12}{^34}\\bigotimes $$\n如何输入括号和分隔符 ()、[]和|表示自己，{}表示{}。当要显示大号的括号或分隔符时，要用\\left和\\right命令。\n例子：\n1 $$ f(x,y,z) = 3y^2z \\left( 3+\\frac{7x+5}{1+y^2} \\right) $$ 显示：\n$$ f(x,y,z) = 3y^2z \\left( 3+\\frac{7x+5}{1+y^2} \\right) $$\n有时候要用\\left.或\\right.进行匹配而不显示本身。\n例子：\n1 $$ \\left. \\frac{{\\rm d}u}{{\\rm d}x} \\right| _{x=0} $$ 显示：\n$$ \\left. \\frac{{\\rm d}u}{{\\rm d}x} \\right| _{x=0} $$\n如何输入分数 例子：\n1 $$ \\frac{1}{3}　或　1 \\over 3 $$ 显示：\n$$ \\frac{1}{3} 或 1 \\over 3 $$\n如何输入开方 语法：\n1 $$ \\sqrt{2}　和　\\sqrt[n]{3} $$ 显示：\n$$ \\sqrt{2} 和　\\sqrt[n]{3} $$\n如何输入省略号 数学公式中常见的省略号有两种，\\ldots表示与文本底线对齐的省略号，\\cdots表示与文本中线对齐的省略号。\n语法：\n1 f(x1,x2,\\ldots,xn) = x1^2 + x2^2 + \\cdots + xn^2 显示：\n$$ f(x1,x2,\\ldots,xn) = x1^2 + x2^2 + \\cdots + xn^2 $$\n如何输入矢量 语法：\n1 \\vec{a} \\cdot \\vec{b}=0 显示：\n$$ \\vec{a} \\cdot \\vec{b}=0 $$\n如何输入积分 语法：\n1 \\int_0^1 x^2 {\\rm d}x 显示：\n$$ \\int_0^1 x^2 {\\rm d}x $$\n如何输入极限运算 语法：\n1 \\lim_{n \\rightarrow +\\infty} \\frac{1}{n(n+1)} 显示：\n$$ \\lim_{n \\rightarrow +\\infty} \\frac{1}{n(n+1)} $$\n如何输入累加、累乘运算 语法：\n1 \\sum{i=0}^n \\frac{1}{i^2}　和　\\prod{i=0}^n \\frac{1}{i^2} 显示：\n\\sum*{i=0}^n \\frac{1}{i^2} 和　\\prod*{i=0}^n \\frac{1}{i^2}\n如何进行公式应用 先要在［mathjax］后添加：\n1 2 3 4 \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; ＜script type=\u0026#34;text/x-mathjax-config\u0026#34;＞ MathJax.Hub.Config({ TeX: {equationNumbers: { autoNumber: [\u0026#34;AMS\u0026#34;], useLabelIds: true}}, \u0026#34;HTML-CSS\u0026#34;: {linebreaks: {automatic: true}}, SVG: {linebreaks: {automatic: true}} }); ＜/script＞ 只要按照这个添加代码就能实现本页的效果，包的下载自己找吧，就这样,想在线就得这样\n语法：\n1 ＼begin{equation}\\label{equation1}r = rF+ \\beta(rM – r_F) + \\epsilon＼end{equation} 显示：\n\\begin{equation}\\label{equation1}r = rF+ \\beta(rM – r_F) + \\epsilon\\end{equation}\n引用：请见公式( \\ref{equation1} )\n如何输入希腊字母 哎，这里的空白这蛋疼，目前还没有最终得解决发子\n语法 显示效果 $$ \\alpha $$ $$ \\alpha $$ $$ \\beta $$ $$ \\beta $$ $$\\gamma $$ $$\\gamma $$ $$ \\Gamma $$ $$ \\Gamma $$ $$ \\delta $$ $$ \\delta $$ $$ \\Delta $$ $$ \\Delta $$ $$ \\epsilon $$ $$ \\epsilon $$ $$ \\varepsilon $$ $$ \\varepsilon $$ $$ \\zeta $$ $$ \\zeta $$ $$ \\eta $$ $$ \\eta $$ $$ \\theta $$ $$ \\theta $$ $$ \\Theta $$ $$ \\Theta $$ $$ \\vartheta $$ $$ \\vartheta $$ $$ \\iota $$ $$ \\iota $$ $$ \\kappa $$ $$ \\kappa $$ $$ \\lambda$$ $$ \\lambda$$ $$ \\Lambda $ $$ \\Lambda $$ $$ \\mu $$ $$ \\mu $$ $$ \\nu $$ $$ \\nu $$ $$ \\Xi $$ $$ \\Xi $$ $$ \\pi $$ $$ \\pi $$ $$ \\Pi $$ $$ \\Pi $$ $$ \\varpi $$ $$ \\varpi $$ $$ \\rho $$ $$ \\rho $$ $$\\varrho $$ $$\\varrho $$ $$ \\sigma $$ $$ \\sigma $$ $$ \\Sigma $$ $$ \\Sigma $$ $$ \\varsigma $$ $$ \\varsigma $$ $$ \\tau $$ $$ \\tau $$ $$ \\upsilon $$ $$ \\upsilon $$ $$ \\Upsilon $$ $$ \\Upsilon $$ $$ \\xi $$ $$ \\xi $$ $$ \\Phi $$ $$ \\Phi $$ $$ \\varphi $$ $$ \\varphi $$ $$ \\chi $$ $$ \\chi $$ $$ \\psi $$ $$ \\psi $$ $$ \\Psi $$ $$ \\Psi $$ $$ \\omega $$ $$ \\omega $$ $$ \\Omega $$ $$ \\Omega $$ 如何输入其它特殊字符 关系运算符：\n语法 显示效果 $$ \\pm $$ $$ \\pm $$ $$ \\times $$ $$ \\times $$ $$ \\div $$ $$ \\div $$ $$ \\mid $$ $$ \\mid $$ $$ \\nmid $$ $$ \\nmid $$ $$ \\cdot $$ $$ \\cdot $$ $$ \\circ $$ $$ \\circ $$ $$ \\ast $$ $$ \\ast $$ $$ \\bigodot $$ $$ \\bigodot $$ $$ \\bigotimes $$ $$ \\bigotimes$$ $$ \\bigoplus $$ $$ \\bigoplus $$ $$ \\leq $$ $$ \\leq $$ $$ \\geq $$ $$ \\geq $$ $$ \\neq $$ $$ \\neq $$ $$ \\approx $$ $$ \\approx $$ $$ \\equiv $$ $$ \\equiv $$ $$ \\sum $$ $$ \\sum $$ $$ \\prod $$ $$ \\prod $$ $$ \\coprod $$ $$ \\coprod $$ 集合运算符： 语法 显示效果 $$ \\emptyset $$ $$ \\emptyset $$ $$ \\in $$ $$ \\in $$ $$ \\notin $$ $$ \\notin $$ $$ \\subset $$ $$ \\subset $$ $$ \\supset $$ $$ \\supset $$ $$ \\subseteq $$ $$ \\subseteq $$ $$ \\supseteq $$ $$ \\supseteq $$ $$ \\bigcap $$ $$ \\bigcap $$ $$ \\bigcup $$ $$ \\bigcup $$ $$ \\bigvee $$ $$ \\bigvee $$ $$ \\bigwedge $$ $$ \\bigwedge $$ $$ \\biguplus $$ $$ \\biguplus $$ $$ \\bigsqcup $$ $$ \\bigsqcup $$ 对数运算符： 语法 显示效果 $$ \\log $$ $$ \\log $$ $$ \\lg $$ $$ \\lg $$ $$ \\ln $$ $$ \\ln $$ 三角运算符： 语法 显示效果 $$ \\bot $$ $$ \\bot $$ $$ \\angle $$ $$ \\angle $$ $$ 30^\\circ $$ $$ 30^\\circ $$ $$ \\sin $$ $$ \\sin $$ $$ \\cos $$ $$ \\cos $$ $$ \\tan $$ $$ \\tan $$ $$ \\cot $$ $$ \\cot $$ $$ \\sec $$ $$ \\sec $$ $$ \\csc $$ $$ \\csc $$ 微积分运算符： 语法 显示效果 $$ \\prime $$ $$ \\prime $$ $$ \\int $$ $$ \\int $$ $$ \\iint $$ $$ \\iint $$ $$ \\iiint $$ $$ \\iiint $$ $$ \\iiiint $$ $$ \\iiiint $$ $$ \\oint $$ $$ \\oint $$ $$ \\lim $$ $$ \\lim $$ $$ \\infty $$ $$ \\infty $$ $$ \\nabla $$ $$ \\nabla $$ 逻辑运算符： 语法 显示效果 $$ \\because $$ $$ \\because $$ $$ \\therefore $$ $$ \\therefore $$ $$ \\forall $$ $$ \\forall $$ $$ \\exists $$ $$ \\exists $$ $$ \\not= $$ $$ \\not= $$ $$ \\not\u0026gt; $$ $$ \\not\u0026gt; $$ $$ \\not\\subset $$ $$ \\not\\subset $$ 戴帽符号： 语法 显示效果 $$ \\hat{y} $$ $$ \\hat{y} $$ $$ \\check{y} $$ $$ \\check{y} $$ $$ \\breve{y} $$ $$ \\breve{y} $$ 连线符号： 语法 显示效果 $$ \\overline{a+b+c+d} $$ $$ \\overline{a+b+c+d} $$ $$ \\underline{a+b+c+d} $$ $$ \\underline{a+b+c+d} $$ $$ \\overbrace{a+\\underbrace{b+c}\u0026lt;em\u0026gt;{1.0}+d}^{2.0} $$ $$ \\overbrace{a+\\underbrace{b+c}{1.0}+d}^{2.0} $$ 箭头符号： 哎，这里的空白这蛋疼，目前还没有最终得解决发子\n语法 显示效果 $$ \\uparrow $$ $$ \\uparrow $$ $$ \\downarrow $$ $$ \\downarrow $$ $$ \\Uparrow $$ $$ \\Uparrow $$ $$ \\Downarrow $$ $$ \\Downarrow $$ $$ \\rightarrow $$ $$ \\rightarrow $$ $$ \\leftarrow $$ $$ \\leftarrow $$ $$ \\Rightarrow $$ $$ \\Rightarrow $$ $$ \\Leftarrow $$ $$ \\Leftarrow $$ $$ \\longrightarrow $$ $$ \\longrightarrow $$ $$ \\longleftarrow $$ $$ \\longleftarrow $$ $$ \\Longrightarrow $$ $$ \\Longrightarrow $$ $$ \\Longleftarrow $$ $$ \\Longleftarrow $$ 要输出字符 哎，这里的空白这蛋疼，目前还没有最终得解决发子\n语法 显示效果 \\空格 a\\ b \\# # \\$ $ \\% % \\\u0026amp; \u0026amp; _ _ {　} { } 这里的空格没有搞定，显示没有按预期的效果来，#下面的，在MarkdownPad2中默认是不需要转换，所以加\\没效果\n如何进行字体转换 要对公式的某一部分字符进行字体转换，可以用$$ {\\rm 需转换的部分字符 } $$命令，其中\\rm可以参照下表选择合适的字体。\n一般情况下，公式默认为意大利体。\n语法 字体名称 显示效果 $$ {\\rm 需转换的部分字符} $$ 罗马体 $$ {\\rm ABCD} $$ $$ {\\it 需转换的部分字符} $$ 意大利体 $$ {\\it ABCD} $$ $$ {\\Bbbr 需转换的部分字符} $$ 黑板粗体字 $$ {\\Bbb ABCD} $$ $$ {\\bf 需转换的部分字符} $$ 黑体 $$ {\\bf　ABCD} $$ $$ {\\cal 需转换的部分字符} $$ 花体 $$ {\\cal　ABCD} $$ $$ {\\sl 需转换的部分字符} $$ 倾斜体 $$ {\\sl ABCD} $$ $$ {\\sf 需转换的部分字符} $$ 等线体 $$ {\\sf　ABCD} $$ $$ {\\mit 需转换的部分字符} $$ 数学斜体 $$ {\\mit　ABCD} $$ $$ {\\tt 需转换的部分字符} $$ 打字机字体 $$ {\\tt ABCD} $$ $$ {\\scr 需转换的部分字符} $$ 小体大写字母 $$ {\\scr ABCD} $$ $$ {\\frakr 需转换的部分字符} $$ Fraktur字母（一种德国字体） $$ {\\frak ABCD} $$ 先到这里把，这个字体转换还没有彻底的明白，其中有几个还没有成功，对于MarkdownPad2支持Latex确实有点蛋疼，实时预览看不到，需要F6 html预览才行，另外还得额外加载相关js代码\n跳转至首页\n","description":"","id":65,"section":"posts","tags":["markdown"],"title":"Markdown语法整理","uri":"https://popo-blog.vercel.app/posts/markdown/markdown%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86/"},{"content":"一级标题 ======= 二级标题 ------- # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 ## Markdown 段落 Runoob.com Google.com ### 字体 *斜体字体* **粗体** ***斜粗体*** ### 分割线 *** ******* ### 删除线 ~~baidu.com~~ `双波浪线是英文字符` ### 下划线 \u0026lt;u\u0026gt;带下划线\u0026lt;/u\u0026gt; ### 脚注 格式 [^要注明的文本] 创建脚注格式类似这样[^RunooB] [^RunooB]: 菜鸟教程 -- 早点歇息 ## Markdown 列表 ##### 无序 * 第一 * 第二 * 第三 + 第一 + 第二 + 第三 - 第一 - 第二 - 第三 ##### 有序 1. 第一 2. 第二 3. 第三 ##### 列表嵌套 1. 第一项 * 第一项嵌套的第一个元素 * 第一项嵌套的第二个元素 2. 第二项 * 第二项嵌套的第一个元素 * 第二项嵌套的第二个元素 ## Markdown 区块 \u0026gt; 区块引用 \u0026gt; 菜鸟教程 \u0026gt; 学的不仅是技术更是梦想 ##### 区块嵌套 \u0026gt; 最外层 \u0026gt; \u0026gt; 第一层嵌套 \u0026gt; \u0026gt; \u0026gt; 第二层嵌套 ##### 区块中列表 \u0026gt; 1. 第一项 \u0026gt; 2. 第二项 \u0026gt; * 第一项 \u0026gt; * 第二项 \u0026gt; * 第三项 ##### 列表中使用区块 * 第一项 \u0026gt; 菜鸟教程 \u0026gt; 学的不仅是技术更是梦想 * 第二项 ## Markdown 代码 `printf()` 函数 \u0026lt;?php echo \u0026#39;RUNOOB\u0026#39;; function test(){ echo \u0026#39;test\u0026#39; } 可以指定一种语言或者不指定 ```javascript $(document).ready(function()){ alert(\u0026#39;RUNOOB\u0026#39;); }); ```python print(\u0026#34;hello world\u0026#34;) ## Markdown 链接 ##### 格式 [链接名称](链接地址) 这个是一个链接 [菜鸟教程](https://runoob.com) 直接使用链接 \u0026lt;https://runoob.com\u0026gt; ##### 高级链接 这个链接用 1 作为网址变量 [Google][1] 这个链接用 runoob 作为网址变量 [Runoob][runoob] 注意至少空一行 [runoob]:http://www.runoob.com [1]:http://www.google.com/ ## Markdown 图片 ##### 格式 ![alt 属性文本](图片地址) ![alt 属性文本](图片地址 \u0026#34;可选标题\u0026#34;) 使用实例： ![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png) ![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png \u0026#34;RUNOOB\u0026#34;) ![](./image/1.jpeg) \u0026lt;img src=\u0026#34;./image/1.jpeg\u0026#34; width=\u0026#34;20%\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;./image/1.jpeg\u0026#34; height=\u0026#34;10%\u0026#34;\u0026gt; 图片地址引用： 这个链接用 1 作为网址变量[RUNOOB][2] [2]:http://static.runoob.com/images/runoob-logo.png **指定图片的高度 宽度** \u0026lt;img src=\u0026#34;http://static.runoob.com/images/runoob-logo.png\u0026#34; width=\u0026#34;20%\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;http://static.runoob.com/images/runoob-logo.png\u0026#34; height=\u0026#34;20%\u0026#34;\u0026gt; ## Markdown 表格 Markdown 制作表格使用 | 来分隔不同的单元格 使用 - 来分隔表头和其它行 |表头|表头| |-|-| |单元格|单元格| |单元格|单元格| 对齐方式： * -: 设置右对齐 * :- 设置左对齐 * :-: 设置居中对齐 |左对齐|右对齐|居中对齐| |:-|-:|:-:| |单元格|单元格|单元格| |单元格|单元格|单元格| ## Markdown 高级技巧 支持的**HTML**元素 目前支持的HTML元素有： `\u0026lt;kbd\u0026gt; \u0026lt;b\u0026gt; \u0026lt;i\u0026gt; \u0026lt;em\u0026gt; \u0026lt;sup\u0026gt; \u0026lt;sub\u0026gt; \u0026lt;br\u0026gt;` 等 使用\u0026lt;kbd\u0026gt;Ctrl\u0026lt;/kbd\u0026gt;+\u0026lt;kbd\u0026gt;Alt\u0026lt;/kbd\u0026gt;+\u0026lt;kbd\u0026gt;Del\u0026lt;/kbd\u0026gt; 重启电脑 \u0026gt;\u0026lt;i\u0026gt; 斜体\u0026lt;/i\u0026gt; \u0026lt;em\u0026gt;斜体\u0026lt;/em\u0026gt; 图片\u0026lt;sup\u0026gt;上移动\u0026lt;/sup\u0026gt; 图片\u0026lt;sub\u0026gt;下移动\u0026lt;/sub\u0026gt; `\u0026lt;br\u0026gt;我换行了` \u0026lt;br\u0026gt;我换行了 ##### **加反斜杆转义特殊字符** \u0026gt;\\*\\* 正常显示星号 \\*\\* **Markdown 支持以下符号加上反斜杠变成普通字符** \u0026gt;\\\\反斜线 \\` 反引号 \u0026gt;\\* 星号 \u0026gt;\\_ 下划线 \u0026gt;\\{} 花括号 \u0026gt;\\[] 方括号 \u0026gt;\\() 小括号 \u0026gt;\\# 井字号 \u0026gt;\\+ 加号 \u0026gt;\\- 减号 \u0026gt;\\. 英文句号 \u0026gt;\\! 感叹号 **1. 横向流程图源码格式：** ```mermaid graph LR A[方形] --\u0026gt;B(圆角) B --\u0026gt; C{条件a} C --\u0026gt;|a=1| D[结果1] C --\u0026gt;|a=2| E[结果2] F[横向流程图] **2. 竖向流程图源码格式：** ```mermaid graph TD A[方形] --\u0026gt; B(圆角) B --\u0026gt; C{条件a} C --\u0026gt; |a=1| D[结果1] C --\u0026gt; |a=2| E[结果2] F[竖向流程图] **3. 标准流程图源码格式：** ```flow st=\u0026gt;start: 开始框 op=\u0026gt;operation: 处理框 cond=\u0026gt;condition: 判断框(是或否?) sub1=\u0026gt;subroutine: 子流程 io=\u0026gt;inputoutput: 输入输出框 e=\u0026gt;end: 结束框 st-\u0026gt;op-\u0026gt;cond cond(yes)-\u0026gt;io-\u0026gt;e cond(no)-\u0026gt;sub1(right)-\u0026gt;op **4. 标准流程图源码格式（横向）：** ```flow st=\u0026gt;start: 开始框 op=\u0026gt;operation: 处理框 cond=\u0026gt;condition: 判断框(是或否?) sub1=\u0026gt;subroutine: 子流程 io=\u0026gt;inputoutput: 输入输出框 e=\u0026gt;end: 结束框 st(right)-\u0026gt;op(right)-\u0026gt;cond cond(yes)-\u0026gt;io(bottom)-\u0026gt;e cond(no)-\u0026gt;sub1(right)-\u0026gt;op **5. UML时序图源码样例：** ```sequence 对象A-\u0026gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--\u0026gt;对象A: 我很好(响应) 对象A-\u0026gt;对象B: 你真的好吗？ **6. UML时序图源码复杂样例：** ```sequence Title: 标题：复杂使用 对象A-\u0026gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--\u0026gt;对象A: 我很好(响应) 对象B-\u0026gt;小三: 你好吗 小三--\u0026gt;\u0026gt;对象A: 对象B找我了 对象A-\u0026gt;对象B: 你真的好吗？ Note over 小三,对象B: 我们是朋友 participant C Note right of C: 没人陪我玩 **7. UML标准时序图样例：** ```mermaid %% 时序图例子,-\u0026gt; 直线，--\u0026gt;虚线，-\u0026gt;\u0026gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-\u0026gt;王五: 王五你好吗？ loop 健康检查 王五-\u0026gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 \u0026lt;br/\u0026gt;看医生... 李四--\u0026gt;\u0026gt;张三: 很好! 王五-\u0026gt;李四: 你怎么样? 李四--\u0026gt;王五: 很好! ","description":"","id":66,"section":"posts","tags":["markdown"],"title":"MarkdownLearn","uri":"https://popo-blog.vercel.app/posts/markdown/markdownlearn/"},{"content":"牛客网IO练习 https://ac.nowcoder.com/acm/contest/5657#question\n计算a+b (1) 题目描述 打开以下链接可以查看正确的代码\nhttps://ac.nowcoder.com/acm/contest/5657#question\n输入描述: 输入包括两个正整数a,b(1 \u0026lt;= a, b \u0026lt;= 10^9),输入数据包括多组。\n输出描述: 输出a+b的结果\n示例1 输入 1 5\n10 20\n输出 6\n30\n1 2 3 4 5 6 7 8 9 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int a, b; while(cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b) cout\u0026lt;\u0026lt;a+b\u0026lt;\u0026lt;endl; return 0; } 计算a+b (2) 题目描述 计算a+b\n打开以下链接可以查看正确的代码\nhttps://ac.nowcoder.com/acm/contest/5657#question\n输入描述: 输入第一行包括一个数据组数t(1 \u0026lt;= t \u0026lt;= 100)\n接下来每行包括两个正整数a,b(1 \u0026lt;= a, b \u0026lt;= 10^9)\n输出描述: 输出a+b的结果\n示例1 输入 2\n1 5\n10 20\n输出 6\n30\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--){ int a, b; while(cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b) cout\u0026lt;\u0026lt;a+b\u0026lt;\u0026lt;endl; } return 0; } 计算a+b (3) 题目描述 计算a+b\n打开以下链接可以查看正确的代码\nhttps://ac.nowcoder.com/acm/contest/5657#question\n输入描述: 输入包括两个正整数a,b(1 \u0026lt;= a, b \u0026lt;= 10^9),输入数据有多组, 如果输入为0 0则结束输入\n输出描述: 输出a+b的结果\n示例1 输入 1 5\n10 20\n0 0\n输出 6\n30\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int a, b; while(cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b){ if(a==0\u0026amp;\u0026amp;b==0) break; cout\u0026lt;\u0026lt;a+b\u0026lt;\u0026lt;endl; } return 0; } 计算a+b (4) 题目描述 计算一系列数的和\n打开以下链接可以查看正确的代码\nhttps://ac.nowcoder.com/acm/contest/5657#question\n输入描述: 输入数据包括多组。\n每组数据一行,每行的第一个整数为整数的个数n(1 \u0026lt;= n \u0026lt;= 100), n为0的时候结束输入。\n接下来n个正整数,即需要求和的每个正整数。\n输出描述: 每组数据输出求和的结果\n示例1 输入 4 1 2 3 4\n5 1 2 3 4 5\n0\n输出 10\n15\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int n; while(cin\u0026gt;\u0026gt;n){ if(n==0) break; int sum = 0,temp; while(n--){ cin\u0026gt;\u0026gt;temp; sum += temp; } cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } return 0; } 计算a+b (5) 题目描述 计算一系列数的和\n打开以下链接可以查看正确的代码\nhttps://ac.nowcoder.com/acm/contest/5657#question\n输入描述: 输入的第一行包括一个正整数t(1 \u0026lt;= t \u0026lt;= 100), 表示数据组数。\n接下来t行, 每行一组数据。\n每行的第一个整数为整数的个数n(1 \u0026lt;= n \u0026lt;= 100)。\n接下来n个正整数, 即需要求和的每个正整数。\n输出描述: 每组数据输出求和的结果\n示例1 输入 2\n4 1 2 3 4\n5 1 2 3 4 5\n输出 10\n15\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--){ int n; cin\u0026gt;\u0026gt;n; int sum = 0,temp; while(n--){ cin\u0026gt;\u0026gt;temp; sum += temp; } cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } return 0; } 计算a+b (6) 题目描述 计算一系列数的和\n打开以下链接可以查看正确的代码\nhttps://ac.nowcoder.com/acm/contest/5657#question\n输入描述: 输入数据有多组, 每行表示一组输入数据。\n每行的第一个整数为整数的个数n(1 \u0026lt;= n \u0026lt;= 100)。\n接下来n个正整数, 即需要求和的每个正整数。\n输出描述: 每组数据输出求和的结果\n示例1 输入 4 1 2 3 4\n5 1 2 3 4 5\n输出 10\n15\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int t; while(cin\u0026gt;\u0026gt;t){ int sum = 0; while(t--){ int temp; cin\u0026gt;\u0026gt;temp; sum += temp; } cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } return 0; } 计算a+b (7) 题目描述 计算一系列数的和\n打开以下链接可以查看正确的代码\nhttps://ac.nowcoder.com/acm/contest/5657#question\n输入描述: 输入数据有多组, 每行表示一组输入数据。\n每行不定有n个整数，空格隔开。(1 \u0026lt;= n \u0026lt;= 100)。\n输出描述: 每组数据输出求和的结果\n示例1 输入 1 2 3\n4 5\n0 0 0 0 0\n输出 6\n9\n0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int temp,sum = 0; while(cin\u0026gt;\u0026gt;temp){ sum += temp; if(cin.get()==\u0026#39;\\n\u0026#39;){ cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; sum = 0; } } return 0; } 字符串排序（1） 题目描述 对输入的字符串进行排序后输出\n打开以下链接可以查看正确的代码\nhttps://ac.nowcoder.com/acm/contest/5657#question\n输入描述: 输入有两行，第一行n\n第二行是n个空格隔开的字符串\n输出描述: 输出一行排序后的字符串，空格隔开，无结尾空格\n示例1 输入 5\nc d a bb e\n输出 a bb c d e\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { int n; string *pstr; vector\u0026lt;string\u0026gt; que; cin \u0026gt;\u0026gt; n; pstr = new string[n]; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; pstr[i]; que.push_back(pstr[i]); } sort(que.begin(), que.end()); for (int i = 0; i \u0026lt; n; i++) { cout \u0026lt;\u0026lt; que[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } 字符串排序 （2） 题目描述 对输入的字符串进行排序后输出\n打开以下链接可以查看正确的代码\nhttps://ac.nowcoder.com/acm/contest/5657#question\n输入描述: 多个测试用例，每个测试用例一行。\n每行通过空格隔开，有n个字符，n＜100\n输出描述: 对于每组测试用例，输出一行排序过的字符串，每个字符串通过空格隔开\n示例1 输入 a c bb\nf dddd\nnowcoder\n输出 a bb c\ndddd f\nnowcoder\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; int main() { string str; vector\u0026lt;string\u0026gt; s; while(cin\u0026gt;\u0026gt;str) { s.push_back(str); if(cin.get()==\u0026#39;\\n\u0026#39;) { sort(s.begin(), s.end()); int n = s.size(); for(int i = 0;i\u0026lt;n;i++) { cout\u0026lt;\u0026lt;s[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } s.clear(); cout\u0026lt;\u0026lt;endl; } } } 字符串排序 （3） 题目描述 对输入的字符串进行排序后输出\n打开以下链接可以查看正确的代码\nhttps://ac.nowcoder.com/acm/contest/5657#question\n输入描述: 多个测试用例，每个测试用例一行。\n每行通过,隔开，有n个字符，n＜100\n输出描述: 对于每组用例输出一行排序后的字符串，用\u0026rsquo;,\u0026lsquo;隔开，无结尾空格\n示例1 输入 a,c,bb\nf,dddd\nnowcoder\n输出 a,bb,c\ndddd,f\nnowcoder\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;sstream\u0026gt; using namespace std; int main() { string line; string str; vector\u0026lt;string\u0026gt; s; while(cin\u0026gt;\u0026gt;line) { stringstream ss(line); while(getline(ss, str, \u0026#39;,\u0026#39;)) { s.push_back(str); } sort(s.begin(),s.end()); if(s.size()==1) cout\u0026lt;\u0026lt;s[0]; else for(int i = 0;i\u0026lt;s.size();i++) { if(i!=s.size()-1) cout\u0026lt;\u0026lt;s[i]\u0026lt;\u0026lt;\u0026#39;,\u0026#39;; else cout\u0026lt;\u0026lt;s[i]; } s.clear(); cout\u0026lt;\u0026lt;endl; } } ","description":"","id":67,"section":"posts","tags":["牛客网"],"title":"C++IO牛客网","uri":"https://popo-blog.vercel.app/posts/c++io%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0/"},{"content":"Mac启动台App问号 1 2 defaults write com.apple.dock ResetLaunchPad -bool TRUE killall Dock ","description":"","id":68,"section":"posts","tags":["Mac"],"title":"Mac启动台App问号","uri":"https://popo-blog.vercel.app/posts/mac/mac%E5%90%AF%E5%8A%A8%E5%8F%B0app%E9%97%AE%E5%8F%B7/"},{"content":"方法一： 第一步：打开「终端」应用程序。\n第二步：输入如下命令：\n1 defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder 第三步：按下「Return」键确认。 现在你将会在 Finder 窗口中看到那些隐藏的文件和文件夹了。\n如果你想再次隐藏原本的隐藏文件和文件夹的话，将上述命令替换成\n1 defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder 即可。\n方法二： Finder界面是，最上方，通过“前往”进入“电脑”或文件夹，\n先进入到需要显示隐藏文件的文件夹下\n接着按Command苹果键+F,在窗格上会显示搜索栏\n然后将第一个下列选择项“种类kind”选择为“其它Other”，当选择“其它”时，\n弹出新的搜索窗口，找到下面的“文件不可见File invisible”项，\n勾上后面的对勾，再单击“好OK”即可，返回文件夹，就可以看到，\n隐藏的文件已经显示出来了\n","description":"","id":69,"section":"posts","tags":["Mac"],"title":"Mac上显示和隐藏文件","uri":"https://popo-blog.vercel.app/posts/mac/mac%E4%B8%8A%E6%98%BE%E7%A4%BA%E5%92%8C%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/"},{"content":"题目描述 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。你可以假设数组是非空的，并且给定的数组总是存在多数元素。1\u0026lt;=数组长度\u0026lt;=50000\n示例1 输入 [1,2,3,2,2,2,5,4,2] 返回值 2 方法一: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: int MoreThanHalfNum_Solution(vector\u0026lt;int\u0026gt; numbers) { if(numbers.empty()) return 0; int time = 0; int result = 0; for(int i=0;i\u0026lt;numbers.size();i++) { if(time==0) { result = numbers[i]; time = 1; } else if(numbers[i]==result) time++; else time--; } time = 0; for(int i = 0;i\u0026lt;numbers.size();i++) if(numbers[i]==result) time++; return time\u0026gt;numbers.size()\u0026gt;\u0026gt;1?result:0; } }; 方法二: 1 2 3 4 5 6 7 8 9 10 11 class Solution { public: int MoreThanHalfNum_Solution(vector\u0026lt;int\u0026gt; numbers) { map\u0026lt;int, int\u0026gt; mp; for(const int val:numbers) mp[val]++; for(const auto \u0026amp;val:mp) if(val.second \u0026gt; (numbers.size()\u0026gt;\u0026gt;1)) return val.first; } }; ","description":"剑指office（二十八）数组中出现次数超过一半的数字","id":70,"section":"posts","tags":["剑指office"],"title":"剑指office（二十八）数组中出现次数超过一半的数字","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/28%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"},{"content":"题目描述 给定一个数组，找出其中最小的K个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。如果K\u0026gt;数组的长度，那么返回一个空的数组\n示例1 输入 [4,5,1,6,2,7,3,8],4 返回值 [1,2,3,4] 方法一: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class Solution { public: vector\u0026lt;int\u0026gt; GetLeastNumbers_Solution(vector\u0026lt;int\u0026gt; input, int k) { vector\u0026lt;int\u0026gt; result; if(input.empty()||k\u0026gt;input.size()) return result; ListNode *node = new ListNode(input[0]); node-\u0026gt;next = NULL; ListNode *lastNode = NULL; ListNode *head = node; //插入排除 for(int i=1;i\u0026lt;input.size();i++) { while(node) { ListNode *newNode = new ListNode(input[i]); if(input[i]\u0026gt;node-\u0026gt;val) { lastNode = node; node = node-\u0026gt;next; if(node==NULL) { //表尾处理 newNode-\u0026gt;next = lastNode-\u0026gt;next; lastNode-\u0026gt;next = newNode; } } else { if(lastNode) { //中间处理 newNode-\u0026gt;next = lastNode-\u0026gt;next; lastNode-\u0026gt;next = newNode; }else { //表头处理 newNode-\u0026gt;next = node; node = newNode; head = node; } break; } } node = head; lastNode = NULL; } for(int i= 0;i\u0026lt;k;i++) { result.push_back(node-\u0026gt;val); node = node-\u0026gt;next; } return result; } }; 方法二: class Solution { public: vector\u0026lt;int\u0026gt; GetLeastNumbers_Solution(vector\u0026lt;int\u0026gt; input, int k) { vector\u0026lt;int\u0026gt; result; if(input.empty()||k\u0026gt;input.size()) return result; sort(input.begin(),input.end()); result.insert(result.begin(),input.begin(), input.begin()+k); return result; } }; ","description":"剑指office（二十八）数组中出现次数超过一半的数字","id":71,"section":"posts","tags":["剑指office"],"title":"剑指office（二十八）数组中出现次数超过一半的数字","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/29%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"},{"content":"题目描述 输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n).\n示例1 输入 [1,-2,3,10,-4,7,2,-5] 返回值 18 方法一: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int FindGreatestSumOfSubArray(vector\u0026lt;int\u0026gt; array) { if(array.empty()) return 0; int maxsum = array[0]; int sum = 0; for(int i=0;i\u0026lt;array.size();i++) { if(sum\u0026lt;0) { sum = array[i]; }else { sum += array[i]; } if(sum\u0026gt;maxsum) maxsum = sum; } return maxsum; } }; 方法二: class Solution { public: int FindGreatestSumOfSubArray(vector\u0026lt;int\u0026gt; array) { if(array.empty()) return 0; int sum = array[0]; int lastSum = 0; int ret = sum; for(int i=0;i\u0026lt;array.size();i++) { sum = max(array[i],lastSum+array[i]); lastSum = sum; ret = max(sum,ret); } return ret; } }; ","description":"剑指office（二十八）数组中出现次数超过一半的数字","id":72,"section":"posts","tags":["剑指office"],"title":"剑指office（二十八）数组中出现次数超过一半的数字","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/30%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"},{"content":"题目描述 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: void ConvertNode(TreeNode* crruentNode,TreeNode* \u0026amp;lastNode) { if(crruentNode==NULL) return; ConvertNode(crruentNode-\u0026gt;left,lastNode); crruentNode-\u0026gt;left = lastNode; if(lastNode!=NULL) lastNode-\u0026gt;right = crruentNode; lastNode = crruentNode; ConvertNode(crruentNode-\u0026gt;right,lastNode); } TreeNode* Convert(TreeNode* pRootOfTree) { TreeNode *lastNode = NULL; if(pRootOfTree==NULL) return pRootOfTree; ConvertNode(pRootOfTree,lastNode); while(pRootOfTree-\u0026gt;left!=NULL) { pRootOfTree = pRootOfTree-\u0026gt;left; } return pRootOfTree; } }; ","description":"剑指office（二十六）二叉树搜索树与双向链表","id":73,"section":"posts","tags":["剑指office"],"title":"剑指office（二十六）二叉树搜索树与双向链表","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/26%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"},{"content":"题目描述 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。\n输入描述: 输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 示例1 输入 \u0026#34;ab\u0026#34; 返回值 [\u0026#34;ab\u0026#34;,\u0026#34;ba\u0026#34;] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: void PermutationCore(string str,int begin) { if(str.length()== begin) { result.push_back(str); return; } for(int i=begin;i\u0026lt;str.length();i++) { if(i!=begin\u0026amp;\u0026amp;str[i]==str[begin]) continue; swap(str[begin], str[i]); PermutationCore(str,begin+1); } } vector\u0026lt;string\u0026gt; Permutation(string str) { if(str.length()==0) return result; PermutationCore(str,0); return result; } private: vector\u0026lt;string\u0026gt; result; }; ","description":"剑指office（二十七）字符串的排列","id":74,"section":"posts","tags":["剑指office"],"title":"剑指office（二十七）字符串的排列","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/27%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"},{"content":"题目描述 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 /* struct RandomListNode { int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) { } }; */ class Solution { public: void Copy(RandomListNode* pHead) { RandomListNode* temp; while(pHead!=NULL) { temp = pHead-\u0026gt;next; RandomListNode* pNode = new RandomListNode(pHead-\u0026gt;label); pNode-\u0026gt;next = temp; pNode-\u0026gt;random = NULL; pHead-\u0026gt;next = pNode; pHead = temp; } } void AddRandom(RandomListNode* pHead) { while (pHead!=NULL) { if(pHead-\u0026gt;random!=NULL) { pHead-\u0026gt;next-\u0026gt;random = pHead-\u0026gt;random-\u0026gt;next; } if(pHead-\u0026gt;next!=NULL) pHead = pHead-\u0026gt;next-\u0026gt;next; } } RandomListNode* Detch(RandomListNode* pHead) { RandomListNode* pNode = pHead; RandomListNode* pCloneHead = NULL; RandomListNode* pClone = NULL; if(pNode != NULL){ pCloneHead = pNode-\u0026gt;next; pClone = pCloneHead; pNode-\u0026gt;next = pCloneHead-\u0026gt;next; pNode = pNode-\u0026gt;next; } while (pNode!=NULL) { pClone-\u0026gt;next = pNode-\u0026gt;next; pClone = pClone-\u0026gt;next; pNode-\u0026gt;next = pClone-\u0026gt;next; pNode = pNode-\u0026gt;next; } return pCloneHead; } RandomListNode* Clone(RandomListNode* pHead) { Copy(pHead); AddRandom(pHead); return Detch(pHead); } }; ","description":"剑指office（二十五）复杂链表的复制","id":75,"section":"posts","tags":["剑指office"],"title":"剑指office（二十五）复杂链表的复制","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/25%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"},{"content":"题目描述 输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。\n示例1 输入 {10,5,12,4,7},22 返回值 [[10,5,7],[10,12]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; FindPath(TreeNode* root,int expectNumber) { if(root==NULL) { return result; } temp.push_back(root-\u0026gt;val); if((expectNumber-root-\u0026gt;val)==0\u0026amp;\u0026amp;root-\u0026gt;left==NULL\u0026amp;\u0026amp;root-\u0026gt;right==NULL)//叶结点 result.push_back(temp); if(expectNumber-root-\u0026gt;val\u0026lt;0) temp.pop_back(); FindPath(root-\u0026gt;left, expectNumber-root-\u0026gt;val); FindPath(root-\u0026gt;right, expectNumber-root-\u0026gt;val); if(temp.size()\u0026gt;1) temp.pop_back();//栈回退 return result; } private: vector\u0026lt;int\u0026gt; temp; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; }; ","description":"剑指office（二十四）二叉树中和为某一值的路径","id":76,"section":"posts","tags":["剑指office"],"title":"剑指office（二十四）二叉树中和为某一值的路径","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/24%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"},{"content":"题目描述 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。（ps：我们约定空树不是二叉搜素树）\n示例1 输入 [4,8,6,12,16,14,10] 返回值 true 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: bool VerifySquenceOfBST(vector\u0026lt;int\u0026gt; sequence) { if(sequence.empty()) return false; int end = *(sequence.end()-1); bool result = true; vector\u0026lt;int\u0026gt; left; vector\u0026lt;int\u0026gt; right; vector\u0026lt;int\u0026gt;::iterator iter = sequence.begin(); for(;iter!=sequence.end()-1;iter++) if(end\u0026lt;*iter) break; vector\u0026lt;int\u0026gt;::iterator splitP = iter; for(;iter!=sequence.end()-1;iter++) if(end\u0026gt;*iter) return false; vector\u0026lt;int\u0026gt;::iterator bei = sequence.begin(); left.insert(left.end(),sequence.begin(),splitP); right.insert(right.end(),splitP,sequence.end()-1); bool leftFlag = (left.size()\u0026gt;1)?VerifySquenceOfBST(left):result; bool rightFlag = (right.size()\u0026gt;1)?VerifySquenceOfBST(right):result; return leftFlag\u0026amp;\u0026amp;rightFlag; } }; ","description":"剑指office（二十三）二叉树搜索树的后序遍历序列","id":77,"section":"posts","tags":["剑指office"],"title":"剑指office（二十三）二叉树搜索树的后序遍历序列","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/23%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"},{"content":"题目描述 从上往下打印出二叉树的每个节点，同层节点从左至右打印。\n示例1 输入 {5,4,#,3,#,2,#,1} 返回值 [5,4,3,2,1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: vector\u0026lt;int\u0026gt; PrintFromTopToBottom(TreeNode* root) { vector\u0026lt;int\u0026gt; result; if(root==NULL) return result; result.push_back(root-\u0026gt;val); PrintLeftToRight(result,root); return result; } void PrintLeftToRight(vector\u0026lt;int\u0026gt;\u0026amp;result,TreeNode* root) { if(root==NULL||root-\u0026gt;left==NULL\u0026amp;\u0026amp;root-\u0026gt;right==NULL) return; if(root-\u0026gt;left) result.push_back(root-\u0026gt;left-\u0026gt;val); if(root-\u0026gt;right) result.push_back(root-\u0026gt;right-\u0026gt;val); PrintLeftToRight(result,root-\u0026gt;left); PrintLeftToRight(result,root-\u0026gt;right); } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: vector\u0026lt;int\u0026gt; PrintFromTopToBottom(TreeNode* root) { vector\u0026lt;int\u0026gt; result; if(root==NULL) return result; queue\u0026lt;TreeNode*\u0026gt; nodeQ; nodeQ.push(root); while(!nodeQ.empty()) { TreeNode* cur = nodeQ.front(); nodeQ.pop(); result.push_back(cur-\u0026gt;val); if(cur-\u0026gt;left)nodeQ.push(cur-\u0026gt;left); if(cur-\u0026gt;right)nodeQ.push(cur-\u0026gt;right); } return result; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: vector\u0026lt;int\u0026gt; PrintFromTopToBottom(TreeNode* root) { vector\u0026lt;int\u0026gt; result; if(root==NULL) return result; queue\u0026lt;TreeNode*\u0026gt; nodeQ; nodeQ.push(root); int level = 0; while(!nodeQ.empty()) { int qS = nodeQ.size(); while(qS--) { TreeNode* cur = nodeQ.front(); nodeQ.pop(); result.push_back(cur-\u0026gt;val); if(cur-\u0026gt;left)nodeQ.push(cur-\u0026gt;left); if(cur-\u0026gt;right)nodeQ.push(cur-\u0026gt;right); } level++; } return result; } }; ","description":"剑指office（二十二）从上往下打印二叉树","id":78,"section":"posts","tags":["剑指office"],"title":"剑指office（二十二）从上往下打印二叉树","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/22%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"content":"题目描述 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）\n示例1 输入 [1,2,3,4,5],[4,3,5,1,2] 返回值 false 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class Solution { public: bool IsPopOrder(vector\u0026lt;int\u0026gt; pushV,vector\u0026lt;int\u0026gt; popV) { bool result = false; stack\u0026lt;int\u0026gt; leftS; stack\u0026lt;int\u0026gt; rightS; int pushVSize = pushV.size(); int popVSize = popV.size(); int j = 0; bool isLeft = true; for(int i = 0;i\u0026lt;pushVSize;i++) { if(pushV[i] == popV[j]) { j++; isLeft = !isLeft; }else { if(isLeft) leftS.push(pushV[i]); else rightS.push(pushV[i]); } } if(j\u0026gt;=popVSize) return true; int left = 0; int right = 0; while(j\u0026lt;popVSize) { left = leftS.empty()?NULL:leftS.top(); right = rightS.empty()?NULL:rightS.top(); if(popV[j]==left) { leftS.pop(); result = true; } else if(popV[j]==right) { rightS.pop(); result = true; } else { result = false; break; } j++; } return result; } }; ","description":"剑指office（二十一）栈的压入、弹出序列","id":79,"section":"posts","tags":["剑指office"],"title":"剑指office（二十一）栈的压入、弹出序列","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/21%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"},{"content":"题目描述 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: stack\u0026lt;int\u0026gt; v; stack\u0026lt;int\u0026gt; minV; void push(int value) { v.push(value); if(minV.empty()) minV.push(value); if(minV.top()\u0026gt;value) { minV.push(value); } } void pop() { if(v.top()==minV.top()) minV.pop(); v.pop(); } int top() { return v.top(); } int min() { return minV.top(); } }; ","description":"剑指office（二十）包含min函数的栈","id":80,"section":"posts","tags":["剑指office"],"title":"剑指office（二十）包含min函数的栈","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/20%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"},{"content":"题目描述 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.\n示例1 输入 [[1,2],[3,4]] 返回值 [1,2,4,3] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class Solution { public: vector\u0026lt;int\u0026gt; printMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; matrix) { vector\u0026lt;int\u0026gt; result; int cols = matrix[0].size(); int rows = matrix.size()-1; int startCol = 0; int startRow = 0; if(rows \u0026lt; 0 \u0026amp;\u0026amp; cols == 0) return result; if(cols==1) { for(int i= 0;i\u0026lt;=rows;i++) result.push_back(matrix[i][0]); return result; } if(rows==0) { for(int i= 0;i\u0026lt;cols;i++) result.push_back(matrix[0][i]); return result; } while(cols-startCol\u0026gt;0\u0026amp;\u0026amp;rows-startRow\u0026gt;=0) { for(int i = startCol;i\u0026lt;cols;i++) { result.push_back(matrix[startRow][i]); } for(int i = startRow+1;i\u0026lt;rows;i++) { result.push_back(matrix[i][cols-1]); } if(rows-startRow\u0026gt;0) for(int i = cols-1;i\u0026gt;=startCol;i--) { result.push_back(matrix[rows][i]); } if(cols-startCol\u0026gt;1) for(int i = rows-1;i\u0026gt;startRow;i--) { result.push_back(matrix[i][startCol]); } startCol++; startRow++; cols = cols-1; rows = rows-1; } return result; } }; ","description":"剑指office（十九）顺时针打印矩阵","id":81,"section":"posts","tags":["剑指office"],"title":"剑指office（十九）顺时针打印矩阵","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/19%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"},{"content":"题目描述 操作给定的二叉树，将其变换为源二叉树的镜像。\n比如： 源二叉树 8 / \\ 6 10 / \\ / \\ 5 7 9 11 镜像二叉树 8 / \\ 10 6 / \\ / \\ 11 9 7 5 示例1 输入 {8,6,10,5,7,9,11} 返回值 {8,10,6,11,9,7,5} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * struct TreeNode { *\tint val; *\tstruct TreeNode *left; *\tstruct TreeNode *right; *\tTreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * }; */ class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param pRoot TreeNode类 * @return TreeNode类 */ TreeNode* Mirror(TreeNode* pRoot) { // write code here if(pRoot==NULL||(pRoot-\u0026gt;left==NULL\u0026amp;\u0026amp;pRoot-\u0026gt;right==NULL)) return pRoot; swapNode(pRoot); Mirror(pRoot-\u0026gt;left); Mirror(pRoot-\u0026gt;right); return pRoot; } void swapNode(TreeNode* pRoot) { TreeNode* tempVal = pRoot-\u0026gt;left; pRoot-\u0026gt;left = pRoot-\u0026gt;right; pRoot-\u0026gt;right = tempVal; } }; ","description":"剑指office（十八）二叉树的镜像","id":82,"section":"posts","tags":["剑指office"],"title":"剑指office（十八）二叉树的镜像","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/18%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"},{"content":"题目描述 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）\n示例1 输入 {8,8,#,9,#,2,#,5},{8,9,#,2} 返回值 true 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) { bool result = false; if(pRoot1!=NULL\u0026amp;\u0026amp;pRoot2!=NULL) { if(pRoot1-\u0026gt;val==pRoot2-\u0026gt;val) result = isSame(pRoot1,pRoot2); if(!result) result = HasSubtree(pRoot1-\u0026gt;left, pRoot2); if(!result) result = HasSubtree(pRoot1-\u0026gt;right, pRoot2); } return result; } bool isSame(TreeNode* pRoot1,TreeNode* pRoot2) { if(pRoot2==NULL) return true; if(pRoot1==NULL) return false; if(pRoot1-\u0026gt;val!=pRoot2-\u0026gt;val) return false; else return isSame(pRoot1-\u0026gt;left, pRoot2-\u0026gt;left)\u0026amp;\u0026amp;isSame(pRoot1-\u0026gt;right, pRoot2-\u0026gt;right); } }; ","description":"剑指office（十七）树的子结构","id":83,"section":"posts","tags":["剑指office"],"title":"剑指office（十七）树的子结构","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/17%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"},{"content":"题目描述 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。\n示例1 输入 {1,3,5},{2,4,6} 返回值 {1,2,3,4,5,6} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) { ListNode* result = NULL; ListNode* cur = NULL; if(!pHead1) return pHead2; if(!pHead2) return pHead1; while(pHead1||pHead2) { if(pHead1\u0026amp;\u0026amp;pHead2) { if(pHead1-\u0026gt;val\u0026gt;=pHead2-\u0026gt;val) { ListNode* temp = pHead2-\u0026gt;next; if(!result) { result = pHead2; cur = result; } else { result-\u0026gt;next = pHead2; result = result-\u0026gt;next; } pHead2 = temp; } else { ListNode* temp = pHead1-\u0026gt;next; if(!result) { result = pHead1; cur = result; } else { result-\u0026gt;next = pHead1; result = result-\u0026gt;next; } pHead1 = temp; } } else { if(pHead1) { result-\u0026gt;next = pHead1; } else { result-\u0026gt;next = pHead2; } break; } } return cur; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) { ListNode* result = new ListNode(-1); ListNode* cur = result; if(!pHead1) return pHead2; if(!pHead2) return pHead1; while(pHead1||pHead2) { if(pHead1\u0026amp;\u0026amp;pHead2) { if(pHead1-\u0026gt;val\u0026gt;=pHead2-\u0026gt;val) { result-\u0026gt;next = pHead2; pHead2 = pHead2-\u0026gt;next; } else { result-\u0026gt;next = pHead1; pHead1 = pHead1-\u0026gt;next; } result = result-\u0026gt;next; } else { result-\u0026gt;next = pHead1?pHead1:pHead2; break; } } return cur-\u0026gt;next; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) { if(!pHead1) return pHead2; if(!pHead2) return pHead1; if(pHead1-\u0026gt;val\u0026gt;=pHead2-\u0026gt;val) { pHead2-\u0026gt;next = Merge(pHead1,pHead2-\u0026gt;next); return pHead2; }else { pHead1-\u0026gt;next = Merge(pHead1-\u0026gt;next, pHead2); return pHead1; } } }; ","description":"剑指office（十六）合并两个排序的链表","id":84,"section":"posts","tags":["剑指office"],"title":"剑指office（十六）合并两个排序的链表","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/16%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"},{"content":"题目描述 输入一个链表，反转链表后，输出新链表的表头。\n示例1 输入 {1,2,3} 返回值 {3,2,1} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* ReverseList(ListNode* pHead) { if (!pHead) return NULL; stack\u0026lt;ListNode*\u0026gt; stackNode; while(pHead) { stackNode.push(pHead); pHead = pHead-\u0026gt;next; } ListNode* result = stackNode.top(); stackNode.pop(); ListNode* cur = result; int S = stackNode.size(); for(int i = 0;i\u0026lt;S;i++) { cur-\u0026gt;next = stackNode.top(); stackNode.pop(); cur = cur-\u0026gt;next; } cur-\u0026gt;next = NULL; return result; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* ReverseList(ListNode* pHead) { ListNode* nextNode = NULL; ListNode* currentNode = pHead; ListNode* reverseNode = NULL; while(currentNode) { nextNode = currentNode-\u0026gt;next; currentNode-\u0026gt;next = reverseNode; reverseNode = currentNode; currentNode = nextNode; } return reverseNode; } }; ","description":"剑指office（十五）反转链表","id":85,"section":"posts","tags":["剑指office"],"title":"剑指office（十五）反转链表","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/15%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"content":"题目描述 输入一个链表，输出该链表中倒数第k个结点。\n如果该链表长度小于k，请返回空。\n示例1 输入 {1,2,3,4,5},1 返回值 {5} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** * struct ListNode { *\tint val; *\tstruct ListNode *next; *\tListNode(int x) : val(x), next(nullptr) {} * }; */ class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param pHead ListNode类 * @param k int整型 * @return ListNode类 */ ListNode* FindKthToTail(ListNode* pHead, int k) { // write code here ListNode *result = pHead; while(pHead\u0026amp;\u0026amp;k--) { pHead = pHead-\u0026gt;next; } if(k\u0026gt;0) return NULL; while(pHead) { pHead = pHead-\u0026gt;next; result = result-\u0026gt;next; } return result; } }; ","description":"剑指office（十四）链表中倒数第k个结点","id":86,"section":"posts","tags":["剑指office"],"title":"剑指office（十四）链表中倒数第k个结点","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/14%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/"},{"content":"题目描述 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。\n示例1 输入 [1,2,3,4] 返回值 [1,3,2,4] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param array int整型vector * @return int整型vector */ vector\u0026lt;int\u0026gt; reOrderArray(vector\u0026lt;int\u0026gt;\u0026amp; array) { // write code here for(int i=0;i\u0026lt;array.size();i++) { if(array[i]\u0026amp;1) { int j = i; if(j\u0026gt;0) while(!(array[j-1]\u0026amp;1)) { swap(array[j],array[j-1]); j--; if(j==0) break; } } } return array; } }; ","description":"剑指office（十三）调整数组顺序使奇数位于偶数前面","id":87,"section":"posts","tags":["剑指office"],"title":"剑指office（十三）调整数组顺序使奇数位于偶数前面","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/13%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"},{"content":"题目描述 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。\n保证base和exponent不同时为0。不得使用库函数，同时不需要考虑大数问题，也不用考虑小数点后面0的位数。\n示例1 输入 2.00000,3 返回值 8.00000 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: double Power(double base, int exponent) { if(exponent == 0) return 1.0; else { double result = 1; for(int i= 0;i\u0026lt;abs(exponent);i++) result *= base; if(exponent \u0026gt; 0) return result; else return 1/result; } } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: double Power(double base,int exponent) { if(exponent\u0026lt;0) { exponent = -exponent; base = 1/base; } return q_power(base,exponent); } double q_power(double base, int exponent) { if(exponent == 0) return 1.0; else { double result = q_power(base, exponent/2); if(exponent\u0026amp;1) { return result*result*base; } else { return result * result; } } } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: double Power(double base,int exponent) { if(exponent\u0026lt;0) { exponent = -exponent; base = 1/base; } return q_power(base,exponent); } double q_power(double base,int exponent) { double result = 1; while(exponent) { if(exponent\u0026amp;1) { result *= base; } base *= base; exponent\u0026gt;\u0026gt;=1; } return result; } }; ","description":"剑指office（十二）数值的整数次方","id":88,"section":"posts","tags":["剑指office"],"title":"剑指office（十二）数值的整数次方","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/12%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"},{"content":"题目描述 输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。\n示例1 输入 10 返回值 2 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int NumberOf1(int n) { int cout = 0; int mark = 0x01; while(mark) { if(mark\u0026amp;n)cout++; mark\u0026lt;\u0026lt;=1; } return cout; } }; 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: int NumberOf1(int n) { int count = 0; while(n) { count++; n = (n-1)\u0026amp;n; } return count; } }; ","description":"剑指office（十一）二进制中1的个数","id":89,"section":"posts","tags":["剑指office"],"title":"剑指office（十一）二进制中1的个数","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/11%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"content":"题目描述 我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？\n比如n=3时，2*3的矩形块有3种覆盖方法：\n示例1 输入 4 返回值 5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int rectCover(int number) { if(number\u0026lt;=2) return number; int first = 1; int second = 2; int result = 0; for(int i = 3;i\u0026lt;=number;i++) { result = first + second; first = second; second = result; } return result; } }; ","description":"剑指office（十）矩形覆盖","id":90,"section":"posts","tags":["剑指office"],"title":"剑指office（十）矩形覆盖","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/10%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/"},{"content":"题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。\n示例1 输入 3 返回值 4 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int jumpFloorII(int number) { if(number\u0026lt;2) return 1; int result = 1; for(int i = 1;i\u0026lt;number;i++) { result *= 2; } return result; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int jumpFloorII(int number) { if(number\u0026lt;2) return 1; vector\u0026lt;int\u0026gt; dp(number+1,0); dp[0]=dp[1]=1; for(int i = 2;i\u0026lt;=number;i++) { for(int j=0;j\u0026lt;i;j++) { dp[i] += dp[j]; } } return dp[number]; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int jumpFloorII(int number) { if(number\u0026lt;2) return 1; int result = 1; for(int i=2;i\u0026lt;=number;i++) { result = result\u0026lt;\u0026lt;1;//左移乘 右移除 } return result; } }; ","description":"剑指office（九）跳台阶扩展问题","id":91,"section":"posts","tags":["剑指office"],"title":"剑指office（九）跳台阶扩展问题","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/9%E8%B7%B3%E5%8F%B0%E9%98%B6%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98/"},{"content":"题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int jumpFloor(int number) { if(number\u0026lt;=2) return number; int first = 1; int second = 2; int result = 0; for(int i = 2;i\u0026lt;number;i++) { result = first + second; first = second; second = result; } return result; } }; ","description":"剑指office（八）跳台阶","id":92,"section":"posts","tags":["剑指office"],"title":"剑指office（八）跳台阶","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/8%E8%B7%B3%E5%8F%B0%E9%98%B6/"},{"content":"题目描述 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。\nn≤39n≤39\n示例1 输入 4 返回值 3 1 2 3 4 5 6 7 8 class Solution { public: int Fibonacci(int n) { if(n\u0026lt;2) return n; return Fibonacci(n-1)+Fibonacci(n-2); } }; ","description":"剑指office（七）用两个栈实现队列","id":93,"section":"posts","tags":["剑指office"],"title":"剑指office（七）用两个栈实现队列","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/7%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"},{"content":"题目描述 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。\n输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。\nNOTE：给出的所有元素都大于0，若数组大小为0，请返回0。\n示例1 输入 [3,4,5,1,2] 返回值 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int minNumberInRotateArray(vector\u0026lt;int\u0026gt; rotateArray) { if(rotateArray.size()==0) return 0; int first = 0; int last = rotateArray.size()-1; int mid = 0; while(last!=first) { mid = floor((first + last)/2); if(rotateArray[last]\u0026gt;rotateArray[mid]) last = mid; else if(rotateArray[first]\u0026lt;rotateArray[mid]) first = mid+1; else first++; } return rotateArray[last]; } }; ","description":"剑指office（六）用两个栈实现队列","id":94,"section":"posts","tags":["剑指office"],"title":"剑指office（六）用两个栈实现队列","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/6%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"},{"content":"题目描述 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: void push(int node) { stack1.push(node); } int pop() { if(stack2.empty()\u0026amp;\u0026amp;!stack1.empty()) { int stackS = stack1.size(); for(int i =0;i\u0026lt;stackS;i++) { int temp = stack1.top(); stack1.pop(); stack2.push(temp); } } int val = stack2.top(); stack2.pop(); return val; } private: stack\u0026lt;int\u0026gt; stack1; stack\u0026lt;int\u0026gt; stack2; }; ","description":"剑指office（五）用两个栈实现队列","id":95,"section":"posts","tags":["剑指office"],"title":"剑指office（五）用两个栈实现队列","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/5%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"},{"content":"题目描述 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。\n示例1 输入 [1,2,3,4,5,6,7],[3,2,4,1,6,5,7] 返回值 {1,2,5,3,4,6,7} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /** * Definition for binary tree * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* reConstructBinaryTree(vector\u0026lt;int\u0026gt; pre,vector\u0026lt;int\u0026gt; vin) { if(pre.size() == 0) {//如果为空，返回NULL return NULL; } TreeNode* tempNode = new TreeNode(pre[0]); int root = pre[0]; vector\u0026lt;int\u0026gt;leftPre; vector\u0026lt;int\u0026gt;leftVin; vector\u0026lt;int\u0026gt;rightPre; vector\u0026lt;int\u0026gt;rightVin; bool leftFlag = true; int j = 1; for(int i = 0;i\u0026lt;vin.size();i++) { if(root == vin[i]) { leftFlag = false; continue; } if(leftFlag) { leftPre.push_back(pre[j]); leftVin.push_back(vin[i]); j++; } else { rightPre.push_back(pre[j]); rightVin.push_back(vin[i]); j++; } } tempNode-\u0026gt;left = reConstructBinaryTree(leftPre,leftVin); tempNode-\u0026gt;right = reConstructBinaryTree(rightPre,rightVin); return tempNode; } }; ","description":"剑指office（四）重建二叉树","id":96,"section":"posts","tags":["剑指office"],"title":"剑指office（四）重建二叉树","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/4%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"content":"题目描述 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。\n示例1 输入 {67,0,24,58} 返回值 [58,24,0,67] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /** * struct ListNode { * int val; * struct ListNode *next; * ListNode(int x) : * val(x), next(NULL) { * } * }; */ class Solution { public: vector\u0026lt;int\u0026gt; printListFromTailToHead(ListNode* head) { stack\u0026lt;int\u0026gt; temp; while(head!=NULL) { temp.push(head-\u0026gt;val); head = head-\u0026gt;next; } vector\u0026lt;int\u0026gt; result; int tempS = temp.size(); for(int i = 0;i\u0026lt;tempS;i++) { result.push_back(temp.top()); temp.pop(); } return result; } }; ","description":"剑指office（三）从尾到头打印链表","id":97,"section":"posts","tags":["剑指office"],"title":"剑指office（三）从尾到头打印链表","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/3%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"},{"content":"OneDriveUploader - Written in GoLang 支持 国际版, 个人版(家庭版), 中国版(世纪互联). 支持上传文件和文件夹到指定目录,并保持上传前的目录结构. 支持命令参数使用, 方便外部程序调用. 支持自定义上传分块大小. 支持多线程上传(多文件同时上传). 支持根据文件大小动态调整重试次数 支持跳过网盘中已存在的同名文件. 授权 通过下面URL登录 (右键新标签打开) 国际版, 个人版(家庭版) https://login.microsoftonline.com/common/oauth2/v2.0/authorize?client_id=78d4dc35-7e46-42c6-9023-2d39314433a5\u0026amp;response_type=code\u0026amp;redirect_uri=http://localhost/onedrive-login\u0026amp;response_mode=query\u0026amp;scope=offline_access%20User.Read%20Files.ReadWrite.All\n中国版(世纪互联) https://login.chinacloudapi.cn/common/oauth2/v2.0/authorize?client_id=dfe36e60-6133-48cf-869f-4d15b8354769\u0026amp;response_type=code\u0026amp;redirect_uri=http://localhost/onedrive-login\u0026amp;response_mode=query\u0026amp;scope=offline_access%20User.Read%20Files.ReadWrite.All\n初始化配置文件 # 国际版 OneDriveUploader -a \u0026#34;url\u0026#34; # 个人版(家庭版) OneDriveUploader -ms -a \u0026#34;url\u0026#34; # 中国版(世纪互联) OneDriveUploader -cn -a \u0026#34;url\u0026#34; # 在浏览器地址栏中获取以 http://loaclhost 开头的整个url内容 # 将获取的完整url内容替换命令中的 url 三个字母 # 每次产生的 url 只能用一次, 重试请重新获取 url # 此操作将会自动初始化的配置文件 # 提示 Init config file: \u0026#39;/path/to/auth.json\u0026#39; 则成功 使用 Usage of OneDriveUploader: -a string // 初始化授权 Setup and Init auth.json. -b string // 自定义上传分块大小, 可以提高网络吞吐量, 受限于磁盘性能和网络速度. Set block size. [Unit: M; 5\u0026lt;=b\u0026lt;=60;] (default \u0026#34;10\u0026#34;) -c string // 配置文件路径 Config file. (default \u0026#34;auth.json\u0026#34;) -n string // 上传单个文件时,在网盘中重命名 Rename file on upload to remote. -r string // 上传到网盘中的某个目录, 默认: 根目录 Upload to reomte path. -s string // *必要参数, 要上传的文件或文件夹 Upload item. -t string // 线程数, 同时上传文件的个数. 默认: 2 Set thread num. (default \u0026#34;2\u0026#34;) -f // 开关(推荐) // 加上 -f 参数，强制读取 auth.json 中的块大小配置和多线程配置. // 不加 -f 参数, 每次覆盖保存当前使用参数到 auth.json 配置文件中. Force Read config form config file. [BlockSize, ThreadNum] -skip // 开关 // 跳过上传网盘中已存在的同名文件. (默认不跳过) Skip exist file on remote. -cn // 开关 // 授权中国版(世纪互联), 需要此参数. OneDrive by 21Vianet. -ms // 开关 // 授权个人版(家庭版), 需要此参数. OneDrive by Microsoft. 配置 { // 授权令牌 \u0026#34;RefreshToken\u0026#34;: \u0026#34;1234564567890ABCDEF\u0026#34;, // 最大线程数.(同时上传文件的数量) \u0026#34;ThreadNum\u0026#34;: \u0026#34;2\u0026#34;, // 最大上传分块大小.(每次上传文件的最大分块大小,网络不好建议调低. 单位:MB) \u0026#34;BlockSize\u0026#34;: \u0026#34;10\u0026#34;, // 最大单文件大小.(目前: 个人版(家庭版)单文件限制为100GB; 其他版本单文件限制为15GB,微软将逐步更新为100GB. 单位:GB) \u0026#34;SigleFile\u0026#34;: \u0026#34;100\u0026#34;, // 缓存刷新间隔. \u0026#34;RefreshInterval\u0026#34;: 1500, // 如果是中国版(世纪互联), 此项应为 true. \u0026#34;MainLand\u0026#34;: false, // 如果是家庭版或者个人免费版, 此项应为 true. \u0026#34;MSAccount\u0026#34;: true } 示例 # 一些示例: # 将同目录下的 mm00.jpg 文件上传到 OneDrive 网盘根目录 OneDriveUploader -s \u0026#34;mm00.jpg\u0026#34; # 将同目录下的 mm00.jpg 文件上传到 OneDrive 网盘根目录,并改名为 mm01.jpg OneDriveUploader -s \u0026#34;mm00.jpg\u0026#34; -n \u0026#34;mm01.jpg\u0026#34; # 将同目录下的 Download 文件夹上传到 OneDrive 网盘根目录 OneDriveUploader -s \u0026#34;Download\u0026#34; # 将同目录下的 Download 文件夹上传到 OneDrive 网盘Test目录中 OneDriveUploader -s \u0026#34;Download\u0026#34; -r \u0026#34;Test\u0026#34; # 将同目录下的 Download 文件夹上传到 OneDrive 网盘Test目录中, 使用 10 线程 OneDriveUploader -t 10 -s \u0026#34;Download\u0026#34; -r \u0026#34;Test\u0026#34; # 将同目录下的 Download 文件夹上传到 OneDrive 网盘Test目录中, 使用 15 线程, 并设置分块大小为 20M OneDriveUploader -t 15 -b 20 -s \u0026#34;Download\u0026#34; -r \u0026#34;Test\u0026#34; # 将同目录下的 Download 文件夹上传到 OneDrive 网盘Test目录中, 使用配置文件中的线程参数和分块大小参数 OneDriveUploader -f -c \u0026#34;/urs/local/auth.json\u0026#34; -s \u0026#34;Download\u0026#34; -r \u0026#34;Test\u0026#34; # 将同目录下的 Download 文件夹上传到 OneDrive 网盘Test目录中, 使用配置文件中的线程参数和分块大小参数，并跳过上传网盘中已存在的同名文件 OneDriveUploader -f -c \u0026#34;/urs/local/auth.json\u0026#34; -skip -s \u0026#34;Download\u0026#34; -r \u0026#34;Test\u0026#34; 注意 多次尝试后, 无失败的上传文件. 退出码为 0 . 最终还有失败的上传文件会详细列出上传失败项. 退出码为 1. Client/Secret (~ 2299/12/31) # 国际版: 78d4dc35-7e46-42c6-9023-2d39314433a5| ZudGl-p.m=LMmr3VrKgAyOf-WevB3p50 # 中国版: dfe36e60-6133-48cf-869f-4d15b8354769| H0-1:6.Sb8:WCW/J-c]K@fddCt[i0EZ2 ","description":"","id":98,"section":"posts","tags":["onedrive"],"title":"OneDriveUploader使用","uri":"https://popo-blog.vercel.app/posts/onedriveuploader%E4%BD%BF%E7%94%A8/"},{"content":"题目描述 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。\n示例1 输入 \u0026#34;We Are Happy\u0026#34; 返回值 \u0026#34;We%20Are%20Happy\u0026#34; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param s string字符串 * @return string字符串 */ string replaceSpace(string s) { for(int i = 0;i\u0026lt;s.size();i++) { if(s[i]==\u0026#39; \u0026#39;) { s = s.replace(i,1,\u0026#34;%20\u0026#34;); } } return s; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param s string字符串 * @return string字符串 */ string replaceSpace(string s) { string newS; for(int i = 0;i\u0026lt;s.size();i++) { if(s[i]==\u0026#39; \u0026#39;) { newS +=\u0026#34;%20\u0026#34;; }else { newS +=s[i]; } } return newS; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param s string字符串 * @return string字符串 */ string replaceSpace(string s) { int sSize = s.size(); int spaceNum = 0; for(int i = 0;i\u0026lt;sSize;i++) { if(s[i]==\u0026#39; \u0026#39;) { spaceNum++; } } int newLen = spaceNum*2 + sSize; int newI = 0; string newS(newLen,\u0026#39; \u0026#39;); for(int i = sSize - 1,newI = newLen-1;i\u0026gt;=0;i--,newI--) { if(s[i]==\u0026#39; \u0026#39;) { newS[newI] = \u0026#39;0\u0026#39;; newI = newI-1; newS[newI] = \u0026#39;2\u0026#39;; newI = newI -1; newS[newI] = \u0026#39;%\u0026#39;; } else { newS[newI] = s[i]; } } return newS; } }; ","description":"剑指office（二）替换空格","id":99,"section":"posts","tags":["剑指office"],"title":"剑指office（二）替换空格","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/2%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"},{"content":" 1 2 3 4 5 6 7 8 9 10 in:name example 名字中有“example” in:readme example readme中有“example” in:description example 描述中有“example” stars:\u0026gt;1000 star\u0026gt;1000 forks:\u0026gt;1000 fork\u0026gt;1000 pushed:\u0026gt;2019-09-01 2019年9月1日后有更新的 language:java 用Java编写的项目 更多打开：https://help.github.com/en/github/searching-for-information-on-github/searching-for-repositories ","description":"","id":100,"section":"posts","tags":["github高级搜索"],"title":"Github高级搜索","uri":"https://popo-blog.vercel.app/posts/github/github%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2/"},{"content":"上传文件 1 2 3 4 5 6 7 8 pscp -r newlivedowload root@139.9.116.41:live_download nethogs eth0 ls -lh df -l ps -aux|grep get.py| grep -v grep nohup 运行文件\u0026gt;\u0026gt; output.log 2\u0026gt;\u0026amp;1 \u0026amp; nohup python3 -u main.py \u0026gt; test.out 2\u0026gt;\u0026amp;1 \u0026amp; 限制网速 git clone https://github.com/magnific0/wondershaper.git 在确定网卡名称以后，就可以按照以下的命令限制网络带宽：\nsudo wondershaper -a \u0026lt;adapter\u0026gt; -d \u0026lt;rate\u0026gt; -u \u0026lt;rate\u0026gt; 例如，如果网卡名称是 enp0s8，并且需要把上行、下行速率分别限制为 1024 Kbps 和 512 Kbps，就可以执行以下命令：\nsudo wondershaper -a eth0 -d 1024 -u 512 其中参数的含义是：\n-a：网卡名称\n-d：下行带宽\n-u：上行带宽\n如果要对网卡解除网络带宽的限制，只需要执行：\n./wondershaper -a eth0 -c 后台运行 可以先执行：screen -S zgy ，screen就会创建一个名字为zgy的会话\n运行代码 当需要临时离开时（会话中的程序不会关闭，仍在运行）可以用快捷键Ctrl+a d(即按住Ctrl，依次再按a,d)\n当回来时可以再执行执行：screen -r zgy 即可恢复到离开前创建的zgy会话的工作界面。\nscreen -ls screen会列出当前存在的会话列表 恢复会话： screen -r zgy或screen -r pid 退出会话 执行：exit ，会提示：[screen is terminating]，表示已经成功退出screen会话。\n常用快捷键 kill 掉一个窗口\nscreen -X -S 4588 quit\nCtrl+a c ：在当前screen会话中创建窗口\nCtrl+a w ：窗口列表\nCtrl+a n ：下一个窗口\nCtrl+a p ：上一个窗口\nCtrl+a 0-9 ：在第0个窗口和第9个窗口之间切换\n","description":"","id":101,"section":"posts","tags":["服务器"],"title":"服务器命令行","uri":"https://popo-blog.vercel.app/posts/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"content":"题目描述 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n[\n[1,2,8,9],\n[2,4,9,12],\n[4,7,10,13],\n[6,8,11,15]\n]\n给定 target = 7，返回 true。\n给定 target = 3，返回 false。\n示例1 输入 7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]] 返回值 true 说明 存在7，返回true 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: bool Find(int target, vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; array) { int cowS = array.size(); int rowS = array[0].size(); int cow = 0; //行 int row = rowS - 1; while(cow\u0026lt;cowS\u0026amp;\u0026amp;row\u0026gt;=0) { int val = array[cow][row]; if(val == target) return true; else if(target\u0026lt;val) row--; else cow++; } return false; } }; ","description":"剑指office（一）二维数组查找","id":102,"section":"posts","tags":["剑指office"],"title":"剑指office（一）二维数组查找","uri":"https://popo-blog.vercel.app/posts/%E5%89%91%E6%8C%87offer/1%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":104,"section":"gallery","tags":null,"title":"图片","uri":"https://popo-blog.vercel.app/gallery/photo/"},{"content":"算法\n囫囵吞枣\n背八股文\n面试总结\nhttps://jable.tv/members/9/favourites/videos/?mode=async\u0026amp;function=get_block\u0026amp;block_id=list_videos_favourite_videos\u0026amp;fav_type=0\u0026amp;playlist_id=0\u0026amp;sort_by=\u0026amp;from_fav_videos=01\n1 pip install jsonfield -i http://pypi.douban.com/simple --trusted-host pypi.douban.com TP-LINK_CCF0\n5cR3e6e7+\nTP-LINK_5G_CCF0\n5cR3e6e7+\n192.168.1.2\n255.255.255.0\n192.168.1.3\n192.168.1.3\ndocker run -itd --name=openwrt --restart=always --network=openwrt --privileged=true kiddin9_openwrt /sbin/init sed -i \u0026#39;s/10.0.0.1/192.168.123.2/\u0026#39; /etc/config/network \u0026amp;\u0026amp; /etc/init.d/network restart docker run -d --name=\u0026#34;openwrt\u0026#34; --restart unless-stopped --network macnet --ip 192.168.123.2 yifan237/onecloud-openwrt:02.21 /sbin/init 1 docker network create -d macvlan --subnet=192.168.123.0/24 --gateway=192.168.123.1 -o parent=eth0 macnet deb https://mirrors.ustc.edu.cn/debian/ bullseye main non-free contrib deb-src https://mirrors.ustc.edu.cn/debian/ bullseye main non-free contrib deb https://mirrors.ustc.edu.cn/debian-security/ bullseye-security main deb-src https://mirrors.ustc.edu.cn/debian-security/ bullseye-security main deb https://mirrors.ustc.edu.cn/debian/ bullseye-updates main non-free contrib deb-src https://mirrors.ustc.edu.cn/debian/ bullseye-updates main non-free contrib deb https://mirrors.ustc.edu.cn/debian/ bullseye-backports main non-free contrib deb-src https://mirrors.ustc.edu.cn/debian/ bullseye-backports main non-free contrib docker network create -d macvlan --subnet=192.168.123.0/24 --gateway=192.168.123.1 -o parent=eth0 macnet ip addr del 192.168.123.176/24 dev eth0; \\ ip link add macvlan link eth0 type macvlan mode bridge; \\ ip addr add 192.168.123.176/24 dev macvlan; \\ ip link set macvlan up; \\ ip route del 192.168.123.0/24 dev eth0; \\ ip route del default; \\ ip route add 192.168.123.0/24 dev macvlan; \\ ip route add default via 192.168.123.2 dev macvlan; docker run -itd --name=openwrt --restart=always --network=macnet --privileged=true kiddin9_openwrt /sbin/init docker container update --restart=no 容器id docker run -it --name samba -p 139:139 -p 445:445 -v /mydisk/movie:/mount -d dperson/samba -u \u0026#34;1;1\u0026#34; -s \u0026#34;movie;/mount/;yes;no;yes;all;all;all\u0026#34; docker run -d \\ --name aria2-pro \\ --restart unless-stopped \\ --log-opt max-size=1m \\ --network host \\ -e PUID=$UID \\ -e PGID=$GID \\ -e RPC_SECRET=525027 \\ -e RPC_PORT=6800 \\ -e LISTEN_PORT=6888 \\ -v /root/aria2/aria2-config:/config \\ -v /mydisk/movie:/downloads \\ p3terx/aria2-pro docker exec -it openwrt sh docker run -d \\ --name=aliyundrive-webdav \\ --restart=always \\ -p 6060:8080 \\ -v /root/aliyundrive-webdav/:/etc/aliyundrive-webdav/ \\ -e REFRESH_TOKEN=2058cd10befc484c97dc87c2bd434d05 \\ -e WEBDAV_AUTH_USER=popo \\ -e WEBDAV_AUTH_PASSWORD=525027 \\ messense/aliyundrive-webdav ","description":"","id":116,"section":"posts","tags":null,"title":"","uri":"https://popo-blog.vercel.app/posts/%E6%9D%82%E8%AE%A1/"}]