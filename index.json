[{"content":"题目描述 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy\n方法1 //需要头文件： \t#include\u0026lt;iostream\u0026gt;\t#include\u0026lt;stdlib.h\u0026gt;\t#include\u0026lt;string\u0026gt; void replaceSpace(char* str, int length) { int count = 0; for (int i = 0; i \u0026lt; length; i++) { if (str[i] == \u0026#39; \u0026#39;) count++; } int new_length = length + 2 * count; int j = length-1; for (int i = new_length-1; i \u0026gt;= 0;) { if (str[j] == \u0026#39; \u0026#39;) { str[i--] = \u0026#39;0\u0026#39;; str[i--] = \u0026#39;2\u0026#39;; str[i--] = \u0026#39;%\u0026#39;; } else { str[i--] = str[j]; } j--; } } 方法2 void replaceSpace2(char* str, int length) { int i = 0; int numSpace = 0; while (str[i] != \u0026#39;\\0\u0026#39;) { if (str[i] == \u0026#39; \u0026#39;) numSpace++; ++i; } int newLen = i + numSpace * 2; if (newLen \u0026gt; length) return; for (int j = i; j \u0026gt;= 0, newLen \u0026gt;= 0;) { if (str[j] == \u0026#39; \u0026#39;) { str[newLen--] = \u0026#39;0\u0026#39;; str[newLen--] = \u0026#39;2\u0026#39;; str[newLen--] = \u0026#39;%\u0026#39;; } else str[newLen--] = str[j]; j--; } } 方法3 #pragma warning(disable:4996) \tvoid replaceSpace3(char* str, int length) { string s = str; for (int i = 0; i \u0026lt; s.size(); ++i) { if (s[i] == \u0026#39; \u0026#39;) { s.replace(i, 2, \u0026#34;%20\u0026#34;); } } str = new char[s.size()]; strcpy(str,s.c_str()); cout \u0026lt;\u0026lt; str; } ","permalink":"https://yslinwe.github.io/%E5%8D%9A%E6%96%87/%E5%89%91%E6%8C%87office%E4%BA%8C%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/","summary":"剑指office（二）替换空格","title":"剑指office（二）替换空格"},{"content":"题目描述 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n方法1 //时间过长不能通过。  bool Find(int target, vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; array) { int col = 0, row = 0; row = array.size(); col = array[0].size(); int up = 0, down = row - 1; int right = col - 1, left = 0; while (left \u0026lt; col-1\u0026amp;\u0026amp;right \u0026gt; 0\u0026amp;\u0026amp;down+1 \u0026gt; 0\u0026amp;\u0026amp;up \u0026lt; row-1) { int left_temp = left; int rl_mid = (right + left) / 2; cout \u0026lt;\u0026lt; \u0026#34;rl_mid=\u0026#34; \u0026lt;\u0026lt; rl_mid \u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;\u0026#34;right=\u0026#34;\u0026lt;\u0026lt;right\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;\u0026#34;left=\u0026#34;\u0026lt;\u0026lt; left\u0026lt;\u0026lt; endl; int rl_val = array[up][rl_mid]; if (target == rl_val) return true; else if (target \u0026lt; rl_val) right = rl_mid - 1; else left = rl_mid + 1; int ud_mid = (up + down) / 2; cout \u0026lt;\u0026lt; \u0026#34;ud_mid=\u0026#34; \u0026lt;\u0026lt; ud_mid \u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt; \u0026#34;up=\u0026#34;\u0026lt;\u0026lt;up\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;\u0026#34;down=\u0026#34;\u0026lt;\u0026lt;down \u0026lt;\u0026lt;endl; int ud_val = array[ud_mid][left_temp]; if (target == ud_val) return true; else if (target \u0026lt; ud_val) down = ud_mid - 1; else up = ud_mid + 1; } return false; } 方法2 bool Find2(int target, vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; array) { int rows = array.size(); int cols = array[0].size(); if (!array.empty() \u0026amp;\u0026amp; rows \u0026gt; 0 \u0026amp;\u0026amp; cols \u0026gt; 0) { int row = 0; int col = cols - 1; while (row \u0026lt; rows \u0026amp;\u0026amp; col \u0026gt;= 0) { if (array[row][col] == target) { return true; } else if (array[row][col] \u0026gt; target) { --col; } else { ++row; } } } return false; } 方法3 bool Find3(int target, vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; array) { int rows = array.size(); int cols = array[0].size(); int row = 0; int col = cols - 1; while(!array.empty() \u0026amp;\u0026amp; col \u0026gt; 0 \u0026amp;\u0026amp; row \u0026lt; rows) { if (array[row][col] == target) return true; else if (array[row][col] \u0026lt; target) row++; else col--; } return false; } ","permalink":"https://yslinwe.github.io/%E5%8D%9A%E6%96%87/%E5%89%91%E6%8C%87office%E4%B8%80%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE/","summary":"剑指office（一）二维数组查找","title":"剑指office（一）二维数组查找"},{"content":"数据结构笔记 顺序栈和顺序队列使用动态数组实现 以下不是C++中stack的实现\n顺序栈 特点：后进先出，先进后出 栈可以用数组或者链表写 开始时，栈顶Top=-1\n顺序栈操作 Push（栈顶添加元素） Top（返回当前栈顶数据） Pop （删除栈顶数据） IsEmpty（检查栈是否为空）\n数组实现 实现自动扩大数组大小 模板类实现和声明要写在一起 template\u0026lt;class T\u0026gt; void ChangeSize1D(T* \u0026amp;a,const int oldSize, const int newSize) { if(newSize\u0026lt;0) throw \u0026#34;newSize must be \u0026gt;=0\u0026#34;; T* temp =new T[newSize]; int number = min(oldSize,newSize); std::copy(a,a+number,temp); delete[] a; a=temp; } 顺序队列（Queue） 特点：先进先出，后进后出\n队列操作  Push（队尾添加元素） Pop （队首删除元素） Front（返回当前队首数据） Rear（返回当前队尾数据） IsEmpty（检查队列是否为空）  实现回绕（利用数组删除后留下的空间）  rear=front front++ 如果front=rear表示队列满了，要自动扩大数组大小  链表  链表：1.数据域 2.链接域 数组缺点：插入数据时慢，需要向后移动，删除数据时，需要向前移动。 链表可以弥补这些缺点。  树  数组缺点：插入数据，数据要移动。 数组优点：二分查找 链表缺点：无法二分查找 链表优点: 插入删除数据快 树 = 数组的优点 + 链表的优点  ","permalink":"https://yslinwe.github.io/%E5%8D%9A%E6%96%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/","summary":"数据结构学习","title":"数据结构学习"},{"content":"git回退到上个版本 git reset --hard HEAD^ 回退到前3次提交之前，以此类推，回退到n次提交之前 git reset --hard HEAD~3 查看commit的sha码 git log git show dde8c25694f34acf8971f0782b1a676f39bf0a46 退到/进到 指定commit的sha码 git reset --hard dde8c25694f34acf8971f0782b1a676f39bf0a46 强推到远程 git push origin HEAD --force 把git add添加进去的文件撤销添加 git reset HEAD 相对路径名\ngit reset HEAD public/uploads/ git练习地址: https://learngitbranching.js.org/?locale=en_US\n","permalink":"https://yslinwe.github.io/%E5%8D%9A%E6%96%87/git%E5%9B%9E%E9%80%80%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%89%88%E6%9C%AC/","summary":"git回退上一个版本","title":"git回退上一个版本"},{"content":"创建repo repo名称为\u0026lt;username\u0026gt;.github.io  设置github actions自动部署 将博客源码放到一个private repo 或者 public repo 中， 创建一个blogSite分支。 blogSite分支，用于存放博客源码 master分支，用于存放博客网页代码\n需要获取一个personal_token或者deploy_key来获取repo的权限，这里选择personal_token的方式，这种方式更简单，后者可以自行了解。\n生成一个personal_token 点击GitHub头像在下拉栏里进入Setting-Developer -\u0026gt; Setting-Personal access 选择 Generate new token\n在上方填入名字ACTION_ACCESS_TOKEN，并勾选repo里的所有选项，还有admin:repo_hook\n点击 Generate token 生成 token， 并先复制保存该token（记得保存后面要用到）\n然后执行以下几步：\n1.在源码repo里新建一个blogSite分支：git checkout -b blogSite 2.在repo根目录新建嵌套的两个文件夹.github/workflows 3.在workflows里新建一个后缀为.yml的配置文件，名字自取。 4.写进去以下配置（从hugo官方文档修改而来）：  name: github pages # 名字自取 on: push: branches: - blogSite  # 这个是博客源码分支 jobs: deploy: # 任务名自取 runs-on: ubuntu-18.04\t# 在什么环境运行任务 steps: - uses: actions/checkout@v2\t# 引用actions/checkout这个action，与所在的github仓库同名 with: submodules: true # Fetch Hugo themes (true OR recursive) 获取submodule主题 fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo\t# 步骤名自取 uses: peaceiris/actions-hugo@v2\t# hugo官方提供的action，用于在任务环境中获取hugo with: hugo-version: \u0026#39;latest\u0026#39;\t# 获取最新版本的hugo # extended: true - name: Build run: hugo --minify\t# 使用hugo构建静态网页 - name: Deploy uses: peaceiris/actions-gh-pages@v3\t# 一个自动发布github pages的action with: # github_token: ${{ secrets.GITHUB_TOKEN }} 该项适用于发布到源码相同repo的情况，不能用于发布到其他repo external_repository: username/username.github.io\t# username 是你的仓库repo的名称，也是你的用户名 personal_token: ${{ secrets.ACTION_ACCESS_TOKEN }}\t# 发布到其他repo需要提供上面生成的personal access token publish_dir: ./public\t# 注意这里指的是要发布哪个文件夹的内容，而不是指发布到目的仓库的什么位置，因为hugo默认生成静态网页到public文件夹，所以这里发布public文件夹里的内容 publish_branch: master\t# 发布到哪个branch  记得修改 external_repository中的username  接下来在源码repo中添加上面的personal access token： 进入repo的Settings-Secrets一栏，选择New repository secret\n在下面填入刚才生成的token，名字注意需要与上面yml文件里XXX相同 personal_token: ${{ secrets.XXX }} 这里的名称是ACTION_ACCESS_TOKEN\n添加token之后，进入github actions里点击刚才失败的任务，点击右上角Re-run jobs 这时应该能够成功运行该任务，这说明自动部署已经开始在工作了，以后往blogSite分支push新文章时github actions会自动生成静态博客并发布到master中。\n","permalink":"https://yslinwe.github.io/%E5%8D%9A%E6%96%87/hugo%E4%BD%BF%E7%94%A8github-action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0github-pages/","summary":"Hugo使用Github Action自动部署博客到Github Pages","title":"Hugo使用Github Action自动部署博客到Github Pages"},{"content":"配置后的效果如下: 1. 安装Unity 2.下载安装.Net Core SDK https://dotnet.microsoft.com/download/dotnet\n运行命令检查安装是否成功\ndotnet --version 3.下载安装Mono SDK https://www.mono-project.com/download/stable/\n运行命令检查安装是否成功\nmono --version 4. 安装VsCode 4.1 安装VsCode插件 C# C# Extensions C# FixFormat Fixed Debugger for Unity Unity Tools Unity Code Snippets Unity Snippets 4.2 VsCode 配置omnisharp路径 设置路径\nCode -\u0026gt; Preferences -\u0026gt; Settings, 检索mono, 点击settings.json 配置omnisharp(很重要) \u0026#34;omnisharp.monoPath\u0026#34;: \u0026#34;/Library/Frameworks/Mono.framework/Versions/Current/Commands/mono\u0026#34;, \u0026#34;omnisharp.useGlobalMono\u0026#34;: \u0026#34;always\u0026#34; 设置.zshrc/.bash_profile环境变量(很重要) export FrameworkPathOverride=/Library/Frameworks/Mono.framework/Versions/Current 5.设置Unity代码编辑器 ","permalink":"https://yslinwe.github.io/%E5%8D%9A%E6%96%87/mac-vscode%E5%BC%80%E5%8F%91unity%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","summary":"Mac VSCode开发Unity环境搭建","title":"Mac VSCode开发Unity环境搭建"},{"content":"获取宝塔面板的登陆链接和用户名、密码 /etc/init.d/bt default ","permalink":"https://yslinwe.github.io/%E5%8D%9A%E6%96%87/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/","summary":"宝塔面板命令行","title":"宝塔面板命令行"},{"content":"Part1 安装oh-my-zsh  第一步 clone oh-my-zsh项目  git clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh  第二步 复制 .zshrc  cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc  第三步 更改你的默认 Shell  chsh -s /bin/zsh  修改后终端变为这样\nps:这里选择了steeef主题，不是默认的robbyrussell主题\n终端的命令提示符 Part2 主题配置  修改.zshrc  cd ~ vim ~/.zshrc  更改主题   将 ZSH_THEME=\u0026ldquo;robbyrussell\u0026rdquo; 改成 ZSH_THEME=\u0026ldquo;steeef\u0026rdquo;\n 应用到.zshrc  source ~/.zshrc P.S. 这些主题都保存在 \u0026ldquo;~/.oh-my-zsh/themes\u0026rdquo; 目录中\n插件 oh-my-zsh 的自带插件都储存在 \u0026ldquo;~/.oh-my-zsh/plugins\u0026rdquo; 目录中, 在 ~/.zshrc 中的 plugins 加入插件名称，这样设置就完成了。    安装 zsh-syntax-highlighting   对于oh-my-zsh\n git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 在 ~/.zshrc 中加入插件的名字 plugins=(zsh-syntax-highlighting) ，最后source生效\nsource ~/.zshrc  对于osx 可以直接\n brew install zsh-syntax-highlighting 并且source生效\nsource /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh ","permalink":"https://yslinwe.github.io/%E5%8D%9A%E6%96%87/mac%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96/","summary":"Mac终端美化","title":"Mac终端美化"},{"content":"一级标题 二级标题 一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 Markdown 段落 Runoob.com\nGoogle.com\n字体 斜体字体 粗体 斜粗体\n分割线   删除线 baidu.com 双波浪线是英文字符\n下划线 带下划线\n脚注 格式 [^要注明的文本]\n创建脚注格式类似这样1\nMarkdown 列表 无序  第一 第二 第三   第一 第二 第三   第一 第二 第三  有序  第一 第二 第三  列表嵌套  第一项  第一项嵌套的第一个元素 第一项嵌套的第二个元素   第二项  第二项嵌套的第一个元素 第二项嵌套的第二个元素    Markdown 区块  区块引用 菜鸟教程 学的不仅是技术更是梦想\n 区块嵌套  最外层\n 第一层嵌套\n 第二层嵌套\n   区块中列表   第一项 第二项   第一项 第二项 第三项   列表中使用区块  第一项  菜鸟教程 学的不仅是技术更是梦想\n  第二项  Markdown 代码 printf() 函数\n\u0026lt;?php echo 'RUNOOB'; function test(){ echo 'test' }  可以指定一种语言或者不指定\n$(document).ready(function()){ alert(\u0026#39;RUNOOB\u0026#39;); }); print(\u0026#34;hello world\u0026#34;) Markdown 链接 格式 链接名称\n这个是一个链接 菜鸟教程\n直接使用链接 https://runoob.com\n高级链接 这个链接用 1 作为网址变量 Google 这个链接用 runoob 作为网址变量 Runoob 注意至少空一行\nMarkdown 图片 格式 使用实例： 图片地址引用：\n这个链接用 1 作为网址变量RUNOOB\n指定图片的高度 宽度\nMarkdown 表格 Markdown 制作表格使用 | 来分隔不同的单元格 使用 - 来分隔表头和其它行\n   表头 表头     单元格 单元格   单元格 单元格    对齐方式：\n -: 设置右对齐 :- 设置左对齐 :-: 设置居中对齐     左对齐 右对齐 居中对齐     单元格 单元格 单元格   单元格 单元格 单元格    Markdown 高级技巧 支持的HTML元素\n目前支持的HTML元素有： \u0026lt;kbd\u0026gt; \u0026lt;b\u0026gt; \u0026lt;i\u0026gt; \u0026lt;em\u0026gt; \u0026lt;sup\u0026gt; \u0026lt;sub\u0026gt; \u0026lt;br\u0026gt; 等\n使用Ctrl+Alt+Del 重启电脑\n  斜体 斜体 图片上移动 图片下移动 \u0026lt;br\u0026gt;我换行了\n \n我换行了\n加反斜杆转义特殊字符  ** 正常显示星号 **\n Markdown 支持以下符号加上反斜杠变成普通字符\n \\反斜线 ` 反引号 * 星号 _ 下划线 {} 花括号 [] 方括号 () 小括号 # 井字号 + 加号 - 减号 . 英文句号 ! 感叹号\n 1. 横向流程图源码格式：\ngraph LR A[方形] --\u0026gt;B(圆角) B --\u0026gt; C{条件a} C --\u0026gt;|a=1| D[结果1] C --\u0026gt;|a=2| E[结果2] F[横向流程图] 2. 竖向流程图源码格式：\ngraph TD A[方形] --\u0026gt; B(圆角) B --\u0026gt; C{条件a} C --\u0026gt; |a=1| D[结果1] C --\u0026gt; |a=2| E[结果2] F[竖向流程图] 3. 标准流程图源码格式：\nst=\u0026gt;start: 开始框 op=\u0026gt;operation: 处理框 cond=\u0026gt;condition: 判断框(是或否?) sub1=\u0026gt;subroutine: 子流程 io=\u0026gt;inputoutput: 输入输出框 e=\u0026gt;end: 结束框 st-\u0026gt;op-\u0026gt;cond cond(yes)-\u0026gt;io-\u0026gt;e cond(no)-\u0026gt;sub1(right)-\u0026gt;op 4. 标准流程图源码格式（横向）：\nst=\u0026gt;start: 开始框 op=\u0026gt;operation: 处理框 cond=\u0026gt;condition: 判断框(是或否?) sub1=\u0026gt;subroutine: 子流程 io=\u0026gt;inputoutput: 输入输出框 e=\u0026gt;end: 结束框 st(right)-\u0026gt;op(right)-\u0026gt;cond cond(yes)-\u0026gt;io(bottom)-\u0026gt;e cond(no)-\u0026gt;sub1(right)-\u0026gt;op 5. UML时序图源码样例：\n对象A-\u0026gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--\u0026gt;对象A: 我很好(响应) 对象A-\u0026gt;对象B: 你真的好吗？ 6. UML时序图源码复杂样例：\nTitle: 标题：复杂使用 对象A-\u0026gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--\u0026gt;对象A: 我很好(响应) 对象B-\u0026gt;小三: 你好吗 小三--\u0026gt;\u0026gt;对象A: 对象B找我了 对象A-\u0026gt;对象B: 你真的好吗？ Note over 小三,对象B: 我们是朋友 participant C Note right of C: 没人陪我玩 7. UML标准时序图样例：\n%% 时序图例子,-\u0026gt; 直线，--\u0026gt;虚线，-\u0026gt;\u0026gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-\u0026gt;王五: 王五你好吗？ loop 健康检查 王五-\u0026gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 \u0026lt;br/\u0026gt;看医生... 李四--\u0026gt;\u0026gt;张三: 很好! 王五-\u0026gt;李四: 你怎么样? 李四--\u0026gt;王五: 很好!   菜鸟教程 \u0026ndash; 早点歇息 \u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://yslinwe.github.io/%E5%8D%9A%E6%96%87/markdown%E6%98%BE%E7%A4%BA/","summary":"markdown","title":"Markdown显示"},{"content":"一级标题 ======= 二级标题 ------- # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 ## Markdown 段落 Runoob.com Google.com ### 字体 *斜体字体* **粗体** ***斜粗体*** ### 分割线 *** ******* ### 删除线 ~~baidu.com~~ `双波浪线是英文字符` ### 下划线 \u0026lt;u\u0026gt;带下划线\u0026lt;/u\u0026gt; ### 脚注 格式 [^要注明的文本] 创建脚注格式类似这样[^RunooB] [^RunooB]: 菜鸟教程 -- 早点歇息 ## Markdown 列表 ##### 无序 * 第一 * 第二 * 第三 + 第一 + 第二 + 第三 - 第一 - 第二 - 第三 ##### 有序 1. 第一 2. 第二 3. 第三 ##### 列表嵌套 1. 第一项 * 第一项嵌套的第一个元素 * 第一项嵌套的第二个元素 2. 第二项 * 第二项嵌套的第一个元素 * 第二项嵌套的第二个元素 ## Markdown 区块 \u0026gt; 区块引用 \u0026gt; 菜鸟教程 \u0026gt; 学的不仅是技术更是梦想 ##### 区块嵌套 \u0026gt; 最外层 \u0026gt; \u0026gt; 第一层嵌套 \u0026gt; \u0026gt; \u0026gt; 第二层嵌套 ##### 区块中列表 \u0026gt; 1. 第一项 \u0026gt; 2. 第二项 \u0026gt; * 第一项 \u0026gt; * 第二项 \u0026gt; * 第三项 ##### 列表中使用区块 * 第一项 \u0026gt; 菜鸟教程 \u0026gt; 学的不仅是技术更是梦想 * 第二项 ## Markdown 代码 `printf()` 函数 \u0026lt;?php echo 'RUNOOB'; function test(){ echo 'test' } 可以指定一种语言或者不指定 ```javascript $(document).ready(function()){ alert('RUNOOB'); }); ```python print(\u0026quot;hello world\u0026quot;) ## Markdown 链接 ##### 格式 [链接名称](链接地址) 这个是一个链接 [菜鸟教程](https://runoob.com) 直接使用链接 \u0026lt;https://runoob.com\u0026gt; ##### 高级链接 这个链接用 1 作为网址变量 [Google][1] 这个链接用 runoob 作为网址变量 [Runoob][runoob] 注意至少空一行 [runoob]:http://www.runoob.com [1]:http://www.google.com/ ## Markdown 图片 ##### 格式 ![alt 属性文本](图片地址) ![alt 属性文本](图片地址 \u0026quot;可选标题\u0026quot;) 使用实例： ![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png) ![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png \u0026quot;RUNOOB\u0026quot;) ![](./image/1.jpeg) \u0026lt;img src=\u0026quot;./image/1.jpeg\u0026quot; width=\u0026quot;20%\u0026quot;\u0026gt; \u0026lt;img src=\u0026quot;./image/1.jpeg\u0026quot; height=\u0026quot;10%\u0026quot;\u0026gt; 图片地址引用： 这个链接用 1 作为网址变量[RUNOOB][2] [2]:http://static.runoob.com/images/runoob-logo.png **指定图片的高度 宽度** \u0026lt;img src=\u0026quot;http://static.runoob.com/images/runoob-logo.png\u0026quot; width=\u0026quot;20%\u0026quot;\u0026gt; \u0026lt;img src=\u0026quot;http://static.runoob.com/images/runoob-logo.png\u0026quot; height=\u0026quot;20%\u0026quot;\u0026gt; ## Markdown 表格 Markdown 制作表格使用 | 来分隔不同的单元格 使用 - 来分隔表头和其它行 |表头|表头| |-|-| |单元格|单元格| |单元格|单元格| 对齐方式： * -: 设置右对齐 * :- 设置左对齐 * :-: 设置居中对齐 |左对齐|右对齐|居中对齐| |:-|-:|:-:| |单元格|单元格|单元格| |单元格|单元格|单元格| ## Markdown 高级技巧 支持的**HTML**元素 目前支持的HTML元素有： `\u0026lt;kbd\u0026gt; \u0026lt;b\u0026gt; \u0026lt;i\u0026gt; \u0026lt;em\u0026gt; \u0026lt;sup\u0026gt; \u0026lt;sub\u0026gt; \u0026lt;br\u0026gt;` 等 使用\u0026lt;kbd\u0026gt;Ctrl\u0026lt;/kbd\u0026gt;+\u0026lt;kbd\u0026gt;Alt\u0026lt;/kbd\u0026gt;+\u0026lt;kbd\u0026gt;Del\u0026lt;/kbd\u0026gt; 重启电脑 \u0026gt;\u0026lt;i\u0026gt; 斜体\u0026lt;/i\u0026gt; \u0026lt;em\u0026gt;斜体\u0026lt;/em\u0026gt; 图片\u0026lt;sup\u0026gt;上移动\u0026lt;/sup\u0026gt; 图片\u0026lt;sub\u0026gt;下移动\u0026lt;/sub\u0026gt; `\u0026lt;br\u0026gt;我换行了` \u0026lt;br\u0026gt;我换行了 ##### **加反斜杆转义特殊字符** \u0026gt;\\*\\* 正常显示星号 \\*\\* **Markdown 支持以下符号加上反斜杠变成普通字符** \u0026gt;\\\\反斜线 \\` 反引号 \u0026gt;\\* 星号 \u0026gt;\\_ 下划线 \u0026gt;\\{} 花括号 \u0026gt;\\[] 方括号 \u0026gt;\\() 小括号 \u0026gt;\\# 井字号 \u0026gt;\\+ 加号 \u0026gt;\\- 减号 \u0026gt;\\. 英文句号 \u0026gt;\\! 感叹号 **1. 横向流程图源码格式：** ```mermaid graph LR A[方形] --\u0026gt;B(圆角) B --\u0026gt; C{条件a} C --\u0026gt;|a=1| D[结果1] C --\u0026gt;|a=2| E[结果2] F[横向流程图] **2. 竖向流程图源码格式：** ```mermaid graph TD A[方形] --\u0026gt; B(圆角) B --\u0026gt; C{条件a} C --\u0026gt; |a=1| D[结果1] C --\u0026gt; |a=2| E[结果2] F[竖向流程图] **3. 标准流程图源码格式：** ```flow st=\u0026gt;start: 开始框 op=\u0026gt;operation: 处理框 cond=\u0026gt;condition: 判断框(是或否?) sub1=\u0026gt;subroutine: 子流程 io=\u0026gt;inputoutput: 输入输出框 e=\u0026gt;end: 结束框 st-\u0026gt;op-\u0026gt;cond cond(yes)-\u0026gt;io-\u0026gt;e cond(no)-\u0026gt;sub1(right)-\u0026gt;op **4. 标准流程图源码格式（横向）：** ```flow st=\u0026gt;start: 开始框 op=\u0026gt;operation: 处理框 cond=\u0026gt;condition: 判断框(是或否?) sub1=\u0026gt;subroutine: 子流程 io=\u0026gt;inputoutput: 输入输出框 e=\u0026gt;end: 结束框 st(right)-\u0026gt;op(right)-\u0026gt;cond cond(yes)-\u0026gt;io(bottom)-\u0026gt;e cond(no)-\u0026gt;sub1(right)-\u0026gt;op **5. UML时序图源码样例：** ```sequence 对象A-\u0026gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--\u0026gt;对象A: 我很好(响应) 对象A-\u0026gt;对象B: 你真的好吗？ **6. UML时序图源码复杂样例：** ```sequence Title: 标题：复杂使用 对象A-\u0026gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--\u0026gt;对象A: 我很好(响应) 对象B-\u0026gt;小三: 你好吗 小三--\u0026gt;\u0026gt;对象A: 对象B找我了 对象A-\u0026gt;对象B: 你真的好吗？ Note over 小三,对象B: 我们是朋友 participant C Note right of C: 没人陪我玩 **7. UML标准时序图样例：** ```mermaid %% 时序图例子,-\u0026gt; 直线，--\u0026gt;虚线，-\u0026gt;\u0026gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-\u0026gt;王五: 王五你好吗？ loop 健康检查 王五-\u0026gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 \u0026lt;br/\u0026gt;看医生... 李四--\u0026gt;\u0026gt;张三: 很好! 王五-\u0026gt;李四: 你怎么样? 李四--\u0026gt;王五: 很好! ","permalink":"https://yslinwe.github.io/%E5%8D%9A%E6%96%87/markdownlearn/","summary":"markdown","title":"MarkdownLearn"},{"content":"牛客网IO练习 https://ac.nowcoder.com/acm/contest/5657#question\n","permalink":"https://yslinwe.github.io/%E5%8D%9A%E6%96%87/c++io%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0/","summary":"C++IO牛客网","title":"C++IO牛客网"},{"content":"Mac启动台App问号 defaults write com.apple.dock ResetLaunchPad -bool TRUE killall Dock ","permalink":"https://yslinwe.github.io/%E5%8D%9A%E6%96%87/mac%E5%90%AF%E5%8A%A8%E5%8F%B0app%E9%97%AE%E5%8F%B7/","summary":"Mac启动台App问号","title":"Mac启动台App问号"},{"content":"方法一：   第一步：打开「终端」应用程序。\n  第二步：输入如下命令：\n  defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder 第三步：按下「Return」键确认。  现在你将会在 Finder 窗口中看到那些隐藏的文件和文件夹了。\n如果你想再次隐藏原本的隐藏文件和文件夹的话，将上述命令替换成\ndefaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder 即可。\n方法二： Finder界面是，最上方，通过“前往”进入“电脑”或文件夹，\n先进入到需要显示隐藏文件的文件夹下\n接着按Command苹果键+F,在窗格上会显示搜索栏\n然后将第一个下列选择项“种类kind”选择为“其它Other”，当选择“其它”时，\n弹出新的搜索窗口，找到下面的“文件不可见File invisible”项，\n勾上后面的对勾，再单击“好OK”即可，返回文件夹，就可以看到，\n隐藏的文件已经显示出来了\n","permalink":"https://yslinwe.github.io/%E5%8D%9A%E6%96%87/mac%E4%B8%8A%E6%98%BE%E7%A4%BA%E5%92%8C%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/","summary":"Mac上显示和隐藏文件","title":"Mac上显示和隐藏文件"},{"content":"将同目录下的 mm00.jpg 文件上传到 OneDrive 网盘根目录 OneDriveUploader -s \u0026#34;mm00.jpg\u0026#34; 将同目录下的 mm00.jpg 文件上传到 OneDrive 网盘根目录,并改名为 mm01.jpg OneDriveUploader -s \u0026#34;mm00.jpg\u0026#34; -n \u0026#34;mm01.jpg\u0026#34; 将同目录下的 Download 文件夹上传到 OneDrive 网盘根目录 OneDriveUploader -s \u0026#34;Download\u0026#34; 将同目录下的 Download 文件夹上传到 OneDrive 网盘Test目录中 OneDriveUploader -s \u0026#34;Download\u0026#34; -r \u0026#34;Test\u0026#34; 将同目录下的 Download 文件夹上传到 OneDrive 网盘Test目录中, 使用 10 线程 OneDriveUploader -t 10 -s \u0026#34;Download\u0026#34; -r \u0026#34;Test\u0026#34; 将同目录下的 Download 文件夹上传到 OneDrive 网盘Test目录中, 使用 15 线程, 并设置分块大小为 20M OneDriveUploader -t 15 -b 20 -s \u0026#34;Download\u0026#34; -r \u0026#34;Test\u0026#34; ","permalink":"https://yslinwe.github.io/%E5%8D%9A%E6%96%87/onedriveuploader%E4%BD%BF%E7%94%A8/","summary":"OneDriveUploader使用","title":"OneDriveUploader使用"},{"content":"in:name example 名字中有“example” in:readme example readme中有“example” in:description example 描述中有“example” stars:\u0026gt;1000 star\u0026gt;1000 forks:\u0026gt;1000 fork\u0026gt;1000 pushed:\u0026gt;2019-09-01 2019年9月1日后有更新的 language:java 用Java编写的项目 更多打开：https://help.github.com/en/github/searching-for-information-on-github/searching-for-repositories ","permalink":"https://yslinwe.github.io/%E5%8D%9A%E6%96%87/github%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2/","summary":"Github高级搜索","title":"Github高级搜索"},{"content":"上传文件 pscp -r newlivedowload root@139.9.116.41:live_download nethogs eth0 ls -lh df -l ps -aux|grep get.py| grep -v grep nohup 运行文件\u0026gt;\u0026gt; output.log 2\u0026gt;\u0026amp;1 \u0026amp; nohup python3 -u main.py \u0026gt; test.out 2\u0026gt;\u0026amp;1 \u0026amp; 限制网速  git clone https://github.com/magnific0/wondershaper.git 在确定网卡名称以后，就可以按照以下的命令限制网络带宽：\n sudo wondershaper -a \u0026lt;adapter\u0026gt; -d \u0026lt;rate\u0026gt; -u \u0026lt;rate\u0026gt; 例如，如果网卡名称是 enp0s8，并且需要把上行、下行速率分别限制为 1024 Kbps 和 512 Kbps，就可以执行以下命令：\n sudo wondershaper -a eth0 -d 1024 -u 512 其中参数的含义是：\n-a：网卡名称 -d：下行带宽 -u：上行带宽\n如果要对网卡解除网络带宽的限制，只需要执行：\n ./wondershaper -a eth0 -c 后台运行 可以先执行：screen -S zgy ，screen就会创建一个名字为zgy的会话\n运行代码 当需要临时离开时（会话中的程序不会关闭，仍在运行）可以用快捷键Ctrl+a d(即按住Ctrl，依次再按a,d) 当回来时可以再执行执行：screen -r zgy 即可恢复到离开前创建的zgy会话的工作界面。\n screen -ls screen会列出当前存在的会话列表  恢复会话：  screen -r zgy或screen -r pid  退出会话 执行：exit ，会提示：[screen is terminating]，表示已经成功退出screen会话。\n常用快捷键 kill 掉一个窗口\n  screen -X -S 4588 quit\n  Ctrl+a c ：在当前screen会话中创建窗口\n  Ctrl+a w ：窗口列表\n  Ctrl+a n ：下一个窗口\n  Ctrl+a p ：上一个窗口\n  Ctrl+a 0-9 ：在第0个窗口和第9个窗口之间切换\n  ","permalink":"https://yslinwe.github.io/%E5%8D%9A%E6%96%87/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%91%BD%E4%BB%A4%E8%A1%8C/","summary":"服务器命令行","title":"服务器命令行"},{"content":"","permalink":"https://yslinwe.github.io/tags/","summary":"tags","title":"标签"},{"content":"","permalink":"https://yslinwe.github.io/categories/","summary":"categories","title":"类别"}]