<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>我的学习博客</title><link>https://yslinxx.gitee.io/</link><description>Recent content on 我的学习博客</description><generator>Hugo -- gohugo.io</generator><language>zh</language><managingEditor>yslinwe@gmail.com (YSL)</managingEditor><webMaster>yslinwe@gmail.com (YSL)</webMaster><copyright>©2021, All Rights Reserved</copyright><lastBuildDate>Sat, 01 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://yslinxx.gitee.io/index.xml" rel="self" type="application/rss+xml"/><item><title>数据结构学习</title><link>https://yslinxx.gitee.io/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/</link><pubDate>Wed, 21 Aug 2019 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Wed, 21 Aug 2019 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/</guid><description>数据结构学习</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2019/02/21/18/36/brasov-4011921__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>数据结构</category></item><item><title>Git Flow 的正确使用姿势</title><link>https://yslinxx.gitee.io/posts/github/git-flow-%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/</link><pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Sat, 01 May 2021 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/github/git-flow-%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/</guid><description>Git Flow 的正确使用姿势</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2020/04/28/12/40/tulips-5104311__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>git</category></item><item><title>Mac中删除.DS_Store</title><link>https://yslinxx.gitee.io/posts/mac/mac%E4%B8%AD%E5%88%A0%E9%99%A4.ds_store/</link><pubDate>Sun, 25 Apr 2021 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Sun, 25 Apr 2021 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/mac/mac%E4%B8%AD%E5%88%A0%E9%99%A4.ds_store/</guid><description>Mac中删除.DS_Store</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/02/02/16/41/flower-5974552__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>Mac</category></item><item><title>Github Action 同步gitee和github单个仓库</title><link>https://yslinxx.gitee.io/posts/github/github-action-%E5%90%8C%E6%AD%A5gitee%E5%92%8Cgithub%E5%8D%95%E4%B8%AA%E4%BB%93%E5%BA%93/</link><pubDate>Fri, 23 Apr 2021 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 23 Apr 2021 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/github/github-action-%E5%90%8C%E6%AD%A5gitee%E5%92%8Cgithub%E5%8D%95%E4%B8%AA%E4%BB%93%E5%BA%93/</guid><description>Github Action 同步gitee和github单个仓库</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2020/04/20/20/47/drip-5069808__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>Github Action</category><category>github</category></item><item><title>Markdown 调整图片位置与大小</title><link>https://yslinxx.gitee.io/posts/markdown/markdown-%E8%B0%83%E6%95%B4%E5%9B%BE%E7%89%87%E4%BD%8D%E7%BD%AE%E4%B8%8E%E5%A4%A7%E5%B0%8F/</link><pubDate>Fri, 23 Apr 2021 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 23 Apr 2021 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/markdown/markdown-%E8%B0%83%E6%95%B4%E5%9B%BE%E7%89%87%E4%BD%8D%E7%BD%AE%E4%B8%8E%E5%A4%A7%E5%B0%8F/</guid><description>Markdown 调整图片位置与大小</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2015/02/06/21/27/pyrite-626549__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>Markdown</category></item><item><title>PicGo配合gtiee实现个人图床</title><link>https://yslinxx.gitee.io/posts/picgo%E9%85%8D%E5%90%88gtiee%E5%AE%9E%E7%8E%B0%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/</link><pubDate>Fri, 23 Apr 2021 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 23 Apr 2021 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/picgo%E9%85%8D%E5%90%88gtiee%E5%AE%9E%E7%8E%B0%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/</guid><description>PicGo配合gtiee实现个人图床</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/01/22/20/16/heron-5941013__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>PicGo</category><category>个人图床</category></item><item><title>git回退上一个版本</title><link>https://yslinxx.gitee.io/posts/github/git%E5%9B%9E%E9%80%80%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%89%88%E6%9C%AC/</link><pubDate>Wed, 21 Apr 2021 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Wed, 21 Apr 2021 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/github/git%E5%9B%9E%E9%80%80%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%89%88%E6%9C%AC/</guid><description>git回退上一个版本</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/01/15/17/01/green-5919790__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>git</category></item><item><title>Hugo使用Github Action自动部署博客到Github Pages</title><link>https://yslinxx.gitee.io/posts/github/hugo%E4%BD%BF%E7%94%A8github-action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0github-pages/</link><pubDate>Tue, 20 Apr 2021 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Tue, 20 Apr 2021 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/github/hugo%E4%BD%BF%E7%94%A8github-action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0github-pages/</guid><description>Hugo使用Github Action自动部署博客到Github Pages</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2020/04/22/08/06/dolomites-5076492__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>Github Action</category><category>Hugo</category></item><item><title>Mac VSCode开发Unity环境搭建</title><link>https://yslinxx.gitee.io/posts/mac/mac-vscode%E5%BC%80%E5%8F%91unity%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link><pubDate>Tue, 20 Apr 2021 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Tue, 20 Apr 2021 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/mac/mac-vscode%E5%BC%80%E5%8F%91unity%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid><description>Mac VSCode开发Unity环境搭建</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2019/10/02/06/27/mood-4520112__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>VSCode Unity环境搭建</category></item><item><title>宝塔面板命令行</title><link>https://yslinxx.gitee.io/posts/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/</link><pubDate>Tue, 20 Apr 2021 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Tue, 20 Apr 2021 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/</guid><description>宝塔面板命令行</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2020/07/06/01/33/sky-5375005__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>宝塔面板</category><category>服务器</category></item><item><title>Mac终端美化</title><link>https://yslinxx.gitee.io/posts/mac/mac%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96/</link><pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Sat, 17 Apr 2021 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/mac/mac%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96/</guid><description>Mac终端美化</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/04/20/17/05/adler-6194438__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>Mac</category></item><item><title>Markdown显示</title><link>https://yslinxx.gitee.io/posts/markdown/markdown%E6%98%BE%E7%A4%BA/</link><pubDate>Fri, 16 Apr 2021 19:42:03 +0800</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 16 Apr 2021 19:42:03 +0800</atom:modified><guid>https://yslinxx.gitee.io/posts/markdown/markdown%E6%98%BE%E7%A4%BA/</guid><description>markdown</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2020/11/07/23/22/beach-5722568__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>markdown</category></item><item><title>MarkdownLearn</title><link>https://yslinxx.gitee.io/posts/markdown/markdownlearn/</link><pubDate>Fri, 16 Apr 2021 19:33:03 +0800</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 16 Apr 2021 19:33:03 +0800</atom:modified><guid>https://yslinxx.gitee.io/posts/markdown/markdownlearn/</guid><description>markdown</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2020/06/20/11/08/cat-5320568__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>markdown</category></item><item><title>C++IO牛客网</title><link>https://yslinxx.gitee.io/posts/c++io%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0/</link><pubDate>Fri, 16 Apr 2021 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 16 Apr 2021 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/c++io%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0/</guid><description>C++IO牛客网</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2020/04/28/12/40/tulips-5104311__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>牛客网</category></item><item><title>Mac启动台App问号</title><link>https://yslinxx.gitee.io/posts/mac/mac%E5%90%AF%E5%8A%A8%E5%8F%B0app%E9%97%AE%E5%8F%B7/</link><pubDate>Sun, 21 Feb 2021 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Sun, 21 Feb 2021 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/mac/mac%E5%90%AF%E5%8A%A8%E5%8F%B0app%E9%97%AE%E5%8F%B7/</guid><description>Mac启动台App问号</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/04/20/08/14/fiber-6193207__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>Mac</category></item><item><title>Mac上显示和隐藏文件</title><link>https://yslinxx.gitee.io/posts/mac/mac%E4%B8%8A%E6%98%BE%E7%A4%BA%E5%92%8C%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/</link><pubDate>Sat, 20 Feb 2021 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Sat, 20 Feb 2021 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/mac/mac%E4%B8%8A%E6%98%BE%E7%A4%BA%E5%92%8C%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/</guid><description>Mac上显示和隐藏文件</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2020/12/10/09/22/beach-front-5819728__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>Mac</category></item><item><title>OneDriveUploader使用</title><link>https://yslinxx.gitee.io/posts/onedriveuploader%E4%BD%BF%E7%94%A8/</link><pubDate>Sat, 11 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Sat, 11 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/onedriveuploader%E4%BD%BF%E7%94%A8/</guid><description>OneDriveUploader使用</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/04/15/15/04/desert-6181352__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>onedrive</category></item><item><title>Github高级搜索</title><link>https://yslinxx.gitee.io/posts/github/github%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/github/github%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2/</guid><description>Github高级搜索</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2020/04/21/06/41/flower-5071405__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>github高级搜索</category></item><item><title>剑指office（一）二维数组查找</title><link>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/1%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/1%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE/</guid><description>题目描述 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
[
[1,2,8,9],
[2,4,9,12],
[4,7,10,13],
[6,8,11,15]
]
给定 target = 7，返回 true。
给定 target = 3，返回 false。
示例1 输入 7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]] 返回值 true 说明 存在7，返回true 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: bool Find(int target, vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; array) { int cowS = array.size(); int rowS = array[0].size(); int cow = 0; //行 int row = rowS - 1; while(cow&amp;lt;cowS&amp;amp;&amp;amp;row&amp;gt;=0) { int val = array[cow][row]; if(val == target) return true; else if(target&amp;lt;val) row--; else cow++; } return false; } };</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/04/25/21/48/car-6207640__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>剑指office</category><category>剑指office</category><category>剑指office</category></item><item><title>剑指office（七）用两个栈实现队列</title><link>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/7%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/7%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</guid><description>题目描述 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。
n≤39n≤39
示例1 输入 4 返回值 3 1 2 3 4 5 6 7 8 class Solution { public: int Fibonacci(int n) { if(n&amp;lt;2) return n; return Fibonacci(n-1)+Fibonacci(n-2); } };</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/04/22/20/33/woman-6200105__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>剑指office</category><category>剑指office</category><category>剑指office</category></item><item><title>剑指office（三）从尾到头打印链表</title><link>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/3%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/3%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</guid><description>题目描述 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。
示例1 输入 {67,0,24,58} 返回值 [58,24,0,67] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /** * struct ListNode { * int val; * struct ListNode *next; * ListNode(int x) : * val(x), next(NULL) { * } * }; */ class Solution { public: vector&amp;lt;int&amp;gt; printListFromTailToHead(ListNode* head) { stack&amp;lt;int&amp;gt; temp; while(head!</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/04/27/05/01/abstract-6210564__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>剑指office</category><category>剑指office</category><category>剑指office</category></item><item><title>剑指office（九）跳台阶扩展问题</title><link>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/9%E8%B7%B3%E5%8F%B0%E9%98%B6%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/9%E8%B7%B3%E5%8F%B0%E9%98%B6%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98/</guid><description>题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
示例1 输入 3 返回值 4 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int jumpFloorII(int number) { if(number&amp;lt;2) return 1; int result = 1; for(int i = 1;i&amp;lt;number;i++) { result *= 2; } return result; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int jumpFloorII(int number) { if(number&amp;lt;2) return 1; vector&amp;lt;int&amp;gt; dp(number+1,0); dp[0]=dp[1]=1; for(int i = 2;i&amp;lt;=number;i++) { for(int j=0;j&amp;lt;i;j++) { dp[i] += dp[j]; } } return dp[number]; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int jumpFloorII(int number) { if(number&amp;lt;2) return 1; int result = 1; for(int i=2;i&amp;lt;=number;i++) { result = result&amp;lt;&amp;lt;1;//左移乘 右移除 } return result; } };</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/04/27/15/03/lake-6211741__340.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>剑指office</category><category>剑指office</category><category>剑指office</category></item><item><title>剑指office（二十一）栈的压入、弹出序列</title><link>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/21%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/21%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</guid><description>题目描述 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）
示例1 输入 [1,2,3,4,5],[4,3,5,1,2] 返回值 false 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class Solution { public: bool IsPopOrder(vector&amp;lt;int&amp;gt; pushV,vector&amp;lt;int&amp;gt; popV) { bool result = false; stack&amp;lt;int&amp;gt; leftS; stack&amp;lt;int&amp;gt; rightS; int pushVSize = pushV.</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/03/26/23/53/house-6127137__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>剑指office</category><category>剑指office</category><category>剑指office</category></item><item><title>剑指office（二十三）二叉树搜索树的后序遍历序列</title><link>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/23%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/23%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</guid><description>题目描述 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。（ps：我们约定空树不是二叉搜素树）
示例1 输入 [4,8,6,12,16,14,10] 返回值 true 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: bool VerifySquenceOfBST(vector&amp;lt;int&amp;gt; sequence) { if(sequence.empty()) return false; int end = *(sequence.end()-1); bool result = true; vector&amp;lt;int&amp;gt; left; vector&amp;lt;int&amp;gt; right; vector&amp;lt;int&amp;gt;::iterator iter = sequence.begin(); for(;iter!=sequence.end()-1;iter++) if(end&amp;lt;*iter) break; vector&amp;lt;int&amp;gt;::iterator splitP = iter; for(;iter!</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/04/23/20/55/couple-6202695__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>剑指office</category><category>剑指office</category><category>剑指office</category></item><item><title>剑指office（二十二）从上往下打印二叉树</title><link>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/22%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/22%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>题目描述 从上往下打印出二叉树的每个节点，同层节点从左至右打印。
示例1 输入 {5,4,#,3,#,2,#,1} 返回值 [5,4,3,2,1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: vector&amp;lt;int&amp;gt; PrintFromTopToBottom(TreeNode* root) { vector&amp;lt;int&amp;gt; result; if(root==NULL) return result; result.</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/03/29/01/12/native-american-6132665__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>剑指office</category><category>剑指office</category><category>剑指office</category></item><item><title>剑指office（二十五）复杂链表的复制</title><link>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/25%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/25%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</guid><description>题目描述 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 /* struct RandomListNode { int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) { } }; */ class Solution { public: void Copy(RandomListNode* pHead) { RandomListNode* temp; while(pHead!</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/04/22/01/27/bird-6197798__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>剑指office</category><category>剑指office</category><category>剑指office</category></item><item><title>剑指office（二十六）二叉树搜索树与双向链表</title><link>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/26%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/26%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid><description>题目描述 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: void ConvertNode(TreeNode* crruentNode,TreeNode* &amp;amp;lastNode) { if(crruentNode==NULL) return; ConvertNode(crruentNode-&amp;gt;left,lastNode); crruentNode-&amp;gt;left = lastNode; if(lastNode!</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2015/07/27/20/16/book-863418__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>剑指office</category><category>剑指office</category><category>剑指office</category></item><item><title>剑指office（二十四）二叉树中和为某一值的路径</title><link>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/24%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/24%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</guid><description>题目描述 输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。
示例1 输入 {10,5,12,4,7},22 返回值 [[10,5,7],[10,12]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; FindPath(TreeNode* root,int expectNumber) { if(root==NULL) { return result; } temp.</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/04/24/02/17/full-moon-6203112__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>剑指office</category><category>剑指office</category><category>剑指office</category></item><item><title>剑指office（二十）包含min函数的栈</title><link>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/20%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/20%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</guid><description>题目描述 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: stack&amp;lt;int&amp;gt; v; stack&amp;lt;int&amp;gt; minV; void push(int value) { v.push(value); if(minV.empty()) minV.push(value); if(minV.top()&amp;gt;value) { minV.push(value); } } void pop() { if(v.top()==minV.top()) minV.pop(); v.pop(); } int top() { return v.top(); } int min() { return minV.top(); } };</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/04/12/02/40/love-6171182__340.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>剑指office</category><category>剑指office</category><category>剑指office</category></item><item><title>剑指office（二）替换空格</title><link>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/2%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/2%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</guid><description>题目描述 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
示例1 输入 &amp;quot;We Are Happy&amp;quot; 返回值 &amp;quot;We%20Are%20Happy&amp;quot; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param s string字符串 * @return string字符串 */ string replaceSpace(string s) { for(int i = 0;i&amp;lt;s.size();i++) { if(s[i]==&amp;#39; &amp;#39;) { s = s.replace(i,1,&amp;#34;%20&amp;#34;); } } return s; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param s string字符串 * @return string字符串 */ string replaceSpace(string s) { string newS; for(int i = 0;i&amp;lt;s.</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/04/25/01/19/gerbera-6205336__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>剑指office</category><category>剑指office</category><category>剑指office</category></item><item><title>剑指office（五）用两个栈实现队列</title><link>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/5%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/5%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</guid><description>题目描述 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: void push(int node) { stack1.push(node); } int pop() { if(stack2.empty()&amp;amp;&amp;amp;!stack1.empty()) { int stackS = stack1.size(); for(int i =0;i&amp;lt;stackS;i++) { int temp = stack1.top(); stack1.pop(); stack2.push(temp); } } int val = stack2.top(); stack2.pop(); return val; } private: stack&amp;lt;int&amp;gt; stack1; stack&amp;lt;int&amp;gt; stack2; };</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/04/11/14/34/mercedes-benz-l4500s-6169985__340.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>剑指office</category><category>剑指office</category><category>剑指office</category></item><item><title>剑指office（八）跳台阶</title><link>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/8%E8%B7%B3%E5%8F%B0%E9%98%B6/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/8%E8%B7%B3%E5%8F%B0%E9%98%B6/</guid><description>题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int jumpFloor(int number) { if(number&amp;lt;=2) return number; int first = 1; int second = 2; int result = 0; for(int i = 2;i&amp;lt;number;i++) { result = first + second; first = second; second = result; } return result; } };</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2020/12/27/12/07/sunrise-5863751__340.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>剑指office</category><category>剑指office</category><category>剑指office</category></item><item><title>剑指office（六）用两个栈实现队列</title><link>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/6%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/6%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</guid><description>题目描述 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
示例1 输入 [3,4,5,1,2] 返回值 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int minNumberInRotateArray(vector&amp;lt;int&amp;gt; rotateArray) { if(rotateArray.size()==0) return 0; int first = 0; int last = rotateArray.size()-1; int mid = 0; while(last!=first) { mid = floor((first + last)/2); if(rotateArray[last]&amp;gt;rotateArray[mid]) last = mid; else if(rotateArray[first]&amp;lt;rotateArray[mid]) first = mid+1; else first++; } return rotateArray[last]; } };</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/04/22/21/05/teapot-6200179__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>剑指office</category><category>剑指office</category><category>剑指office</category></item><item><title>剑指office（十一）二进制中1的个数</title><link>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/11%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/11%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</guid><description>题目描述 输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。
示例1 输入 10 返回值 2 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int NumberOf1(int n) { int cout = 0; int mark = 0x01; while(mark) { if(mark&amp;amp;n)cout++; mark&amp;lt;&amp;lt;=1; } return cout; } }; 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: int NumberOf1(int n) { int count = 0; while(n) { count++; n = (n-1)&amp;amp;n; } return count; } };</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/01/05/01/15/home-5889366__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>剑指office</category><category>剑指office</category><category>剑指office</category></item><item><title>剑指office（十七）树的子结构</title><link>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/17%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/17%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</guid><description>题目描述 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
示例1 输入 {8,8,#,9,#,2,#,5},{8,9,#,2} 返回值 true 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) { bool result = false; if(pRoot1!</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/04/19/02/06/castle-6189967__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>剑指office</category><category>剑指office</category><category>剑指office</category></item><item><title>剑指office（十三）调整数组顺序使奇数位于偶数前面</title><link>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/13%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/13%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</guid><description>题目描述 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。
示例1 输入 [1,2,3,4] 返回值 [1,3,2,4] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param array int整型vector * @return int整型vector */ vector&amp;lt;int&amp;gt; reOrderArray(vector&amp;lt;int&amp;gt;&amp;amp; array) { // write code here for(int i=0;i&amp;lt;array.size();i++) { if(array[i]&amp;amp;1) { int j = i; if(j&amp;gt;0) while(!</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/04/17/02/02/dispersion-6184855__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>剑指office</category><category>剑指office</category><category>剑指office</category></item><item><title>剑指office（十九）顺时针打印矩阵</title><link>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/19%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/19%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</guid><description>题目描述 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.
示例1 输入 [[1,2],[3,4]] 返回值 [1,2,4,3] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class Solution { public: vector&amp;lt;int&amp;gt; printMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; matrix) { vector&amp;lt;int&amp;gt; result; int cols = matrix[0].</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/04/17/00/30/angel-6184762__340.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>剑指office</category><category>剑指office</category><category>剑指office</category></item><item><title>剑指office（十二）数值的整数次方</title><link>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/12%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/12%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</guid><description>题目描述 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
保证base和exponent不同时为0。不得使用库函数，同时不需要考虑大数问题，也不用考虑小数点后面0的位数。
示例1 输入 2.00000,3 返回值 8.00000 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: double Power(double base, int exponent) { if(exponent == 0) return 1.0; else { double result = 1; for(int i= 0;i&amp;lt;abs(exponent);i++) result *= base; if(exponent &amp;gt; 0) return result; else return 1/result; } } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: double Power(double base,int exponent) { if(exponent&amp;lt;0) { exponent = -exponent; base = 1/base; } return q_power(base,exponent); } double q_power(double base, int exponent) { if(exponent == 0) return 1.</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/04/30/19/37/orange-6219723__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>剑指office</category><category>剑指office</category><category>剑指office</category></item><item><title>剑指office（十五）反转链表</title><link>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/15%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/15%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid><description>题目描述 输入一个链表，反转链表后，输出新链表的表头。
示例1 输入 {1,2,3} 返回值 {3,2,1} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* ReverseList(ListNode* pHead) { if (!pHead) return NULL; stack&amp;lt;ListNode*&amp;gt; stackNode; while(pHead) { stackNode.</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/04/24/20/28/harrier-6205003__340.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>剑指office</category><category>剑指office</category><category>剑指office</category></item><item><title>剑指office（十八）二叉树的镜像</title><link>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/18%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/18%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</guid><description>题目描述 操作给定的二叉树，将其变换为源二叉树的镜像。
比如： 源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11 镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 5 示例1 输入 {8,6,10,5,7,9,11} 返回值 {8,10,6,11,9,7,5} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * }; */ class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param pRoot TreeNode类 * @return TreeNode类 */ TreeNode* Mirror(TreeNode* pRoot) { // write code here if(pRoot==NULL||(pRoot-&amp;gt;left==NULL&amp;amp;&amp;amp;pRoot-&amp;gt;right==NULL)) return pRoot; swapNode(pRoot); Mirror(pRoot-&amp;gt;left); Mirror(pRoot-&amp;gt;right); return pRoot; } void swapNode(TreeNode* pRoot) { TreeNode* tempVal = pRoot-&amp;gt;left; pRoot-&amp;gt;left = pRoot-&amp;gt;right; pRoot-&amp;gt;right = tempVal; } };</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2020/02/15/16/09/loveourplanet-4851331__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>剑指office</category><category>剑指office</category><category>剑指office</category></item><item><title>剑指office（十六）合并两个排序的链表</title><link>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/16%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/16%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</guid><description>题目描述 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
示例1 输入 {1,3,5},{2,4,6} 返回值 {1,2,3,4,5,6} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) { ListNode* result = NULL; ListNode* cur = NULL; if(!</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/04/22/02/05/snow-6197832__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>剑指office</category><category>剑指office</category><category>剑指office</category></item><item><title>剑指office（十四）链表中倒数第k个结点</title><link>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/14%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/14%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</guid><description>题目描述 输入一个链表，输出该链表中倒数第k个结点。
如果该链表长度小于k，请返回空。
示例1 输入 {1,2,3,4,5},1 返回值 {5} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** * struct ListNode { * int val; * struct ListNode *next; * ListNode(int x) : val(x), next(nullptr) {} * }; */ class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param pHead ListNode类 * @param k int整型 * @return ListNode类 */ ListNode* FindKthToTail(ListNode* pHead, int k) { // write code here ListNode *result = pHead; while(pHead&amp;amp;&amp;amp;k--) { pHead = pHead-&amp;gt;next; } if(k&amp;gt;0) return NULL; while(pHead) { pHead = pHead-&amp;gt;next; result = result-&amp;gt;next; } return result; } };</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2020/12/23/14/41/forest-5855196__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>剑指office</category><category>剑指office</category><category>剑指office</category></item><item><title>剑指office（十）矩形覆盖</title><link>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/10%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/10%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/</guid><description>题目描述 我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？
比如n=3时，2*3的矩形块有3种覆盖方法：
示例1 输入 4 返回值 5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int rectCover(int number) { if(number&amp;lt;=2) return number; int first = 1; int second = 2; int result = 0; for(int i = 3;i&amp;lt;=number;i++) { result = first + second; first = second; second = result; } return result; } };</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/02/01/10/13/mandala-5970032__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>剑指office</category><category>剑指office</category><category>剑指office</category></item><item><title>剑指office（四）重建二叉树</title><link>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/4%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E5%89%91%E6%8C%87offer/4%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>题目描述 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
示例1 输入 [1,2,3,4,5,6,7],[3,2,4,1,6,5,7] 返回值 {1,2,5,3,4,6,7} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /** * Definition for binary tree * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* reConstructBinaryTree(vector&amp;lt;int&amp;gt; pre,vector&amp;lt;int&amp;gt; vin) { if(pre.</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/04/30/21/13/helicopter-6219889__340.png" medium="image"><media:title type="html">featured image</media:title></media:content><category>剑指office</category><category>剑指office</category><category>剑指office</category></item><item><title>服务器命令行</title><link>https://yslinxx.gitee.io/posts/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%91%BD%E4%BB%A4%E8%A1%8C/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><author>yslinwe@gmail.com (YSL)</author><atom:modified>Fri, 10 Apr 2020 00:00:00 +0000</atom:modified><guid>https://yslinxx.gitee.io/posts/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%91%BD%E4%BB%A4%E8%A1%8C/</guid><description>服务器命令行</description><dc:creator>YSL</dc:creator><media:content url="https://yslinxx.gitee.iohttps://cdn.pixabay.com/photo/2021/04/26/08/54/beach-6208424__340.jpg" medium="image"><media:title type="html">featured image</media:title></media:content><category>服务器</category></item></channel></rss>